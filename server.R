require(shiny)
#library(ggplot2)
#library(RColorBrewer)
#library(fastcluster)
#library(NMF)
#library(grid)
#library(clValid)
#library(qusage)
#library(VennDiagram)
#library(shinydashboard)
#library(gtools)
#library(scales)
#library(reshape2)
#library(data.table)
#library(pca3d)
#library(shinyjs)
#library(stringr)
library(ggplot2)

tabs.content <- list(list(Title = "Gene Lists", Content = fluidRow(
  box(title = "Filtering Options", width = 4, status = "primary", solidHeader = FALSE,
      uiOutput("Comparison1"),
      filterOptsUI("dgeResultsTable"),
      uiOutput("merge"),
      uiOutput("modmaplmmres"),
      checkboxInput("DownloadOptions", strong("Download multiple genelists at once:", style = "color:#456dae"), FALSE),
      conditionalPanel(condition = "input.DownloadOptions",
                       uiOutput("selectComps"),
                       textInput("ziptext", label = "Filename Input", value = "All_Comparisons_Raw.05"),
                       downloadButton('downloadSelComp', 'Download selected genelists')
      )
  ),
  box(title = "Results Table", width = 8, status = "primary", solidHeader = FALSE,
      uiOutput("baylorMods"),
      uiOutput('downloadModMap'),
      uiOutput('moduleMap'),
      helpText("Right click on hyperlinks to open in new window"),
      downloadButton('downloadData', 'Download Table'),
      dataTableOutput("genelisttable")
  )
)), list(Title = "Diagnostics", Content = fluidRow(
  column(width = 4,
         box(title = "Comparison Selection", width = NULL, status = "primary",
             uiOutput("diagnosticsComparison")
         ),
         box(title = "Overview Table", width = NULL, status = "primary",
             dataTableOutput("numtable")
         )
  ),
  box(title = "P-Value Distribution Assesment", width = 8, status = "primary", solidHeader = FALSE,
      plotOutput("distplot"), plotOutput("genelistgraph"), 
      textOutput("intro")
  )
)), list(Title = "Significant Variables Heatmap", Content = fluidRow(
  box(title = "Heatmap Options", width = 4, status = "primary", solidHeader = FALSE,
      div(style = "display:inline-block", actionButton("go2", "Plot")),
      div(style = "display:inline-block", infoPopup("Plot", 'The heatmap will not update until the "Plot" button is clicked.
                                                    This allows the user to make multiple adjustments at once, without having to wait for 
                                                    each individual adjustment to update on the heatmap.', placement = "right", trigger = "click")),
      uiOutput("Comparison3"),
      filterOptsUI("dgeHeatmap"),
      uiOutput('test1'),
      div(style = "display:inline-block", checkboxInput("rowCluster", strong("Row Cluster"), value = FALSE)),
      div(style = "display:inline-block", infoPopup("Row Cluster", "Based on the PC performance, it might not be recommended to cluster the rows if the number of rows exceed 7000",
                                                    placement = "right", trigger = "click")),
      br(),
      maxValuesUI("dgeMaxValues"),
      br(),
      subsetAndOrderUI("dgeSubOrder"),
      br(),
      colClusterUI("dgeCluster"),
      br(),
      graphOptionsUI("dgeGraphOptions")
      ),
  box(title = "Heatmap", width = 8, status = "primary", solidHeader = FALSE,
      infoPopup("Help Message", 'The heat map below is constructed on individual samples for a number of scenarios,
                specifically for baseline samples only (cross sectional) or all samples at all time points.  For baseline samples,
                heatmaps can be generated based on normalizing the expression data to the median, or to a control group if applicable.
                When all samples at all time points are to be plotted, heatmaps can be generated by normalizing to the median,
                a control group, or each subjects own baseline value. Only samples that have a corresponding baseline sample are
                included in the map. The initial graph of the heat map may not be very appealing depending on the number of samples.
                The inputs on the left have a wide variety of user options that range from the type of normalized data, clustering rows
                and columns, subsetting samples and probes, etc. These options are consistent across all the unsupervised analysis plots.
                One addition, unique to the probe level heat map is the "Max value on color key" option that specifies the coloring legend
                for the heatmap index. The default is set to +/- 2. If the user would like the index to have the most extreme red and blue
                to be set to a value of +/- 4 then user simply needs to enter 4. The user can also enter 0 which will make the limits based
                on the max and min of the entire expression file.',
                placement = "bottom", trigger = "click"),
      helpText(""),
      downloadButton('downloadHeatmap1', 'Download Data'),
      downloadButton('downloadHeatmap2', 'Download Figure'),
      checkboxInput("dgePlotGeneSymbols", strong("Plot Gene Symbols?"), FALSE),
      plotOutput("heatmap1")
  )
  )), list(Title = "Venn Diagram", Content =  fluidRow(
    box(title = "Options", width = 4, status = "primary", solidHeader = FALSE,
        filterOptsUI("dgeVenn"),
        uiOutput("vennComparison"),
        selectInput("UorI", "Intersection or union:", c("Intersection" = 1, "Union" = 2), selected = 1),
        uiOutput("include"),
        uiOutput("exclude")
    ),
    column(width = 8,
           box(title = "Venn Diagram", width = NULL, status = "primary", solidHeader = FALSE,
               downloadButton('downloadVennPic', 'Download Figure'),
               plotOutput("vennDiagram")
           ),
           box(title = "Venn Results Table", width = NULL, status = "primary", solidHeader = FALSE,
               downloadButton('downloadVennData', 'Download Data'),
               dataTableOutput("vennIntersection")
           )
    )
  )), list(Title = "Modular DGE Analysis", Content =  fluidRow(
    box(title = "Options", width = 4, status = "primary", solidHeader = FALSE,
        actionButton("goModDge", "Plot"),
        br(),
        div(style = "display:inline-block", checkboxInput(inputId = "compSelect", label = strong("Comparison(s) selection:", style = "color:#456dae"), value = FALSE)),
        div(style = "display:inline-block", helpPopup("Comparison(s) selection", "This option allows the user to select specific comparisons of interest")),
        conditionalPanel(condition = "input.compSelect == true",
                         uiOutput("Comparison2")),
        uiOutput("dgeModSelection"),
        br(),
        div(style = "display:inline-block", checkboxInput("uploadModules", strong("Upload modules", style = "color:#456dae"), FALSE)),
        div(style = "display:inline-block", infoPopup("Upload modules", "Allows the user to provide their own list of modules (CSV) to plot. The CSV file should contain a single column named 'Transcript.ID' or 'Gene.Symbol', 
                                                      depending on whether the list provided is the PROBE ID's or gene Gene.Symbols.", placement = "right", trigger = "click")),
        conditionalPanel(condition = "input.uploadModules",
                         fileInput('modSelect', '', multiple = FALSE, accept=c(".csv"))
        ),
        filterOptsUI("modDgeMap"),
        br(),
        div(style = "display:inline-block", checkboxInput("LMMdeleterows", "Delete all zero rows", FALSE)),
        div(style = "display:inline-block", infoPopup("Delete all zero rows", 'Rows with all zeros (all white rows) will be deleted from the heat map.',
                                                      placement = "right", trigger = "click")),
        br(),
        checkboxInput("modDgeCluster", "Cluster rows", FALSE),
        checkboxInput("colCluster","Cluster columns", FALSE),
        br(),
        graphOptionsUI("modDgeGraphOptions", varType = "modules")
        ),
    box(title = "Module DGE Heatmap", width = 8, status = "primary", solidHeader = FALSE,
        downloadButton('downloadModDgeData', 'Download Data'),
        downloadButton('downloadModDgeMap', 'Download Figure'),
        plotOutput("modDgeMap")
    )
  )))

#Increase maximum file size input; currently set to 1GB -- Not sure if we need more.
options(shiny.maxRequestSize=1000*1024^2)
shinyServer(function(input,output, session){

  setBookmarkExclude(c("file1"))
  output$test<-renderUI({
    if(is.null(values$rowdend3)){
      if(ctrl()$id ==TRUE){
        try<-list("All Samples Median Normalized" = 3,
                  "All Samples Healthy Normalized" = 4,
                  "Non-Healthy Samples Median Normalized" = 6)
      }

      if(ctrl()$id == FALSE){
        try<-list("All Samples Median Normalized" = 3)
      }
    }

    if(!is.null(values$rowdend3)){
      if(ctrl()$id == TRUE){
        try<-list("Baseline Mean Normalized" = 1,
                  "Baseline Healthy Normalized" = 2,
                  "All Samples Mean Normalized" = 3,
                  "All Samples Healthy Normalized"= 4,
                  "All Samples Baseline Normalized"=5)
      }

      if(ctrl()$id == FALSE){
        try<-list("Baseline Mean Normalized" = 1,
                  "All Samples Mean Normalized" = 3,
                  "All Samples Baseline Normalized"=5)
      }
    }
    selectInput("set", "Select heatmap:",as.list(try))
  })

  dir.projects <- reactive({
    "C:/Users/e89628/Documents/Intern/BartDownloadFilesForTesting/BART"
  })

  list.projects <- reactive({
    list.files(dir.projects())
  })

  get.wd <- eventReactive(input$uploadserver,{return(getwd())})


  fileindex<-reactive({
    if(is.null(input$file1)){return(NULL)}
    index1<-c()
    index1[1]<-which(input$file1$name == "pvca1.png")
    index1[2]<-which(input$file1$name == "pvca2.png")
    index1[3]<-which(input$file1$name == "bartResults.rda")
    index1
  })

  values <- reactiveValues()

  updateData <- function(path, route){
    vars <- load(file = path, envir = .GlobalEnv)
    values$exprs <- NULL
    values$design <- NULL
    values$scores.ctrl <- NULL
    values$scores.base <- NULL
    values$modules <- NULL
    values$rowdend1b <- NULL
    values$rowdend2b <- NULL
    values$rowdend1 <- NULL
    values$rowdend2 <- NULL
    values$rowdend3 <- NULL
    values$norm.method <- "mean"
    values$dist.method <- "euclidean"
    values$agg.method <- "complete"
    values$time.var <- NULL
    values$control.var <- NULL
    values$control.val <- NULL
    values$baseline.var <- NULL
    values$baseline.val <- NULL
    values$sample.id <- NULL
    values$subject.id <- NULL
    values$results.file <- NULL
    values$dge.gsets <- NULL
    values$dge.annots <- NULL
    values$qusage.results <- NULL
    values$lower.ci <- NULL
    values$upper.ci <- NULL
    values$gene.sets <- NULL
    values$annots <- NULL
    values$roast.results <- NULL
    values$flow.results <- NULL
    values$flow.data <- NULL
    values$metab.results <- NULL
    values$metab.data <- NULL
    values$corr.num <- NULL
    values$corr.names <- NULL
    values$x.var <- NULL
    values$y.var <- NULL
    values$corr.method <- NULL
    values$corrs <- NULL
    values$corr.files <- NULL
    #values$baylorMod <- TRUE
    setwd(route)
    for (var in vars){
      values[[var]] <- get(var, .GlobalEnv)
    }
    return(values)
  }
  
  baylorMod <- reactive({
   if(is.null(values$dge.gsets)){
    baylorMod <- FALSE
   } else{
    baylorMod <- input$baylorMods
   }
   baylorMod
  })
  
  unsupervisedBaylorMod <- reactive({
   baylorMod <- input$baylorModules
   baylorMod
  })

  observe({
    if(is.null(input$file1)) return(NULL)
    mypath<-input$file1[[fileindex()[3], 'datapath']]
    updateData(mypath, tempdir())
  })
  
  design <- reactive({
    if(is.null(values$design)){return(NULL)}
    des <- values$design[[which(names(values$design) %in% c("microarray", "rnaseq"))]]
    flow <- values$design[[which(names(values$design) %in% c("flow"))]]
    metab <- values$design[[which(names(values$design) %in% c("metab"))]]
    z <- list(des = des, flow = flow, metab = metab)
    return(z)
  })
  
  sample.id <- reactive({
    if(is.null(values$sample.id)){return(NULL)}
    id <- values$sample.id[[which(names(values$sample.id) %in% c("microarray", "rnaseq"))]]
    flow <- values$sample.id[[which(names(values$sample.id) %in% c("flow"))]]
    metab <-  values$sample.id[[which(names(values$sample.id) %in% c("metab"))]]
    z <- list(id = id, flow = flow, metab = metab)
    return(z)
  })
  
  subject.id <- reactive({
    if(is.null(values$subject.id)){return(NULL)}
    id <- values$subject.id[[which(names(values$subject.id) %in% c("microarray", "rnaseq"))]]
    flow <- values$subject.id[[which(names(values$subject.id) %in% c("flow"))]]
    metab <- values$subject.id[[which(names(values$subject.id) %in% c("metab"))]]
    z <- list(id = id, flow = flow, metab = metab)
    return(z)
  })
  
  control.var <- reactive({
    if(is.null(values$control.var)){return(NULL)}
    id <- values$control.var[[which(names(values$control.var) %in% c("microarray", "rnaseq"))]]
    flow <- values$control.var[[which(names(values$control.var) %in% c("flow"))]]
    metab <- values$control.var[[which(names(values$control.var) %in% c("metab"))]]
    z <- list(id = id, flow = flow, metab = metab)
    return(z)
  })
  
  control.val <- reactive({
    if(is.null(values$control.val)){return(NULL)}
    id <- values$control.val[[which(names(values$control.val) %in% c("microarray", "rnaseq"))]]
    flow <- values$control.val[[which(names(values$control.val) %in% c("flow"))]]
    metab <- values$control.val[[which(names(values$control.val) %in% c("metab"))]]
    z <- list(id = id, flow = flow, metab = metab)
    return(z)
  })
  
  baseline.var <- reactive({
    if(is.null(values$baseline.var)){return(NULL)}
    id <- values$baseline.var[[which(names(values$baseline.var) %in% c("microarray", "rnaseq"))]]
    flow <- values$baseline.var[[which(names(values$baseline.var) %in% c("flow"))]]
    metab <- values$baseline.var[[which(names(values$baseline.var) %in% c("metab"))]]
    z <- list(id = id, flow = flow, metab = metab)
    return(z)
  })
  
  baseline.val <- reactive({
    if(is.null(values$baseline.val)){return(NULL)}
    id <- values$baseline.val[[which(names(values$baseline.val) %in% c("microarray", "rnaseq"))]]
    flow <- values$baseline.val[[which(names(values$baseline.val) %in% c("flow"))]]
    metab <- values$baseline.val[[which(names(values$baseline.val) %in% c("metab"))]]
    z <- list(id = id, flow = flow, metab = metab)
    return(z)
  })
  
  time.var <- reactive({
    if(is.null(values$time.var)){
     id <- flow <- metab <- NULL
    } else{
     id <- values$time.var[[which(names(values$time.var) %in% c("microarray", "rnaseq"))]]
     flow <- values$time.var[[which(names(values$time.var) %in% c("flow"))]]
     metab <- values$time.var[[which(names(values$time.var) %in% c("metab"))]]
    }
    z <- list(id = id, flow = flow, metab = metab)
    return(z)
  })
  
  ctrl <- reactive({
    if(is.null(values$control.var) || is.null(values$control.val)){return(NULL)}
    id <- flow <- metab <- FALSE
    if(!is.null(control.var()$id) & !is.null(control.val()$id)){
      id <- TRUE
    }
    if(!is.null(control.var()$flow) & !is.null(control.val()$flow)){
      flow <- TRUE
    }
    if(!is.null(control.var()$metab) & !is.null(control.val()$metab)){
      metab <- TRUE
    }
    z <- list(id = id, flow = flow, metab = metab)
    return(z)
  })

  output$versionbox <- renderValueBox({
    valueBox(
      paste0("Software Version: BETA \nRelease Date: TBD"), version$version.string, icon = icon("th-list"),
      color = "purple"
    )
  })

  output$version <- renderPrint({
    writeLines("Software Version: BETA \nRelease Date: TBD")
    writeLines(version$version.string)
  })

  output$path <- renderText({
    path <- values$project.name
    path
  })


  ############ Design File and Summary Statistics ##############################

  output$SumStat <- renderMenu({
    if(is.null(values$design)){
      return(strong(""))
    }
    if(is.null(design()$des) == FALSE){
      if(length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) == 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("PVCA", tabName = "pvca")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("PVCA", tabName = "pvca"),
                        menuSubItem("Fast QC Report", tabName = "fastqc")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) > 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("PVCA", tabName = "pvca"),
                        menuSubItem("QC files upload", tabName = "qcupload")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("Fast QC Report", tabName = "fastqc")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) > 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("QC files upload", tabName = "qcupload")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) > 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("Fast QC Report", tabName = "fastqc"),
                        menuSubItem("QC files upload", tabName = "qcupload")))
      }
      else{
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("PVCA", tabName = "pvca"),
                        menuSubItem("Fast QC Report", tabName = "fastqc"),
                        menuSubItem("QC files upload", tabName = "qcupload")))
      }
    }
  })


  output$designDataTable<- renderDataTable({
    design()$des
  })

  output$downloadDesign <- downloadHandler(

    filename = function() {paste(values$project.name,'_Design','.csv', sep='')  },
    content = function(file) {
      write.csv(design()$des, file, row.names = FALSE)
    }
  )

  output$downloadSummary0 <- downloadHandler(

    filename = function() {'SummaryStats_Table1.csv'},
    content = function(file) {
      write.csv(table_0(), file, row.names = FALSE)
    }
  )

  output$summaryName<-renderUI({
    selectizeInput("summary_var", "Main Variable for Summarization:", names(design()$des), multiple = TRUE, selected = NULL,
                   options = list(maxItems = 1))
  })

  output$groupingVar1 <- renderUI({
    selectizeInput("groupingVar1", "Grouping Factor 1 (e.g. responder status):", names(design()$des),multiple = TRUE, selected = NULL,
                options = list(maxItems = 1))
  })
  
  output$groupingVar2 <-renderUI({
    selectizeInput("groupingVar2", "Grouping Factor 2 (e.g. time):", names(design()$des), multiple = TRUE, selected = NULL,
                options = list(maxItems = 1))
  })

  output$summaryText<-renderUI({
    if(is.null(input$summary_var)){return(NULL)}
    if(is.null(input$groupingVar1) & is.null(input$groupingVar2)){
      return(HTML(paste(strong("Table:"), "Summary Statistics for", input$summary_var, sep=" ")))
    }
    if(!is.null(input$groupingVar1) & is.null(input$groupingVar2)){
      return(HTML(paste(strong("Table:"), "Summary Statistics for", input$summary_var, "by",input$groupingVar1,sep=" ")))
    }
    if(!is.null(input$groupingVar1) & !is.null(input$groupingVar2)){
      return(HTML(paste(strong("Table:"), "Summary Statistics for", input$summary_var, "by",input$groupingVar1, "and", input$groupingVar2,sep=" ")))
    }
  })

  designForSummaryStats <- reactive({
    design <- design()$des
    time.var <- time.var()$id
    for(i in 1:ncol(design)){
     if(is.null(time.var)){
      if(is.factor(design[,i])){
       design[,i] <- as.character(design[,i])
      }
     } else{
      if(is.factor(design[,i]) || colnames(design)[i] == time.var){
       design[,i] <- as.character(design[,i])
      }
     }
      if(length(which(design[,i] == "")) > 0){
        design[,i][which(design[,i] == "")] <- NA
      }
      if(is.character(design[,i])){
        design[,i] <- as.factor(design[,i])
      }
    }
    return(design)
  })
  
  table0 <- reactive({
    if(is.null(input$summary_var)){return(NULL)}
    if(is.null(input$groupingVar1) & is.null(input$groupingVar2)){
      summaryFormula <- designForSummaryStats()[,input$summary_var]
    }
    if(!is.null(input$groupingVar1) & is.null(input$groupingVar2)){
      summaryFormula <- paste(input$summary_var, "~", input$groupingVar1)
      summaryFormula2 <- paste(input$groupingVar1, "~", input$summary_var)
    }
    if(!is.null(input$groupingVar1) & !is.null(input$groupingVar2)){
      summaryFormula <- paste(input$summary_var, "~", input$groupingVar1, "+", input$groupingVar2)
      summaryFormula2 <- paste(input$groupingVar1, "+", input$groupingVar2, "~", input$summary_var)
    }
    if(is.numeric(designForSummaryStats()[,input$summary_var])){
      mysummary<-function(x){
        y<-c(length(x),mean(x,na.rm = TRUE),median(x, na.rm = TRUE),sd(x, na.rm = TRUE),min(x, na.rm = TRUE),max(x, na.rm = TRUE))
        names(y)<-c("Total","Mean","Median", "Sd","Min.","Max.")
        return(y)
      }
      if(is.null(input$groupingVar1) & is.null(input$groupingVar2)){
        sum0 <- data.frame(t(data.frame(mysummary(summaryFormula))))
      } else{
        sum0 <- aggregate(as.formula(summaryFormula), data = designForSummaryStats(), mysummary)
        sum0 <- cbind(data.frame(sum0[,-ncol(sum0),drop = FALSE]),data.frame(sum0[,ncol(sum0)]))
      }
      sum0$Total <- as.character(sum0$Total)
    } else{
      mysummary<-function(x){
        y<-summary(x, na.rm = TRUE)
        y<-as.character(c(length(x),y))
        names(y)<-c("Total", names(summary(x)))
        return(y)
      }
      if(is.null(input$groupingVar1) & is.null(input$groupingVar2)){
        sum0 <- t(data.frame(mysummary(summaryFormula)))
      } else{
        sum0 <- reshape2::dcast(summaryFormula2, data = designForSummaryStats(), fun.aggregate = length)
        if(length(which(colnames(sum0) == "NA")) > 0){
          colnames(sum0)[which(colnames(sum0) == "NA")] <- "Undefined"
        }
        if(!is.null(input$groupingVar2)){
          colTotal <- rowSums(sum0[,-c(1,2)])
          sum0 <- data.frame(cbind(sum0, Total = colTotal))
          rowTotal <- c("Total","",as.character(colSums(sum0[,-c(1,2)])))
          sum0[,1] <- as.character(sum0[,1])
          sum0$Total <- as.character(sum0$Total)
          sum0 <- rbind(sum0, rowTotal)
        } else{
          colTotal <- rowSums(sum0[,-1])
          sum0 <- cbind(sum0, Total = colTotal)
          rowTotal <- c("Total", as.character(colSums(sum0[,-1])))
          sum0[,1] <- as.character(sum0[,1])
          sum0$Total <- as.character(sum0$Total)
          sum0 <- rbind(sum0, rowTotal)
        }
      }
    }
    for(i in 1:ncol(sum0)){
      if(is.numeric(sum0[,i])){
        sum0[,i] <- round(sum0[,i], as.numeric(input$digits))
      }
    }
    return(sum0)
  })
  
  dig <- function(){
    as.numeric(input$digits)
  }
  
  output$summary0 <- renderUI({
    if(input$sortableTable){
      return(DT::dataTableOutput("summaryTable"))
    } else{
      return(tableOutput("summaryTable2"))
    }
  })
  
  output$summaryTable <- DT::renderDataTable({
    table0()
  }, rownames = FALSE)
  
  output$summaryTable2 <- renderTable({
    table0()
  },digits = dig, include.rownames = FALSE)
  
  
  ################# PVCA ##################################

  output$PVCA1 <- renderImage({
    if (is.null(input$file1)){return(NULL)}
    if(is.na(fileindex()[1]) == TRUE){
      filename <- 'datapath'
    }
    else{
      filename<-input$file1[[fileindex()[1], 'datapath']]
    }

    # Return a list containing the filename and alt text
    list(src = filename,
         alt = "Principle Component 3D PLOT",
         height=300,
         width=700)

  }, deleteFile = FALSE)

  output$PVCA2 <- renderImage({
    if (is.null(input$file1)){return(NULL)}
    if(is.na(fileindex()[2]) == TRUE){
      filename <- 'datapath'
    }
    else{
      filename<-input$file1[[fileindex()[2], 'datapath']]
    }

    # Return a list containing the filename and alt text
    list(src = filename,
         alt = "PVCA Summary")

  }, deleteFile = FALSE)


  ######################### QC Metrics ################################
  output$qc_select <- renderUI(
    if(length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) < 1){
      return(NULL)
    }
    else{
      qcnames <- grep(".html", input$file1$name, value = TRUE, fixed = TRUE)
      if(length(qcnames) > 1){
        names <- c()
        for(i in 1:length(qcnames)){
          names[i] <- sub("_S.*", "", qcnames[i])
        }
        selectInput("fqc_samples", "Select sample:", names)
      }
    }
  )

  output$qc_select2 <- renderUI(
    if(length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      qcnames <- grep(".html", input$file1$name, value = TRUE, fixed = TRUE)
      if(length(qcnames) > 1){
        selectInput("fqc_read", "Select read:", c("R1", "R2"))
      }
    }
  )

  output$fqc <- renderUI(
    if(length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      qcnames <- grep(".html", input$file1$name, value = TRUE, fixed = TRUE)
      index <- which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))
      if(length(qcnames) == 1){
        return(includeHTML(input$file1$datapath[index]))
      }
      if(length(qcnames) > 1){
        names <- c()
        check <- c()
        for(i in 1:length(qcnames)){
          names[i] <- sub("_S.*", "", qcnames[i])
        }
        for(i in 1:length(qcnames)){
          check[i] <- grepl(input$fqc_read, qcnames[i], fixed = TRUE) & grepl(input$fqc_samples, qcnames[i], fixed = TRUE)
        }
        return(includeHTML(input$file1$datapath[index][check]))
      }
    }
  )


  output$dropdown <- renderUI(
    if(length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      qcnames <- grep(".csv", input$file1$name, value = TRUE, fixed = TRUE)
      index <- which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))
      selectInput("qcTab", "Select QC table:", qcnames)
    }
  )

  output$dropdowncolumns <- renderUI(
    if(length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      qctab <- read.csv(input$file1$datapath[which(input$file1$name == input$qcTab)], header = TRUE)
      numeric <- sapply(qctab, is.numeric)
      qctab <- qctab[,numeric]
      selectInput("qcCols", "Select metrics to plot:", colnames(qctab))
    }
  )

  output$QCbox <- renderUI(
    if(length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      return(plotOutput("qcbox"))
    }
  )

  output$coordflip <- renderUI(
    if(length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      checkboxInput("coord_flip", "Flip coordinates", FALSE)
    }
  )

  qc.width <- function(){
    input$qcplotsizew
  }

  qc.height <- function(){
    input$qcplotsizeh
  }

  axis_label_size_qc <- reactive({
    input$axis_label_sizeqc
  })

  axis_text_size_qc <- reactive({
    input$axis_text_sizeqc
  })

  output$qcbox <- renderPlot({
    qctab <- read.csv(input$file1$datapath[which(input$file1$name == input$qcTab)], header = TRUE)
    qcplot <- ggplot(data = qctab[,c(1,which(colnames(qctab) %in% input$qcCols))], aes(x = X)) + geom_bar(aes_string(weight = input$qcCols), fill="blue4")
    qcplot <- qcplot + theme(axis.text.x = element_text(hjust = 1, angle = 90), axis.text = element_text(size = axis_text_size_qc()),
                             axis.title = element_text(size = axis_label_size_qc())) + xlab("Samples") + ylab(input$qcCols)
    if(input$coord_flip){
      qcplot <- qcplot + coord_flip()
      qcplot
    }
    else{
      qcplot
    }
  }, height = qc.height, width = qc.width)

  output$downloadQC <- downloadHandler(

    filename = function() {paste("QC_Plot_",input$qcCols, ".png", sep = "")},
    content = function(file) {
      png(file, width = input$qcplotsizew, height = input$qcplotsizeh)
      qctab <- read.csv(input$file1$datapath[which(input$file1$name == input$qcTab)], header = TRUE)
      qcplot <- ggplot(data = qctab[,c(1,which(colnames(qctab) %in% input$qcCols))], aes(x = X)) + geom_bar(aes_string(weight = input$qcCols), fill="blue4")
      qcplot <- qcplot + theme(axis.text.x = element_text(hjust = 1, angle = 90), axis.text = element_text(size = axis_text_size_qc()),
                               axis.title = element_text(size = axis_label_size_qc())) + xlab("Samples") + ylab(input$qcCols)
      if(input$coord_flip){
        qcplot <- qcplot + coord_flip()
        print(qcplot)
      }
      else{
        print(qcplot)
      }
      dev.off()
    }
  )

  ######################### Create Module Percentage Matrices ############################

  module_matrices <- reactive({
    mod1 <- mod2 <- mod3 <- NULL
    z <- list(mod1 = mod1, mod2 = mod2, mod3 = mod3)
    return(z)
  })

  ######################### Unsupervised Side Menu ###############################

output$Unsupervised <- renderMenu({
  if(is.null(values$exprs)){
      return(strong(""))
  }
  
  if(is.null(values$scores.base) & is.null(values$scores.ctrl)){
    return(menuItem("Unupervised Analysis", icon = icon("line-chart"), tabName = "unsupervised",
                    menuSubItem("Gene Level Heat Maps", tabName = "probeheatmap"))
    )
  }
  
  if(!is.null(values$scores.base) || !is.null(values$scores.ctrl)){
    return(menuItem("Unupervised Analysis", icon = icon("line-chart"), tabName = "unsupervised",
                    menuSubItem("Gene Level Heat Maps", tabName = "probeheatmap"),
                    menuItem("Module Maps", icon = icon("angle-double-right"), tabName = "moduleMap"))
    )
  }
})


  #################################### Module Maps ############################
  
  output$baylorModules <- renderUI({
   checkboxInput("baylorModules", strong("Are plotted scores from Baylor modules?"), FALSE)
  })
  
  output$baseOrCtrl <- renderUI({
    if(is.null(values$scores.ctrl) & is.null(values$scores.base)){return(NULL)}
    if(!is.null(values$scores.ctrl) & !is.null(values$scores.base)){
      return(
        selectizeInput("baseOrCtrl", "Proportions With Respect to Baseline or Controls:", choices = c("With Respect to Baseline", "With Respect to Controls"))
      )
    }
    if(!is.null(values$scores.ctrl) & is.null(values$scores.base)){
      return(
        selectizeInput("baseOrCtrl", "Proportions With Respect to Baseline or Controls:", choices = c("With Respect to Controls"))
      )
    } 
    if(is.null(values$scores.ctrl) & !is.null(values$scores.base)){
      return(
        selectInput("baseOrCtrl", "Proportions With Respect to Baseline or Controls:", choices = c("With Respect to Baseline"))
      )
    } 
  })
  
  output$modSelection <- renderUI({
    if(!unsupervisedBaylorMod()){return(NULL)}
    selectizeInput("moduleSelection", "Module to include:", c("All", "Only Annotated", "First Round", "First Two Rounds", "First Three Rounds", "First Four Rounds", "First Five Rounds",
                                                              "First Six Rounds", "First Seven Rounds", "First Eight Rounds"), "First Six Rounds")
  })
  
  modData <- reactive({
    if(is.null(input$baseOrCtrl)){return(NULL)}
    if(input$baseOrCtrl == "With Respect to Baseline"){
      dat <- 100*(values$scores.base-1)
    } 
    if(input$baseOrCtrl == "With Respect to Controls"){
      dat <- 100*(values$scores.ctrl-1)
    } 
    if(unsupervisedBaylorMod()){
      if(input$moduleSelection == "Only Annotated"){
        dat <- dat[grep(" ", rownames(dat)),]
      } else if(input$moduleSelection == "First Round"){
        #dat <- dat[1:2,]
        dat <- dat[grep("^M1", rownames(dat)),]
      } else if(input$moduleSelection == "First Two Rounds"){
        #dat <- dat[1:5,]
        dat <- dat[grep("^M1|^M2", rownames(dat)),]
      } else if(input$moduleSelection == "First Three Rounds"){
        #dat <- dat[1:11,]
        dat <- dat[grep("^M1|^M2|^M3", rownames(dat)),]
      } else if(input$moduleSelection == "First Four Rounds"){
        #dat <- dat[1:27,]
        dat <- dat[grep("^M1|^M2|^M3|^M4", rownames(dat)),]
      } else if(input$moduleSelection == "First Five Rounds"){
        #dat <- dat[1:42,]
        dat <- dat[grep("^M1|^M2|^M3|^M4|^M5", rownames(dat)),]
      } else if(input$moduleSelection == "First Six Rounds"){
        #dat <- dat[1:62,]
        dat <- dat[grep("^M1|^M2|^M3|^M4|^M5|^M6", rownames(dat)),]
      } else if(input$moduleSelection == "First Seven Rounds"){
        #dat <- dat[1:97,]
        dat <- dat[grep("^M1|^M2|^M3|^M4|^M5|^M6|^M7", rownames(dat)),]
      } else if(input$moduleSelection == "First Eight Rounds"){
        #dat <- dat[1:208,]
        dat <- dat[grep("^M1|^M2|^M3|^M4|^M5|^M6|^M7|^M8", rownames(dat)),]
      } 
    }
    des <- design()$des
    dist <- dist(dat)
    hcl <- fastcluster::hclust(dist)
    ddm <- as.dendrogram(hcl)
    Rowv <- rowMeans(dat, na.rm = TRUE)
    ddm <- reorder(ddm, Rowv)
    des <- des[match(colnames(dat), des[,sample.id()$id], nomatch = 0),]
    x <- list(dat = dat, ddm = ddm, des = des)
    return(x)
  })
  
  modGraphParams <- eventReactive(input$goMod,{
    params <- callModule(graphOptions, "modGraphOptions", varType = "modules")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    circleSize <- params$circleSize
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution, 
                   circleSize = circleSize)
    return(params)
  })
  
  modResolution <- reactive({
   params <- callModule(graphOptions, "modGraphOptions", varType = "modules")
   return(params$resolution)
  })
  
  modWidth <- function(){modGraphParams()$width}
  modHeight <- function(){modGraphParams()$height}
  
  callModule(subsetAndOrderRenderUI, "modSubOrder", des = reactive(design()$des))
  callModule(clusterAssociationRenderUI, "modAssociation", data = reactive(design()$des))
  
  modRowCluster <- eventReactive(input$goMod,{
    dat<- callModule(uploadVarsRowCluster, "mod", data = reactive(modData()$dat), dendro = reactive(modData()$ddm))
    x <- dat$x
    ddm <- dat$ddm
    labelRows <- dat$labelRows
    y <- list(x = x, ddm = ddm, labelRows = labelRows)
    return(y)
  })
  
  modClusterData <- eventReactive(input$goMod,{
    x <- callModule(colCluster, "modCluster", des = reactive(modOrderedData()$colAnnot), data = reactive(modOrderedData()$x))
    return(x)
  })
  
  modGen_clustTab <- reactive({
    x <- callModule(clusterAssociation, "modAssociation", des = reactive(modOrderedData()$design), hclObj = reactive(modClusterData()$hcl))
    return(x)
  })
  
  modOrderedData <- eventReactive(input$goMod,{
    dat <- callModule(subsetAndOrder, "modSubOrder", des = reactive(modData()$des), data = reactive(modRowCluster()$x), 
                      sampleAnnot = reactive(sample.id()$id))
    x <- dat$dat
    colAnnot <- dat$colAnnot
    design <- dat$design
    z <- list(x = x, colAnnot = colAnnot, design = design)
    return(z)
  })
  
  modColors <- eventReactive(input$goMod,{
    x <- callModule(annColors, "modSubOrder", reactive(modOrderedData()$colAnnot))
    return(x)
  })
  
  output$modHeatmap <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(modOrderedData()$x,Rowv = modRowCluster()$ddm, Colv = modClusterData()$colddm, circle_size = modGraphParams()$circleSize, treeheight = modGraphParams()$treeHeight, fontsize = modGraphParams()$fontSize, cexRow = 1.2, 
                             annheight = modGraphParams()$legendSize,color = colorRampPalette(c("blue", "white", "red"))(100),annCol = modClusterData()$colAnnot,annColors = modColors(),
                             breaks=seq(-100,100,by=4))
                   
                 }
    )
  }, width = modWidth, height = modHeight)
  
  output$downloadModPlot3Other <- downloadHandler(
    filename = function() {paste(values$project.name, '_Longitudinal_ModuleMap','.png', sep = '')},
    content = function(file){
      res <- modGraphParams()$resolution
      height <- modGraphParams()$height
      width <- modGraphParams()$width
      png(file, width = (res/72)*width, height = (res/72)*height, res = res)
      print(aheatmap2(modOrderedData()$x,Rowv = modRowCluster()$ddm, Colv = modClusterData()$colddm, circle_size = modGraphParams()$circleSize, treeheight = modGraphParams()$treeHeight, fontsize = modGraphParams()$fontSize, cexRow = 1.2, 
                      annheight = modGraphParams()$legendSize,color = colorRampPalette(c("blue", "white", "red"))(100),annCol = modClusterData()$colAnnot,annColors = modColors(),
                      breaks=seq(-100,100,by=4)))
      dev.off()
    }
  )
  
  output$downloadModMap3Other <- downloadHandler(
    filename = function() {paste(values$project.name,'_Longitudinal_ModuleMapData','.csv', sep='')  },
    content = function(file) {
      write.csv(heatDataDownload(), file, row.names = TRUE)
    }
  )


  output$modOptimalNumber <- renderText({
    paste("Optimal number of clusters =", modClusterData()$opt_num )
  })
  
  output$modClusterPlot <- renderPlot({
    barplot(modClusterData()$d, names.arg = 2:round(nrow(modOrderedData()$colAnnot)/2), xlab = "Number of Clusters", ylab = "Dunn's Index",cex.main = 1.5, col = "#4ba9d6")
  })

  output$downloadClusterPlot2Other <- downloadHandler(
    filename = function() {paste(values$project.name,'_','Cluster_Plot_Longitudinal','.png', sep = '')},
    content = function(file){
      png(file, width = 800)
      print(barplot(modClusterData()$d, names.arg = 2:round(nrow(modOrderedData()$colAnnot)/2), xlab = "Number of Clusters", ylab = "Dunn's Index"))
      dev.off()
    }
  )
  
  output$cluster_output3Other <- renderTable({
    if(is.null(modGen_clustTab())){return(NULL)}
    modGen_clustTab()$table1
  }, include.rownames = FALSE, digits = 0)
  
  output$explanation2Other <- renderText({
    if(is.null(modGen_clustTab())){return(NULL)}
    if(ncol(modGen_clustTab()$table2) > 1){
      print("The table below is the table the tests are run on. It is the same as the table above, except the columns with zero counts have been deleted.")
    }
  })
  
  output$cluster_tab2Other <- renderTable({
    if(is.null(modGen_clustTab())){return(NULL)}
    if(ncol(modGen_clustTab()$table2) > 1){
      modGen_clustTab()$table2
    }
  }, include.rownames = FALSE)
  
  output$chisquare_test3Other <- renderText({
    if(is.null(modGen_clustTab())){return(NULL)}
    if(ncol(modGen_clustTab()$table2) > 1){
      if(modGen_clustTab()[[3]]$p.value < .001){
        paste("Chi_square statistic = ", round(modGen_clustTab()[[3]]$statistic, 2), ",", "p-value < .001")
      }
      else{
        paste("Chi-Square Test Statistic = ", round(modGen_clustTab()[[3]]$statistic, 2), ",", "p-value =", round(modGen_clustTab()[[3]]$p.value, 3))
      }
    }
  })
  
  output$fisher3Other <- renderText({
    if(is.null(modGen_clustTab())){return(NULL)}
    if(ncol(modGen_clustTab()$table2) > 1){
      if(modGen_clustTab()[[4]]$p.value < .001){
        paste("Fishers Exact Test: p-value < .001")
      }
      else{
        paste("Fishers Exact Test: p-value = ", round(modGen_clustTab()[[4]]$p.value, 3))
      }
    }
  })

  ##################################### Gene Level Heat Map #####################################

  heatmapdata <- reactive({
    if (input$set==1){#heatmapbase1
      if(ctrl()$id == TRUE){
        base_sample_name <- design()$des$columnname[which(design()$des[,baseline.var()$id] == baseline.val()$id & design()$des[,control.var()$id] != control.val()$id)]
        index <- which(colnames(values$exprs) %in% base_sample_name)
      }
      if(ctrl()$id == FALSE){
        base_sample_name <- design()$des$columnname[which(design()$des[,baseline.var()$id] == baseline.val()$id)]
        index <- which(colnames(values$exprs) %in% base_sample_name)
      }
        exp_base_sam <- values$exprs[, index]
        des_base_sam <- design()$des[which(design()$des$columnname %in% colnames(exp_base_sam)),]
        y<-manipulateData(y = exp_base_sam, x = des_base_sam,colname = "columnname")
        ddm<-values$rowdend1b
    }
    if (input$set==2){#heatmapbase2
      base_sample_name <- design()$des$columnname[which(design()$des[,baseline.var()$id]==baseline.val()$id | design()$des[,control.var()$id]==control.val()$id)]
      index <- which(colnames(values$exprs) %in% base_sample_name)
      exp_base_sam <- values$exprs[, index]
      des_base_sam <- design()$des[which(design()$des$columnname %in% colnames(exp_base_sam)), ]
      y<-manipulateData(y=exp_base_sam,x=des_base_sam,colname ="columnname",ref.var=control.var()$id,ref.val=control.val()$id,long=FALSE,keep.ref=TRUE)
      ddm<-values$rowdend2b
    }
    if(input$set==3){#heatmap1
      y<-manipulateData(y=values$exprs,x=design()$des,colname="columnname")
      ddm<-values$rowdend1
    }
    if(input$set==4){#heatmap2
      y <- manipulateData(y = values$exprs, x = design()$des, colname = "columnname", ref.var = control.var()$id, ref.val = control.val()$id, long = FALSE, keep.ref = TRUE)
      ddm<-values$rowdend2
    }
    if(input$set==5){#heatmap3
      if(ctrl()$id==TRUE){
        des_w_controls<-design()$des[which(design()$des$columnname %in% colnames(values$exprs)),]
        des_wo_controls<-design()$des[-which(design()$des[,control.var()$id]==control.val()$id),]
        h5index<-which(colnames(values$exprs) %in% des_wo_controls$columnname)
        y<-manipulateData(y=values$exprs[,h5index],x=des_wo_controls,colname="columnname",ref.var=baseline.var()$id,ref.val=baseline.val()$id,long=TRUE,subject.id=subject.id()$id,keep.ref=FALSE)
      }
      if(ctrl()$id==FALSE){
        y<-manipulateData(y=values$exprs,x=design()$des,colname="columnname",ref.var=baseline.var()$id,ref.val=baseline.val()$id,long=TRUE,subject.id=subject.id()$id,keep.ref=FALSE)
      }
      ddm<-values$rowdend3
    }
    z<-list(y=y,ddm=ddm)
    return(z)
  })
  
  output$plotGeneSymbols <- renderUI({
   if(is.null(values$results.file)){return(NULL)}
   if(all.equal(as.character(values$results.file$Transcript.ID), as.character(values$results.file$Gene.Symbol)) == TRUE){return(NULL)}
   checkboxInput("plotGeneSymbols", "Plot Gene Symbols?", FALSE)
  })
  
  output$dgePlotGeneSymbols <- renderUI({
   if(all.equal(as.character(values$results.file$Transcript.ID), as.character(values$results.file$Gene.Symbol)) == TRUE){return(NULL)}
   checkboxInput("dgePlotGeneSymbols", "Plot Gene Symbols?", FALSE)
  })

  heatmapname<-reactive({
    if(input$set==1) heattxt<-"Baseline Median Normalized"
    if(input$set==2) heattxt<-"Baseline Healthy Normalized"
    if(input$set==3) heattxt<-"All Samples Median Normalized"
    if(input$set==4) heattxt<-"All Samples Healthy Normalized"
    if(input$set==5) heattxt<-"All Samples Normalized to each Subjects Baseline"
    return(heattxt)
  })
  
  graphParams <- eventReactive(input$go, {
    params <- callModule(graphOptions, "unsupervisedGraphOptions")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution)
    return(params)
  })
  
  resolution <- reactive({
    params <- callModule(graphOptions, "unsupervisedGraphOptions")
    return(params$resolution)
  })
  plotWidth <- function(){graphParams()$width}
  plotHeight <- function(){graphParams()$height}
  
  callModule(subsetAndOrderRenderUI, "unsupervisedSubOrder", des = reactive(design()$des))
  callModule(clusterAssociationRenderUI, "unsupervisedAssociation", data = reactive(design()$des))
  
  rowCluster <- eventReactive(input$go, {
    dat <- callModule(uploadVarsRowCluster, "transcripts", data = reactive(heatmapdata()$y$exprs.norm), dendro = reactive(heatmapdata()$ddm))
    x <- dat$x
    ddm <- dat$ddm
    labelRows <- dat$labelRows
    rowAnnot <- dat$rowAnnot
    y <- list(x = x, ddm = ddm, labelRows = labelRows, rowAnnot = rowAnnot)
    return(y)
  })
  
  clusterData <- eventReactive(input$go,{
    x <- callModule(colCluster, "unsupervisedCluster", des = reactive(orderedData()$colAnnot), data = reactive(orderedData()$x))
    return(x)
  })
  
  gen_clustTab <- reactive({
    x <- callModule(clusterAssociation, "unsupervisedAssociation", des = reactive(orderedData()$design), hclObj = reactive(clusterData()$hcl))
    return(x)
  })

  orderedData <- reactive({
    dat <- callModule(subsetAndOrder, "unsupervisedSubOrder", des = reactive(heatmapdata()$y$design.norm), data = reactive(rowCluster()$x), 
                    sampleAnnot = reactive(sample.id()$id))
    x <- dat$dat
    colAnnot <- dat$colAnnot
    design <- dat$design
    z <- list(x = x, colAnnot = colAnnot, design = design)
    return(z)
  })
  
  maxRangeData <- eventReactive(input$go, {
    x <- callModule(maxValues, "unsupervisedMaxValues", reactive(orderedData()$x))
    if(!is.null(values$results.file) & all.equal(values$results.file$Transcript.ID, values$results.file$Gene.Symbol) != TRUE){
     if(input$plotGeneSymbols){
      rownames(x) <- make.unique(as.character(values$results.file$Gene.Symbol[match(rownames(x), as.character(values$results.file$Transcript.ID))]))
     }
    }
    return(x)
  })
  
  heatColors <- eventReactive(input$go, {
    x <- callModule(annColors, "unsupervisedSubOrder", reactive(orderedData()$colAnnot))
    return(x)
  })
  
  output$heatmap <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(maxRangeData(),Rowv = rowCluster()$ddm,Colv = clusterData()$colddm, treeheight = graphParams()$treeHeight, fontsize = graphParams()$fontSize, cexRow = 1.2, 
                             annheight = graphParams()$legendSize,color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = clusterData()$colAnnot,annColors = heatColors(),labRow=rowCluster()$labelRows,
                             annRow = rowCluster()$rowAnnot,breaks=0)
                 }
    )
  }, width = plotWidth, height = plotHeight)
  
  output$downloadHeatmap <- downloadHandler(
    filename = function() {paste('Gene_Level_Heatmap','.png', sep = '')},
    content = function(file){
      png(file, width = (resolution()/72)*graphParams()$width, height = (resolution()/72)*graphParams()$height, res = resolution())
        print(aheatmap2(maxRangeData(),Rowv = rowCluster()$ddm,Colv = clusterData()$colddm, treeheight = graphParams()$treeHeight, fontsize = graphParams()$fontSize, cexRow = 1.2, 
                        annheight = graphParams()$legendSize,color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = clusterData()$colAnnot,annColors = heatColors(),labRow=rowCluster()$labelRows, 
                        breaks=0))
      dev.off()
    }
  )
  
  output$downloadHeatmapData <- downloadHandler(
    filename = function() {paste(values$project.name,'_',heatmapname(),'.csv', sep='')  },
    content = function(file) {
      write.csv(heatDataDownload(), file, row.names = TRUE)
    }
  )
  
  heatDataDownload <- reactive({
    x <- orderedData()$x
    if(is.na(rowCluster()$ddm)){
      if(is.na(clusterData()$colddm)){
        x <- x
      } else {
        x <- x[,order.dendrogram(clusterData()$colddm)]
      }
    } else {
      if(is.na(clusterData()$colddm)){
        x <- x[order.dendrogram(rowCluster()$ddm),]
      } else {
        x <- x[order.dendrogram(rowCluster()$ddm), order.dendrogram(clusterData()$colddm)]
        x <- x[nrow(x):1,]
      }
    }
    return(x)
  })


  output$clusterPlot <- renderPlot({
    barplot(clusterData()$d, names.arg = 2:round(nrow(orderedData()$colAnnot)/2), xlab = "Number of Clusters", ylab = "Dunn Index",main = "Dunn Index for Cluster Number Selection", cex.main = 1.5, col = "#4ba9d6")
  })

  output$downloadClusterPlot3 <- downloadHandler(
    filename = function() {paste('DunnIndexPlot','.png', sep = '')},
    content = function(file){
      png(file, width = 800)
      print(barplot(clusterData()$d, names.arg = 2:round(nrow(orderedData()$colAnnot)/2), xlab = "Number of Clusters", ylab = "Dunn's Index", col = "#4ba9d6"))
      dev.off()
    }
  )

  output$OptimalNumber <- renderText({
    paste("Optimal number of clusters =", clusterData()$opt_num )
  })

  output$cluster_output4 <- renderTable({
    if(is.null(gen_clustTab())){return(NULL)}
    gen_clustTab()$table1
  }, include.rownames = FALSE, digits = 0)

  output$explanation3 <- renderText({
    if(is.null(gen_clustTab())){return(NULL)}
    if(ncol(gen_clustTab()$table2) > 1){
      print("The table below is the table the tests are run on. It is the same as the table above, except the columns with zero counts have been deleted.")
    }
  })

  output$cluster_tab3 <- renderTable({
    if(is.null(gen_clustTab())){return(NULL)}
    if(ncol(gen_clustTab()$table2) > 1){
      gen_clustTab()$table2
    }
  }, include.rownames = FALSE)

  output$chisquare_test4 <- renderText({
    if(is.null(gen_clustTab())){return(NULL)}
    if(ncol(gen_clustTab()$table2) > 1){
      if(gen_clustTab()[[3]]$p.value < .001){
        paste("Chi_square statistic = ", round(gen_clustTab()[[3]]$statistic, 2), ",", "p-value < .001")
      }
      else{
        paste("Chi-Square Test Statistic = ", round(gen_clustTab()[[3]]$statistic, 2), ",", "p-value =", round(gen_clustTab()[[3]]$p.value, 3))
      }
    }
  })

  output$fisher4 <- renderText({
    if(is.null(gen_clustTab())){return(NULL)}
    if(ncol(gen_clustTab()$table2) > 1){
      if(gen_clustTab()[[4]]$p.value < .001){
        paste("Fishers Exact Test: p-value < .001")
      }
      else{
        paste("Fishers Exact Test: p-value = ", round(gen_clustTab()[[4]]$p.value, 3))
      }
    }
  })


  ################################# DGE ###########################################

  output$diffge <- renderMenu({
    if(is.null(values$results.file)){
      return(strong(""))
    }
    else{
      return(menuItem("DGE", icon = icon("area-chart"), tabName = "dge",
                      menuSubItem("Overview", tabName = "overview"),
                      menuSubItem("Gene List Maker", tabName = "genelistmaker"),
                      menuSubItem("Gene Search", tabName = "genesearch")))
    }
  })

  siglist <- reactive({
    results.file <- values$results.file
    estimates <- results.file[,grep("Estimate", names(results.file)), drop = FALSE]
    pvals <- results.file[,grep("^P.Value", names(results.file)), drop = FALSE]
    #fdr.pvals <- data.frame(apply(pvals, 2, p.adjust, method = "fdr"))
    fdr.pvals <- results.file[,grep("FDR.P.Value", names(results.file)), drop = FALSE]
    #colnames(fdr.pvals) <- gsub("P.Value","FDR.P.Value",colnames(fdr.pvals))
    bonf.pvals <- data.frame(apply(pvals, 2, p.adjust, method = "bonferroni"))
    colnames(bonf.pvals) <- gsub("P.Value.","Bonf.P.Value.",colnames(bonf.pvals))
    comparisons <- gsub("Estimate.", "", colnames(estimates))
    raw <- fdr <- bonf <- c()
    if(input$overviewFc){
      if(input$selectFcSign == "+"){
        for(i in 1:ncol(estimates)){
          raw[i] <- sum(pvals[,i] <= input$alphalevel2 & estimates[,i] >= input$selectFcValue, na.rm = TRUE)
          fdr[i] <- sum(fdr.pvals[,i] <= input$alphalevel2 & estimates[,i] >= input$selectFcValue, na.rm = TRUE)
          bonf[i] <- sum(bonf.pvals[,i] <= input$alphalevel2 & estimates[,i] >= input$selectFcValue, na.rm = TRUE)
        }
      } else if(input$selectFcSign == "-"){
        for(i in 1:ncol(estimates)){
          raw[i] <- sum(pvals[,i] <= input$alphalevel2 & estimates[,i] <= -input$selectFcValue, na.rm = TRUE)
          fdr[i] <- sum(fdr.pvals[,i] <= input$alphalevel2 & estimates[,i] <= -input$selectFcValue, na.rm = TRUE)
          bonf[i] <- sum(bonf.pvals[,i] <= input$alphalevel2 & estimates[,i] <= -input$selectFcValue, na.rm = TRUE)
        }
      } else{
        for(i in 1:ncol(estimates)){
          raw[i] <- sum(pvals[,i] <= input$alphalevel2 & (estimates[,i] >= input$selectFcValue | estimates[,i] <= -input$selectFcValue), na.rm = TRUE)
          fdr[i] <- sum(fdr.pvals[,i] <= input$alphalevel2 & (estimates[,i] >= input$selectFcValue | estimates[,i] <= -input$selectFcValue), na.rm = TRUE)
          bonf[i] <- sum(bonf.pvals[,i] <= input$alphalevel2 & (estimates[,i] >= input$selectFcValue | estimates[,i] <= -input$selectFcValue), na.rm = TRUE)
        }
      }
    } else{
      raw <- apply(pvals, 2, function(x) sum(x <= input$alphalevel2, na.rm = TRUE))
      fdr <- apply(fdr.pvals, 2, function(x) sum(x <= input$alphalevel2, na.rm = TRUE))
      bonf <- apply(bonf.pvals, 2, function(x) sum(x <= input$alphalevel2, na.rm = TRUE))
    }
    overview <- data.frame(Comparison = comparisons, Raw = raw, FDR = fdr, Bonf = bonf)
    y <- list(z = overview)
    return(y)
  })

  output$sigcomptable <- renderDataTable({
    withProgress(message = 'Making the table',
                 detail = 'This may take a while...', value = 1,{
                   siglist()$z[order(siglist()$z$Raw,decreasing=TRUE),]
                 })
  })
  
  index <- reactive({
    which(names(values$results.file)== paste0("P.Value.",input$diagnosticsComparison))
  })
  
  output$diagnosticsComparison <- renderUI({
    nam <- names(values$results.file)
    index <- grep("^P.Value",nam)
    p.names <- nam[index]
    p.names <- gsub("P.Value.", "", p.names)
    return(selectizeInput("diagnosticsComparison", "Comparison:", p.names, p.names[1], multiple = FALSE))
  })
  
  pcomp <- reactive({
    x <- sub("^", "P.Value.", input$comparison)
    x
  })

  plottitle1 <- reactive({
    paste("Distribution of Raw p-values for", input$diagnosticsComparison)
  })

  output$distplot<-renderPlot({
    y<-max(hist(values$results.file[, index()])$density)
    hist(values$results.file[,index()], freq=FALSE, xlim=c(0,1), ylim=c(0,y),main=plottitle1(),
         xlab="Raw p-value's", ylab="Density")
    lines(c(0,1),c(1,1),lwd=2,lty=2)
  })

  plotdata <-reactive({
    mymatrix<-c()
    index2<-c(0.001,0.01,1:19/20)
    for (i in 1:21){mymatrix<-rbind(mymatrix,c(mycorrection(values$results.file[,index()],index2[i],"RAW"),mycorrection(values$results.file[,index()],index2[i],"FDR"),mycorrection(values$results.file[,index()],index2[i],"BONF")))}
    mydata<-data.frame(cbind(index2,mymatrix))
    names(mydata)<-c("alpha","raw","fdr","bonf")
    data.frame(mydata)
  })

  output$numtable <-renderDataTable({
    numtab<-cbind(plotdata()[,1],plotdata()[,2:4]*dim(values$results.file)[1])
    names(numtab)<-c("Alpha", "Raw", "FDR", "Bonf")
    return(numtab)
  })
  
  sel_genelists <- reactive({
    if(length(grep("All", input$comparisons_download)) > 0){
      nam <- names(values$results.file)
      index <- grep("^P.Value",nam)
      p.names <- nam[index]
      comps <- gsub("P.Value.", "", p.names)
    }
    else{
      comps <- input$comparisons_download
    }
    x.all <- list()
    for(i in 1:length(comps)){
      x <- callModule(filterOpts, "dgeResultsTable", data = reactive(values$results.file), comparison = reactive(comps[i]),"genes")
      x.all[[i]] <- x
    }
    names(x.all) <- comps
    return(x.all)
  })

  sig_ind <- reactive({
    if(!is.null(values$dge.gsets)){
      genes <- unlist(values$dge.gsets)
      gsetNames <- rep(names(values$dge.gsets), times = lapply(values$dge.gsets, length))
      modinfo <- data.frame(Module = gsetNames, Transcript.ID = genes)
      if(input$dgeResults == "Modular DGE Analysis"){
        dat <- callModule(filterOpts, "modDgeMap", data = reactive(values$results.file), data.type = "percents", geneList = reactive(modinfo))
      }
      if(input$dgeResults == "Gene Lists"){
        dat <- callModule(filterOpts, "dgeResultsTable", data = reactive(values$results.file), data.type = "percents", geneList = reactive(modinfo))
      }
      if(baylorMod() == TRUE){
        modnames <- unique(modinfo$Module)
        modnum<-gsub("M","",modnames)
        modvec<-as.numeric(unlist(strsplit(modnum,".",fixed=TRUE)))
        modmat<-matrix(modvec,ncol=2,byrow=T)
        modordnum<-table(factor(modinfo$Module,levels=modnames[order(modmat[,1],modmat[,2])],ordered=TRUE))
        mod_for_merge<-data.frame(Module=names(modordnum),Size=as.vector(modordnum))
        prop_matrix <- dat$prop_matrix[match(as.character(mod_for_merge$Module), rownames(dat$prop_matrix), nomatch = 0),,drop = FALSE]
        prop_matrix2 <- dat$prop_matrix2[match(as.character(mod_for_merge$Module), rownames(dat$prop_matrix2), nomatch = 0),,drop = FALSE]
        z <- list(prop_matrix = prop_matrix, prop_matrix2 = prop_matrix2)
      } else{
        z <- list(prop_matrix = dat$prop_matrix, prop_matrix2 = dat$prop_matrix2)
      }
      return(z)
    } else{
      return(NULL)
    }
  })
  
  ModMap_Comparison <- reactive({
    numgen <- function(x){
      d<-c()
      odd<-2*(1:20)-1
      if(length(x)==1){
        return(odd[1:x])}
      if(length(x)>1){
        for(i in 1:length(x)){d<-c(d,odd[1:x[i]])}
        return(d)}
    }
    numgen2 <- function(x){
      d<-c()
      odd<-2*(1:8)-1
      for (i in 1:length(x)){d<-c(d,rep(odd[9-i],x[i]))}
      return(d)
    }
    colorvar = sig_ind()$prop_matrix2[1:97,input$comparison]
    colgrp <- findInterval(colorvar,seq(0,2,length.out=10))
    colfunc <- colorRampPalette(c("blue","white", "red"))
    collist <- colfunc(length(unique(colgrp)))
    mycolors <- collist[colgrp]
    mycolors = colorvar
    df2 <- data.frame(
      x = numgen(c(2,3,6,16,15,20,20,15)),
      y = c(numgen2(c(2,3,6,16,15,20,20,15))),
      proportion = mycolors
    )
    test<-ggplot(df2, aes(xmin=x-1,xmax=x+1,ymin=y-1,ymax=y+1),environment=environment())+
      theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),panel.grid.major = element_blank()
            ,panel.grid.minor = element_blank()
            ,panel.border = element_blank())+geom_rect(fill="white", colour="black")+
      scale_y_continuous(breaks=c(15,13,11,9,7,5,3,1), labels=c("M1","M2","M3","M4","M5","M6","M7","M7 (21-35)"),limits=c(0,40))+
      scale_x_continuous(breaks=(2*(1:20)-1),labels=1:20,limits=c(0,40))
    
    test2<-test+coord_cartesian(xlim = c(0, 40), ylim=c(0, 16))
    test3<-test2+geom_point(aes(x=x,y=y,colour=proportion,size=500))+
      scale_colour_gradient2(low="blue", high="red", guide="colorbar",midpoint=0, limits = c(-1,1))+ 
      theme(axis.title.x=element_blank(),axis.title.y=element_blank()) + scale_size_continuous(limits=c(1,500)) + 
      guides(size = FALSE) 
    return(test3)
  })
  
  output$moduleMap <- renderUI({
    if(!baylorMod()){return(NULL)}
    plotOutput('modMap')
  })
  
  output$modmaplmmres <- renderUI({
    if(!baylorMod()){return(NULL)}
    numericInput('modmaplmmres', "Plot resolution (for downloaded plot):", min = 72, max = 400, value = 72, step = 1)
  })
  
  output$modMap <- renderPlot({
    ModMap_Comparison()
  }, width = 700, height = 190)
  
  output$baylorMods <- renderUI({
   if(is.null(values$dge.gsets)){return(NULL)}
   checkboxInput("baylorMods", strong("Are the provided gene sets baylor modules?"), FALSE)
  })
  
  output$downloadModMap <- renderUI({
    if(!baylorMod()){return(NULL)}
    downloadButton('downloadModuleMap', "Download Figure")
  })
  
  output$downloadModuleMap <- downloadHandler(
    filename = function() {paste('ModMap_Comparison','.png', sep = '')},
    content = function(file){
      png(file, width = (mod_map_lmm_res()/72)*700, height = (mod_map_lmm_res()/72)*190, res = mod_map_lmm_res())
      print(ModMap_Comparison())
      dev.off()
    }
  )
  
  output$merge <- renderUI({
    if(!is.null(values$dge.gsets)){
      return(checkboxInput("merge", "Merge gene set information", FALSE))
    } else{
      return(NULL)
    }
  })
  
  mergeDgeGeneSet <- reactive({
    x <- reshape2::melt(values$dge.gsets)
    x <- x[,c(2,1)]
    colnames(x) <- c("Gene.Set", "Gene")
    if(!is.null(values$dge.annots)){
      y <- values$dge.annots
      colnames(y) <- c("Gene.Set", "Annotation")
      x <- merge(x, y, by = "Gene.Set", all = TRUE)
    }
    return(x)
  })

  output$genelisttable <-renderDataTable({
    y <- callModule(filterOpts, "dgeResultsTable", data = reactive(values$results.file), comparison = reactive(input$comparison),"genes")
    if(!is.null(values$dge.gsets)){
      if(input$merge){
        x <- mergeDgeGeneSet()[!duplicated(mergeDgeGeneSet()[,2]),]
        colnames(x)[2] <- "Transcript.ID"
        mergeData <- merge(y, x, by = "Transcript.ID", all.x = TRUE)[,-c(1:ncol(y)),drop = FALSE]
        y <- cbind(y[,c(1,2)],mergeData, y[,c(3:ncol(y))])
      }
    }
    y$Gene.Symbol <- paste("<a href=http://www.genecards.org/cgi-bin/carddisp.pl?gene=",y$Gene.Symbol," target = '_blank'",'>',y$Gene.Symbol,"</a>",sep='')
    escape = FALSE
    y
  },escape=FALSE)

  sig_exp_file <- reactive({
    g <- callModule(filterOpts, "dgeHeatmap", data = reactive(values$results.file), comparison = reactive(input$comparison2),"genes")
    e <- values$exprs[match(g$Transcript.ID, rownames(values$exprs), nomatch = 0),]
    g <- g[match(rownames(e), g$Transcript.ID, nomatch = 0),]
    g$Gene.Symbol <- as.character(g$Gene.Symbol)
    g$Transcript.ID <- as.character(g$Transcript.ID)
    if(length(which(g$Gene.Symbol == "")) > 0){
     rows <- g$Gene.Symbol
     rows[which(rows == "")] <- g$Transcript.ID[which(rows == "")]
    } else{
     rows <- g$Gene.Symbol
    }
    if(input$dgePlotGeneSymbols){
     rownames(e) <- make.unique(as.character(rows))
    }
    z = list(g = e)
    return(z)
  })

  output$test1<-renderUI({
   if(is.null(values$rowdend3)){
    if(ctrl()$id ==TRUE){
     try<-list("All Samples Median Normalized" = 3,
               "All Samples Healthy Normalized" = 4,
               "Non-Healthy Samples Median Normalized" = 6)
    }
    
    if(ctrl()$id == FALSE){
     try<-list("All Samples Median Normalized" = 3)
    }
   }
   
   if(!is.null(values$rowdend3)){
    if(ctrl()$id == TRUE){
     try<-list("Baseline Mean Normalized" = 1,
               "Baseline Healthy Normalized" = 2,
               "All Samples Mean Normalized" = 3,
               "All Samples Healthy Normalized"= 4,
               "All Samples Baseline Normalized"=5)
    }
    
    if(ctrl()$id == FALSE){
     try<-list("Baseline Mean Normalized" = 1,
               "All Samples Mean Normalized" = 3,
               "All Samples Baseline Normalized"=5)
    }
   }
   selectInput("set1", "Select heatmap:",as.list(try))
  })


  heatmapdata2 <-reactive({
    final_expression <- sig_exp_file()$g
    if (input$set1==1){#heatmapbase1
      if(ctrl()$id == TRUE){
        base_sample_name <- design()$des$columnname[which(design()$des[,baseline.var()$id] == baseline.val()$id & design()$des[,control.var()$id] != control.val()$id)]
        index <- which(colnames(final_expression) %in% base_sample_name)
      }
      if(ctrl()$id == FALSE){
        base_sample_name <- design()$des$columnname[which(design()$des[,baseline.var()$id] == baseline.val()$id)]
        index <- which(colnames(final_expression) %in% base_sample_name)
      }
      exp_base_sam <- final_expression[, index]
      des_base_sam <- design()$des[which(design()$des$columnname %in% colnames(exp_base_sam)),]
      y<-manipulateData(y = exp_base_sam, x = des_base_sam,colname = "columnname")
    }
    if (input$set1==2){#heatmapbase2
      base_sample_name <- design()$des$columnname[which(design()$des[,baseline.var()$id]==baseline.val()$id | design()$des[,control.var()$id]==control.val()$id)]
      index <- which(colnames(final_expression) %in% base_sample_name)
      exp_base_sam <- final_expression[, index]
      des_base_sam <- design()$des[which(design()$des$columnname %in% colnames(exp_base_sam)), ]
      y<-manipulateData(y=exp_base_sam,x=des_base_sam,colname ="columnname",ref.var=control.var()$id,ref.val=control.val()$id,long=FALSE,keep.ref=TRUE)
    }
    if(input$set1==3){#heatmap1
      y<-manipulateData(y=final_expression,x=design()$des,colname="columnname")
    }
    if(input$set1==4){#heatmap2
      y <- manipulateData(y = final_expression, x = design()$des, colname = "columnname", ref.var = control.var()$id, ref.val = control.val()$id, long = FALSE, keep.ref = TRUE)
    }
    if(input$set1==5){#heatmap3
      if(ctrl()$id==TRUE){
        des_w_controls<-design()$des[which(design()$des$columnname %in% colnames(final_expression)),]
        des_wo_controls<-design()$des[-which(design()$des[,control.var()$id]==control.val()$id),]
        h5index<-which(colnames(final_expression) %in% des_wo_controls$columnname)
        y<-manipulateData(y=final_expression[,h5index],x=des_wo_controls,colname="columnname",ref.var=baseline.var()$id,ref.val=baseline.val()$id,long=TRUE,subject.id=subject.id()$id,keep.ref=FALSE)
      }
      if(ctrl()$id==FALSE){
        y<-manipulateData(y=final_expression,x=design()$des,colname="columnname",ref.var=baseline.var()$id,ref.val=baseline.val()$id,long=TRUE,subject.id=subject.id()$id,keep.ref=FALSE)
      }
    }
    z<-list(y=y)
    return(z)
  })

  heatmapname1<-reactive({
    if(input$set1==1) heattxt<-"Baseline Mean Normalized"
    if(input$set1==2) heattxt<-"Baseline Healthy Normalized"
    if(input$set1==3) heattxt<-"All Samples Mean Normalized"
    if(input$set1==4) heattxt<-"All Samples Healthy Normalized"
    if(input$set1==5) heattxt<-"All Samples Normalized to each Subjects Baseline"
    heattxt
  })
  
  dgeGraphParams <- eventReactive(input$go2, {
    params <- callModule(graphOptions, "dgeGraphOptions")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution)
    return(params)
  })
  
  dgeResolution <- reactive({
    params <- callModule(graphOptions, "dgeGraphOptions")
    return(params$resolution)
  })
  
  dgePlotWidth <- function(){dgeGraphParams()$width}
  dgePlotHeight <- function(){dgeGraphParams()$height}
  
  callModule(subsetAndOrderRenderUI, "dgeSubOrder", des = reactive(design()$des))
  
  dgeRowCluster <- eventReactive(input$go2, {
    x <- heatmapdata2()$y$exprs.norm 
    ddm <- NA
    if(input$rowCluster){
      dist <- dist(x)
      hcl <- fastcluster::hclust(dist)
      ddm <- as.dendrogram(hcl)
      Rowv <- rowMeans(x, na.rm = TRUE)
      ddm <- reorder(ddm, Rowv)
    }
    labelRows <- NULL
    y <- list(x = x, ddm = ddm, labelRows = labelRows)
    return(y)
  })
  
  dgeClusterData <- eventReactive(input$go2,{
    x <- callModule(colCluster, "dgeCluster", des = reactive(dgeOrderedData()$colAnnot), data = reactive(dgeOrderedData()$x))
    return(x)
  })
  
  dgeOrderedData <- reactive({
    dat <- callModule(subsetAndOrder, "dgeSubOrder", des = reactive(heatmapdata2()$y$design.norm), data = reactive(dgeRowCluster()$x), 
                      sampleAnnot = reactive(sample.id()$id))
    x <- dat$dat
    colAnnot <- dat$colAnnot
    design <- dat$design
    z <- list(x = x, colAnnot = colAnnot, design = design)
    return(z)
  })
  
  dgeMaxRangeData <- eventReactive(input$go2, {
    x <- callModule(maxValues, "dgeMaxValues", reactive(dgeOrderedData()$x))
    return(x)
  })
  
  dgeHeatColors <- eventReactive(input$go2, {
    x <- callModule(annColors, "dgeSubOrder", reactive(dgeOrderedData()$colAnnot))
    return(x)
  })
  
  output$heatmap1 <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(dgeMaxRangeData(),Rowv = dgeRowCluster()$ddm,Colv = dgeClusterData()$colddm, treeheight = dgeGraphParams()$treeHeight, fontsize = dgeGraphParams()$fontSize, cexRow = 1.2, 
                             annheight = dgeGraphParams()$legendSize,color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = dgeClusterData()$colAnnot,annColors = dgeHeatColors(),labRow=dgeRowCluster()$labelRows,
                             breaks=0)
                 }
    )
  }, width = dgePlotWidth, height = dgePlotHeight)
  
  
  output$downloadHeatmap2 <- downloadHandler(
    filename = function() {paste('SigVarsHeatmap','.png', sep = '')},
    content = function(file){
      png(file, width = (dgeResolution()/72)*dgeGraphParams()$width, height = (dgeResolution()/72)*dgeGraphParams()$height, res = dgeResolution())
      print(aheatmap2(dgeMaxRangeData(),Rowv = dgeRowCluster()$ddm,Colv = dgeClusterData()$colddm, treeheight = dgeGraphParams()$treeHeight, fontsize = dgeGraphParams()$fontSize, cexRow = 1.2, 
                      annheight = dgeGraphParams()$legendSize,color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = dgeClusterData()$colAnnot,annColors = dgeHeatColors(),labRow=dgeRowCluster()$labelRows,
                      breaks=0))
      dev.off()
    }
  )
  
  output$downloadHeatmap1 <- downloadHandler(
    filename = function() {paste(values$project.name,'_',heatmapname1(),'.csv', sep='')  },
    content = function(file) {
      write.csv(heatDataDownload2(), file, row.names = TRUE)
    }
  )
  
  heatDataDownload2 <- reactive({
    x <- dgeOrderedData()$x
    if(is.na(dgeRowCluster()$ddm)){
      if(is.na(dgeClusterData()$colddm)){
        x <- x
      } else {
        x <- x[,order.dendrogram(dgeClusterData()$colddm)]
      }
    } else {
      if(is.na(dgeClusterData()$colddm)){
        x <- x[order.dendrogram(dgeRowCluster()$ddm),]
      } else {
        x <- x[order.dendrogram(dgeRowCluster()$ddm), order.dendrogram(dgeClusterData()$colddm)]
        x <- x[nrow(x):1,]
      }
    }
    return(x)
  })

  output$Comparison1 <- renderUI({
    nam <- names(values$results.file)
    index <- grep("^P.Value",nam)
    p.names <- nam[index]
    p.names <- gsub("P.Value.", "", p.names)
    selectInput("comparison", "Comparison:", p.names, p.names[1])
  })

  output$Comparison2 <- renderUI({
    nam <- names(values$results.file)
    index <- grep("^P.Value",nam)
    p.names <- nam[index]
    p.names <- gsub("P.Value.", "", p.names)
    selectInput("comparison_LMM", "Comparison:", p.names, p.names[1], multiple = TRUE)
  })
  
  output$Comparison3 <- renderUI({
    nam <- names(values$results.file)
    index <- grep("^P.Value",nam)
    p.names <- nam[index]
    p.names <- gsub("P.Value.", "", p.names)
    selectizeInput("comparison2", "Comparison:", p.names, p.names[1], multiple = FALSE)
  })
  
  output$selectComps <- renderUI({
    nam <- names(values$results.file)
    index <- grep("^P.Value",nam)
    p.names <- nam[index]
    p.names <- gsub("P.Value.", "", p.names)
    p.names <- c("All", p.names)
    selectInput("comparisons_download", "Comparison:", p.names, p.names[1], multiple = TRUE)
  })
  
  gensymb.search <- reactive({
    dat <- values$results.file
    genlist <- unique(dat$Gene.Symbol)
    genlist
  })

  probe.search <- reactive({
    dat <- values$results.file
    selectedprobes <- dat$Transcript.ID[which(dat$Gene.Symbol %in% input$specgene)]
    selectedprobes
  })

  output$specgene1 <- renderUI({
    genlist <- gensymb.search()
    withProgress(message = '',
                 detail = 'Generating the Options...', value = 1,{
                   selectizeInput("specgene", "Gene.Symbol selection:",
                                  choices = genlist,
                                  selected = genlist[1],options = list(maxOptions = 30))
                 })
  })

  output$probeid1 <- renderUI({
    if(is.null(input$specgene)){return(NULL)}
    else{
      selectedprobes <- probe.search()
      selectizeInput("probeid", "Transcript.ID selection:", multiple = TRUE, selectedprobes,selected=selectedprobes[1], options = list(maxOptions = 30))
    }
  })

  output$genTable <- renderUI({
    actionButton("go3", "Generate table")
  })

  sgl_flat <- reactive({
    results.file <- values$results.file
    sgl <- results.file[grep("^P.Value", names(results.file))]
    sgl_2 <- apply(sgl, 2, p.adjust, method = "bonferroni")
    colnames(sgl_2) <- gsub("P.Value.","Bonf.P.Value.",colnames(sgl_2))
    sgl_flat <- data.frame(results.file, sgl_2)
    sgl_flat
  })

  specgenelist <- eventReactive(input$go3,{
    m_newsgl <- function(sss){
      newsgl_Gene.Symbol <- sgl_flat()[which(sgl_flat()$Gene.Symbol %in% sss),][,-2]
      comparisons <- gsub("Estimate.", "", colnames(newsgl_Gene.Symbol)[grep("Estimate", colnames(newsgl_Gene.Symbol), fixed = TRUE)])
      dat <- reshape2::melt(newsgl_Gene.Symbol, id.vars = "Transcript.ID")
      splt <- as.data.frame(stringr::str_split_fixed(dat$variable, paste0(".",rep(comparisons,each = nrow(newsgl_Gene.Symbol))),2))
      colnames(splt) <- c("variable", "Comparison")
      splt$Comparison <- rep(comparisons,each = nrow(newsgl_Gene.Symbol))
      dat <- do.call("cbind", list(Transcript.ID = as.character(dat[,1]), splt, value = dat$value))
      newdat <- reshape2::dcast(dat, Transcript.ID + Comparison ~ variable)
      newdat <- newdat[,c(1,2,4,7,6,5,3)]
      return(newdat)
    }
    xx_0 <- m_newsgl(input$specgene)
    xx <- xx_0[which(xx_0$Transcript.ID %in% input$probeid),]
    xx
  })

  output$specgenetable <- renderDataTable({
    specgenelist()
  })

  output$genelistgraph<-renderPlot({
    plot(plotdata()$alpha,plotdata()$raw,type="l",main="Multiple Testing Comparison Plot",col="black",xlim=c(0,1),ylim=c(0,1),xlab=expression(alpha),ylab="% of Total Probes in Gene List")
    lines(plotdata()$alpha,plotdata()$fdr,col="red",lwd=2)
    lines(plotdata()$alpha,plotdata()$bonf,col="green")
    legend("bottomright",legend=c("Raw P-value","FDR","Bonf."), lty=c(1,1,1),col=c("black","red","green") )
    axis(4,at=1:10/10,labels=round(1:10/10*dim(values$results.file)[1],0))
    lines(c(0,1),c(0,1),lty=2)
  })

  output$downloadCG <- downloadHandler(
    filename = function(){paste0("Gene_Search_List","_", input$specgene,"_with_selected_probes", ".csv")},
    content = function(file){
      write.csv(specgenelist(), file,row.names = FALSE)
    }
  )

  output$downloadSC <- downloadHandler(
    filename = function() {paste("Significance_Comparison_Overview", '_', input$alphalevel2, '.csv', sep = '') },
    content = function(file){
      write.csv(siglist()$z, file,row.names = FALSE)
    }
  )

  output$downloadData <- downloadHandler(
    filename = function() {paste(substring(pcomp(),12),'_',input$correction_method1,input$alphalevel1,'.csv', sep='')  },
    content = function(file) {
      y <- callModule(filterOpts, "dgeResultsTable", data = reactive(values$results.file), comparison = reactive(input$comparison),"genes")
      write.csv(y, file,row.names = FALSE)
    }
  )
  
  output$downloadSelComp <- downloadHandler(
    filename = function() {paste(input$ziptext,".zip", sep = "")},
    content = function(file) {
      file.names <- c()
      for(i in 1:length(sel_genelists())){
        #file.names[i] <- paste(names(sel_genelists())[i], "_", input$correction_method1, input$alphalevel1, ".csv", sep = "")
        file.names[i] <- paste(names(sel_genelists())[i],".csv", sep = "")
        #write.csv(sel_genelists()[[i]], file = paste(names(sel_genelists())[i], "_", input$correction_method1, input$alphalevel1, ".csv", sep = ""), row.names = FALSE)
        write.csv(sel_genelists()[[i]], file = paste(names(sel_genelists())[i], ".csv", sep = ""), row.names = FALSE)
      }
      zip(zipfile = file, files = file.names)
    },
    contentType = "application/zip"
  )

  output$readme <-renderText({paste("The following reports are designed to investigate the results of Differential Gene Expression Analysis.
                                    Below is a summary by a biostatistics team member of the statistical model that was conducted for this project.
                                    The following tabs provide the user with the ability to create their own gene lists for any comparison the analysis conducted.
                                    In the DGE: Gene Lists tab, the user can create the list using raw p-value thresholds or multiple testing corrections by tweaking the inputs on the left hand side of interface.
                                    In addition to the list, a module map of the first Seven rounds of the Baylor Modules is produced.  The percentages are calculated by taking the significant probes in the current gene list
                                    and calculating the percentages of significant probes that are significantly up or down regulated.") })
  output$intro <-renderText({paste("Number of probes in Gene list by method and alpha parameter.")})
  
  output$dgeTabs <- renderUI({
    if(is.null(values$dge.gsets)){
      tabs <- lapply(1:(length(tabs.content)-1), function(i) tabPanel(tabs.content[[i]]$Title, tabs.content[[i]]$Content))
      return(do.call(tabBox, args = c(tabs, list(title = "DGE Results", width = 12, id = "dgeResults"))))
    } else {
      tabs <- lapply(1:length(tabs.content), function(i) tabPanel(tabs.content[[i]]$Title, tabs.content[[i]]$Content))
      return(do.call(tabBox, args = c(tabs, list(title = "DGE Results", width = 12, id = "dgeResults"))))
    }
  })

  modDgeGraphParams <- eventReactive(input$goModDge,{
    params <- callModule(graphOptions, "modDgeGraphOptions", varType = "modules")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    circleSize <- params$circleSize
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution, 
                   circleSize = circleSize)
    return(params)
  })
  
  modDgePlotWidth <- function(){modDgeGraphParams()$width}
  modDgePlotHeight <- function(){modDgeGraphParams()$height}
  
  output$dgeModSelection <- renderUI({
    if(!baylorMod()){return(NULL)}
    if(!is.null(values$dge.annots)){
     return(
      selectizeInput("dgeModuleSelection", "Module to include:", c("All", "Only Annotated", "First Round", "First Two Rounds", "First Three Rounds", "First Four Rounds", "First Five Rounds",
                                                                   "First Six Rounds", "First Seven Rounds", "First Eight Rounds"), "First Six Rounds")
     )
    } else{
     return(
      selectizeInput("dgeModuleSelection", "Module to include:", c("All", "First Round", "First Two Rounds", "First Three Rounds", "First Four Rounds", "First Five Rounds",
                                                                   "First Six Rounds", "First Seven Rounds", "First Eight Rounds"), "First Six Rounds")
     )
    }
  })
  
  modDgeData <- eventReactive(input$goModDge,{
    dat <- sig_ind()$prop_matrix2*100
    if(!is.null(values$dge.annots)){
     annots <- values$dge.annots[match(rownames(dat)[which(rownames(dat) %in% as.character(values$dge.annots[,1]))], 
                                       as.character(values$dge.annots[,1]), nomatch = 0),]
     rownames(dat)[which(rownames(dat) %in% as.character(values$dge.annots[,1]))] <- 
      paste0(rownames(dat)[which(rownames(dat) %in% as.character(values$dge.annots[,1]))], " ", as.character(annots[,2]))
    }
    ddm <- NA
    colddm <- NA
    if(input$compSelect){
      dat <- dat[,match(input$comparison_LMM, colnames(dat), nomatch = 0), drop = FALSE]
    }
    if(baylorMod()){
     if(input$dgeModuleSelection == "Only Annotated"){
      dat <- dat[grep(" ", rownames(dat)),, drop = FALSE]
     } else if(input$dgeModuleSelection == "First Round"){
      #dat <- dat[1:2,]
      dat <- dat[grep("^M1", rownames(dat)),, drop = FALSE]
     } else if(input$dgeModuleSelection == "First Two Rounds"){
      #dat <- dat[1:5,]
      dat <- dat[grep("^M1|^M2", rownames(dat)),, drop = FALSE]
     } else if(input$dgeModuleSelection == "First Three Rounds"){
      #dat <- dat[1:11,]
      dat <- dat[grep("^M1|^M2|^M3", rownames(dat)),, drop = FALSE]
     } else if(input$dgeModuleSelection == "First Four Rounds"){
      #dat <- dat[1:27,]
      dat <- dat[grep("^M1|^M2|^M3|^M4", rownames(dat)),, drop = FALSE]
     } else if(input$dgeModuleSelection == "First Five Rounds"){
      #dat <- dat[1:42,]
      dat <- dat[grep("^M1|^M2|^M3|^M4|^M5", rownames(dat)),, drop = FALSE]
     } else if(input$dgeModuleSelection == "First Six Rounds"){
      #dat <- dat[1:62,]
      dat <- dat[grep("^M1|^M2|^M3|^M4|^M5|^M6", rownames(dat)),, drop = FALSE]
     } else if(input$dgeModuleSelection == "First Seven Rounds"){
      #dat <- dat[1:97,]
      dat <- dat[grep("^M1|^M2|^M3|^M4|^M5|^M6|^M7", rownames(dat)),, drop = FALSE]
     } else if(input$dgeModuleSelection == "First Eight Rounds"){
      #dat <- dat[1:208,]
      dat <- dat[grep("^M1|^M2|^M3|^M4|^M5|^M6|^M7|^M8", rownames(dat)),, drop = FALSE]
     } 
    }
    if(input$uploadModules){
      modNames <- read.csv(input$modSelect$datapath, header = TRUE)
      dat <- dat[which(rownames(dat) %in% modNames[,1]),]
    }
    if(input$LMMdeleterows){
      dat <- dat[-which(rowSums(dat) == 0),]
    }
    if(input$modDgeCluster){
      ddm <- FALSE
    }
    if(input$colCluster){
      colddm <- TRUE
    }
    z <- list(dat = dat, ddm = ddm, colddm = colddm)
    return(z)
  })
  
  output$modDgeMap <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(modDgeData()$dat,Rowv = modDgeData()$ddm,Colv = modDgeData()$colddm,circle_size = modDgeGraphParams()$circleSize, treeheight = modDgeGraphParams()$treeHeight, fontsize = modDgeGraphParams()$fontSize, cexRow = 1.2, 
                             annheight = modDgeGraphParams()$legendSize,color = colorRampPalette(c("blue", "white", "red"))(100),breaks=seq(-100,100,by=4))
                 }
    )
  }, width = modDgePlotWidth, height = modDgePlotHeight)
  
  output$downloadModDgeMap <- downloadHandler(
    filename = function() {paste(values$project.name,"_LMM_ModuleMap",'_',input$correction_method1,input$alphalevel1,'.png', sep='')},
    content = function(file) {
      png(file, width = (modDgeGraphParams()$resolution/72)*modDgeGraphParams()$width, height = (modDgeGraphParams()$resolution/72)*modDgeGraphParams()$height, 
          res = modDgeGraphParams()$resolution)
      print(aheatmap2(modDgeData()$dat,Rowv = modDgeData()$ddm,Colv = modDgeData()$colddm,circle_size = modDgeGraphParams()$circleSize, treeheight = modDgeGraphParams()$treeHeight, fontsize = modDgeGraphParams()$fontSize, cexRow = 1.2, 
                      annheight = modDgeGraphParams()$legendSize,color = colorRampPalette(c("blue", "white", "red"))(100),breaks=seq(-100,100,by=4)))
      dev.off()
    }
  )


  output$downloadModDgeData <- downloadHandler(

    filename = function() {paste(values$project.name,"_LMM_ModuleData",'_',input$correction_method1,input$alphalevel1,'.csv', sep='')},
    content = function(file) {
      write.csv(modDgeData()$dat, file)
    }
  )

  output$vennComparison <- renderUI({
    nam <- names(values$results.file)
    index <- grep("^P.Value",nam)
    p.names <- nam[index]
    p.names <- gsub("P.Value.", "", p.names)
    selectInput("Vcomparison", "Comparison:", p.names, p.names[1], multiple = TRUE)
  })

  output$include <- renderUI({
    n = length(input$Vcomparison)
    Vcomparison = input$Vcomparison
    selectInput("Include", "Include:", Vcomparison, Vcomparison[1:n], multiple = TRUE)
  })

  output$exclude <- renderUI({
    comparisons <- setdiff(input$Vcomparison, input$Include)
    selectInput("Exclude", "Exclude:", comparisons, comparisons[1], multiple = TRUE)
  })

  venndata <- reactive({
    venn.data <- list()
    for(i in 1:length(input$Vcomparison)){
      venn.data[[i]] <- callModule(filterOpts, "dgeVenn", reactive(values$results.file), reactive(input$Vcomparison[i]), "genes")
      venn.data[[i]] <- as.character(venn.data[[i]][,1])
    }
    names(venn.data) <- input$Vcomparison
    if(length(venn.data) > 5){
    venn.data <- venn.data[1:5]
    }
    return(venn.data)
  })

  Venn.intersection <- reactive({
    if(is.null(venndata())){return(NULL)}
    venndata1 <- venndata()[which(names(venndata()) %in% input$Include)]
    intersections <- Reduce(intersect, venndata1)
    n = length(input$Exclude)
    if(n > 0){
      venndata2 <- venndata()[which(names(venndata()) %in% input$Exclude)]
      venndata2 = unlist(venndata2)
      excl <- list(intersections, venndata2)
      intersections <- Reduce(setdiff, excl)
    }
    return(intersections)
  })
  
  output$testing <- renderText({
    length(venndata())
  })

  Venn.union <- reactive({
    if(is.null(venndata())){return(NULL)}
    venndata1 <- venndata()[which(names(venndata()) %in% input$Include)]
    unions <- Reduce(union, venndata1)
    n = length(input$Exclude)
    if(n > 0){
      venndata2 <- venndata()[which(names(venndata()) %in% input$Exclude)]
      venndata2 <- unlist(venndata2)
      excl <- list(unions, venndata2)
      unions <- Reduce(setdiff, excl)
    }
    return(unions)
  })

  genelist2 <- reactive({
    n = length(input$Include)
    comp <- input$Include
    fcomp <- list()
    for(i in 1:n){
      fcomp[[i]] <- c(paste0("Estimate.", input$Include[i]), paste0("Test.statistic.", input$Include[i]),
                      paste0("P.Value.", input$Include[i]))
    }
    if(input$UorI == 1){
      y <- which(values$results.file[,1] %in% Venn.intersection())
      cols <- list()
      for(i in 1:n){
        #cols[[i]] <- grep(fcomp[i], colnames(values$results.file))
        cols[[i]] <- match(fcomp[[i]], colnames(values$results.file))
      }
    }
    if(input$UorI == 2){
      y <- which(values$results.file[,1] %in% Venn.union())
      cols <- list()
      for(i in 1:n){
        #cols[[i]] <- grep(fcomp[i], colnames(values$results.file))
        cols[[i]] <- match(fcomp[[i]], colnames(values$results.file))
      }
    }
    x = list()
    pcols = list()
    pvals_fdr = list()
    pvals_bonf = list()
    pvals <- list()
    estimates <- list()
    tstats <- list()
    for(i in 1:n){
      if(i == 1){
        x[[i]] <- values$results.file[y,c(1,2,cols[[i]])]
      }
      if(i > 1){
        x[[i]] <- values$results.file[y,cols[[i]]]
      }
      pvals[[i]] <- grep("^P.Value", colnames(x[[i]]))
      estimates[[i]] <- grep("^Estimate", colnames(x[[i]]))
      tstats[[i]] <- grep("^Test.statistic", colnames(x[[i]]))
      if(i == 1){
        x[[i]] <- x[[i]][,c(1,2,estimates[[i]],pvals[[i]])]
      }
      if(i > 1){
        x[[i]] <- x[[i]][,c(estimates[[i]],pvals[[i]])]
      }
    }
    for(i in 1:n){
      if(i == 1){
        colnames(x[[i]]) = c("Transcript.ID", "Gene.Symbol", "Log2FC","P.Value")
      }
      if(i > 1){
        colnames(x[[i]]) = c("Log2FC", "P.Value")
      }
    }
    if(n > 1){
      for(i in 1:n){
        if(i == 1){
          colnames(x[[i]]) = c("Transcript.ID", "Gene.Symbol", paste("Log2FC for", comp[i], sep = " "), paste("P.Value.", comp[i], sep =" "))
        }
        if(i > 1){
          colnames(x[[i]]) = c(paste("Log2FC for", comp[i], sep = " "), paste("P.Value.", comp[i], sep = " "))
        }
      }
    }
    x = do.call("cbind", x)
    if(nrow(x) == 0){
      x <- data.frame("No Genes Present")
      names(x) <- "Transcript.ID"
    }
    return(x)
  })

  output$vennIntersection <- renderDataTable({
    y <- genelist2()
    y$Gene.Symbol <- paste("<a href=http://www.genecards.org/cgi-bin/carddisp.pl?gene=",y$Gene.Symbol," target = '_blank'",'>',y$Gene.Symbol,"</a>",sep='')
    escape = FALSE
    y
  }, escape = FALSE)

  output$vennDiagram <- renderPlot({
    dummy <- data.frame("No Genes Present")
    names(dummy) <- "Transcript.ID"
    if(identical(genelist2(),dummy)){return(NULL)}
    color.choices = c("blue", "green", "red", "orange","purple")
    if(length(venndata()) == 1){
      color.choices = color.choices[1]
    }
    if(length(venndata()) == 2){
      color.choices = color.choices[1:2]
    }
    if(length(venndata()) == 3){
      color.choices = color.choices[1:3]
    }
    if(length(venndata()) == 4){
      color.choices = color.choices[1:4]
    }
    if(length(venndata()) == 5){
      color.choices = color.choices
    }
    grid.draw(VennDiagram::venn.diagram(venndata(), filename = NULL, lwd = 1, col = color.choices, cat.cex = .9, fil = color.choices, margin = .12, ext.text = FALSE,
                           euler.d = TRUE))
  })

  output$downloadVennData <- downloadHandler(
    filename = function() {paste0("VennDiagram_", input$UorI, '.csv')  },
    content = function(file) {
      dummy <- data.frame("No Genes Present")
      names(dummy) <- "Transcript.ID"
      if(identical(genelist2(),dummy)){return(NULL)}
      write.csv(genelist2(), file,row.names = FALSE)
    }
  )

  output$downloadVennPic <- downloadHandler(
    filename = function() {paste0("VennDiagram_", input$UorI, '.png')  },
    content = function(file) {
      dummy <- data.frame("No Genes Present")
      names(dummy) <- "Transcript.ID"
      if(identical(genelist2(),dummy)){return(NULL)}
      color.choices = c("blue", "green", "red", "orange","purple")
      if(length(venndata()) == 1){
        color.choices = color.choices[1]
      }
      if(length(venndata()) == 2){
        color.choices = color.choices[1:2]
      }
      if(length(venndata()) == 3){
        color.choices = color.choices[1:3]
      }
      if(length(venndata()) == 4){
        color.choices = color.choices[1:4]
      }
      if(length(venndata()) == 5){
        color.choices = color.choices
      }
      png(file)
      grid.draw(VennDiagram::venn.diagram(venndata(), filename = NULL, lwd = 1, col = color.choices, cat.cex = .9, fil = color.choices, margin = .12, ext.text = FALSE,euler.d = TRUE))
      dev.off()
    }
  )


  output$downloadLMMModMap2 <- downloadHandler(
    filename = function() {paste('LMMModMap','.png', sep = '')},
    content = function(file){
      png(file, width = (resolution1()/72)*LMMmap1(), height = (resolution1()/72)*LMMmap2(), res = resolution1())
      if(min(lmm_module()$dat) >= 0 & max(lmm_module()$dat) > 0){
        print(aheatmap2(lmm_module()$dat, Rowv = lmm_module()$rowv, circle_size = input$LMMradius, fontsize = input$LMMFont, Colv = NA , color = lmm_module()$color_palette[500:1000]))
      }
      if(max(lmm_module()$dat) <= 0 & min(lmm_module()$dat) < 0){
        print(aheatmap2(lmm_module()$dat, Rowv = lmm_module()$rowv, circle_size = input$LMMradius, fontsize = input$LMMFont, Colv = NA , color = lmm_module()$color_palette[1:500]))
      }
      if(min(lmm_module()$dat) < 0 & max(lmm_module()$dat) >0){
        print(aheatmap2(lmm_module()$dat, Rowv = lmm_module()$rowv, circle_size = input$LMMradius, fontsize = input$LMMFont, Colv = NA , color = lmm_module()$color_palette))
      }
      if(all(lmm_module()$dat == 0)){
        return(NULL)
      }
      dev.off()
    }
  )

  mod_map_lmm_res <- reactive({
    input$modmaplmmres
  })

  output$download_modmap_comparison <- downloadHandler(
    filename = function() {paste('ModMap_Comparison','.png', sep = '')},
    content = function(file){
      png(file, width = (mod_map_lmm_res()/72)*700, height = (mod_map_lmm_res()/72)*190, res = mod_map_lmm_res())
      print(ModMap_Comparison())
      dev.off()
    }
  )


############## QUSAGE #####################

  output$qusage <- renderMenu({
    if(is.null(values$qusage.results)){
      return(strong(""))
    }
    if(is.null(values$qusage.results) == FALSE){
      menuItem("Q-Gen", icon = icon("filter"), tabName = "qusage")
    }
  })

  output$genesets <- renderUI({
    if(is.null(values$qusage.results)){
      return(NULL)
    }
    else{
     if(is.list(values$qusage.results) & !is.data.frame(values$qusage.results)){
       if(is.null(names(values$qusage.results))){
         return(selectInput("genesets1", "Select geneset definition:", choices = c(1:length(values$qusage.results))))
       }
       if(!is.null(names(values$qusage.results))){
         return(selectInput("genesets1", "Select geneset definition:", choices = c(names(values$qusage.results))))
       }
     }
      else{
        return(NULL)
      }
    }
  })

  master <- reactive({
    if(is.null(values$qusage.results)){return(NULL)}
    if(is.null(input$genesets1)){
      qusage_results <- values$qusage.results
    }
    if(!is.null(input$genesets1)){
      if(!is.null(names(values$qusage.results))){
        qusage_results <- values$qusage.results[[input$genesets1]]
      }
      else{
        qusage_results <- values$qusage.results[[as.numeric(input$genesets1)]]
      }
    }
    master <- qusage_results
    colnames(master)[which(colnames(master) == "log.fold.change")] <- "Log2FC"
    unique_comp <- unique(master$Comparison)
    sub_uniquecomp <- list()
    n <- length(unique_comp)
    for(i in 1:n){
      sub_uniquecomp[[i]] <- which(master$Comparison == unique_comp[i])
    }
    bonf <- list()
    for(i in 1:n){
      bonf[[i]] <- p.adjust(master$p.Value[sub_uniquecomp[[i]]], method = "bonferroni")
    }
    bonf <- unlist(bonf)
    master$Bonf <- bonf
    if(!is.null(values$annots)){
     n2 <- length(values$annots[,1])
     mod.ann <- list()
     master$Modulev2_Annotation <- ""
     for(i in 1:n2){
      mod.ann[[i]] <- which(master$pathway.name %in% values$annots[,1][i])
     }
     for(i in 1:n2){
      master$Modulev2_Annotation[mod.ann[[i]]] <- as.character(values$annots[,2][i])
     }
    }
    master$Comparison <- as.factor(master$Comparison)
    return(master)
  })

  mod_list <- reactive({
    Modulelist <- values$gene.sets
    return(Modulelist)
  })


  output$Comparisons <- renderUI({
    selectInput("set_comp", "Comparison selection:", choices = unique(master()$Comparison), selected = unique(master()$Comparison)[1])
  })

  output$Comparisons1 <- renderUI({
    selectInput("set_comp1", "Comparison(s) selection:", choices = unique(master()$Comparison), selected = unique(master()$Comparison)[1], multiple = T)
  })

  output$Comparisons2 <- renderUI({
    selectInput("set_comp2", "Comparison selection:", choices = unique(master()$Comparison), selected = unique(master()$Comparison)[1])
  })

  output$Comparisons3 <- renderUI({
    selectInput("set_comp3", "Comparison selection:", choices = unique(master()$Comparison), selected = unique(master()$Comparison)[1])
  })

  output$Module_Select1 <- renderUI({
    selectInput("Mod_Select1", "Module selection:", choices = names(mod_list()), selected = names(mod_list()[1]))
  })

  output$PaloOrFirst1  <- renderUI({
    if(length(input$set_comp1) <= 1){return(NULL)}
    else{
      selectInput("PaloOrFirst", "Significant gene sets:", choices = c("In at least one comparison chosen" = 1, "In first comparison chosen" = 2), selected = 1)
    }
  })

  output$ColorChoice <- renderUI({
    if(length(input$set_comp1) <= 1){return(NULL)}
    else{
      cols = c("blue", "red","green","lightskyblue","purple","hotpink","brown","gold")
      selectInput("ColorChoice1", "Choose line colors:", choices = cols, selected = cols[1:length(input$set_comp1)], multiple = T)
    }
  })

  multi_testing <- reactive({
    Multi_testing1 = input$Multi_testing1
    Multi_testing1
  })

  multi_testing2 <- reactive({
    Multi_testing2 = input$Multi_testing2
    Multi_testing2
  })
  
  comp_subset1 <- reactive({
    master <- callModule(filterOpts, "qusFcPlot", data = master, comparison = reactive(input$set_comp1), data.type = "geneSets", 
                         paloOrFirst = reactive(input$PaloOrFirst))
    return(master)
  })


output$Module_Select <- renderUI({
    master <- master()[which(master()$Comparison %in% input$set_comp2),]
    pathways <- master$pathway.name
    selectInput("Mod_Select", "Module selection:", choices = gtools::mixedsort(as.character(pathways)), selected = gtools::mixedsort(as.character(pathways))[1])
  })

  venn.data <- reactive({
    if(is.null(master())){return(NULL)}
    master <- comp_subset1()
    unique.comparison <- unique(master$Comparison)
    n = length(unique.comparison)
    master1 <- list()
    for(i in 1:n){
      master1[[i]] <- subset(master, Comparison == unique.comparison[i])
    }
    names(master1) <- as.character(unique.comparison)
    for(i in 1:n){
      master1[[i]] <- master1[[i]]$pathway.name[which(master1[[i]]$SIG == "Significant")]
    }
    master1
  })

  comp_overview <- reactive({
    if(is.null(master())){return(NULL)}
    master1 = master()[which(master()$p.Value <= input$SigLevel),]
    master2 = master()[which(master()$FDR <= input$SigLevel),]
    master3 = master()[which(master()$Bonf <= input$SigLevel),]
    if(nrow(master1) == 0 & nrow(master2) == 0 & nrow(master3) == 0){return(NULL)}
    if(input$foldchange.q == "+"){
      master1 = master1[which(master1$Log2FC > 0),]
      master2 = master2[which(master2$Log2FC > 0),]
      master3 = master3[which(master3$Log2FC > 0),]
    }
    if(input$foldchange.q == "-"){
      master1 = master1[which(master1$Log2FC < 0),]
      master2 = master2[which(master2$Log2FC < 0),]
      master3 = master3[which(master3$Log2FC < 0),]
    }
    if(nrow(master1) > 0){
      master_sig1 = aggregate(Comparison ~ Comparison, data = master1, FUN = table, drop = FALSE)
      master_sig1 = as.matrix(master_sig1)
      master_sig1 = as.data.frame(master_sig1)
      colnames(master_sig1) = sub("Comparison.", "",colnames(master_sig1))
      master_sig1 = t(master_sig1)
      master_sig1 = as.data.frame(master_sig1)
      master_sig1 = cbind(rownames(master_sig1), master_sig1[,1])
      master_sig1 = as.data.frame(master_sig1)
    }
    if(nrow(master2) > 0){
      master_sig2 = aggregate(Comparison ~ Comparison, data = master2, FUN = table)
      master_sig2 = as.matrix(master_sig2)
      master_sig2 = as.data.frame(master_sig2)
      colnames(master_sig2) = sub("Comparison.", "",colnames(master_sig2))
      master_sig2 = t(master_sig2)
      master_sig2 = as.data.frame(master_sig2)
      master_sig2 = cbind(rownames(master_sig2), master_sig2[,1])
      master_sig2 = as.data.frame(master_sig2)
    }
    if(nrow(master3) > 0){
      master_sig3 = aggregate(Comparison ~ Comparison, data = master3, FUN = table)
      master_sig3 = as.matrix(master_sig3)
      master_sig3 = as.data.frame(master_sig3)
      colnames(master_sig3) = sub("Comparison.", "",colnames(master_sig3))
      master_sig3 = t(master_sig3)
      master_sig3 = as.data.frame(master_sig3)
      master_sig3 = cbind(rownames(master_sig3), master_sig3[,1])
      master_sig3 = as.data.frame(master_sig3)
    }
    if(nrow(master1) > 0 & nrow(master2) > 0 & nrow(master3) > 0){
      master_sig = cbind(master_sig1, master_sig2[,-1], master_sig3[,-1])
      master_sig[,2] = as.numeric(as.character(master_sig[,2]))
      master_sig[,3] = as.numeric(as.character(master_sig[,3]))
      master_sig[,4] = as.numeric(as.character(master_sig[,4]))
      colnames(master_sig) = c("Comparison", "Raw", "FDR", "Bonf")
      master_sig = master_sig[order(master_sig$Raw, decreasing = T),]
    }
    if(nrow(master1) > 0 & nrow(master2) > 0 & nrow(master3) == 0){
      master_sig = cbind(master_sig1, master_sig2[,-1], 0)
      master_sig[,2] = as.numeric(as.character(master_sig[,2]))
      master_sig[,3] = as.numeric(as.character(master_sig[,3]))
      master_sig[,4] = as.numeric(as.character(master_sig[,4]))
      colnames(master_sig) = c("Comparison", "Raw", "FDR", "Bonf")
      master_sig = master_sig[order(master_sig$Raw, decreasing = T),]
    }
    if(nrow(master1) > 0 & nrow(master2) == 0 & nrow(master3) > 0){
      master_sig = cbind(master_sig1, 0, master_sig3[,-1])
      master_sig[,2] = as.numeric(as.character(master_sig[,2]))
      master_sig[,3] = as.numeric(as.character(master_sig[,3]))
      master_sig[,4] = as.numeric(as.character(master_sig[,4]))
      colnames(master_sig) = c("Comparison", "Raw", "FDR", "Bonf")
      master_sig = master_sig[order(master_sig$Raw, decreasing = T),]
    }
    if(nrow(master1) > 0 & nrow(master2) == 0 & nrow(master3) == 0){
      master_sig = cbind(master_sig1, 0, 0)
      master_sig[,2] = as.numeric(as.character(master_sig[,2]))
      master_sig[,3] = as.numeric(as.character(master_sig[,3]))
      master_sig[,4] = as.numeric(as.character(master_sig[,4]))
      colnames(master_sig) = c("Comparison", "Raw", "FDR", "Bonf")
      master_sig = master_sig[order(master_sig$Raw, decreasing = T),]
    }
    if(nrow(master_sig) == 1){
     master_sig$Comparison <- unique(master()$Comparison)
    }
    return(master_sig)
  })

  individual_modselect <- reactive({
    if(is.null(master())){return(NULL)}
    master = master()[which(master()$Comparison == input$set_comp2 & master()$pathway.name == input$Mod_Select), ,drop = F]
    lowerCI = values$lower.ci
    upperCI = values$upper.ci
    rownames(lowerCI) <- rownames(upperCI) <- as.character(values$results.file[,1])
    mmr_modselection <- callModule(filterOpts, "qusIndFcPlot", data = reactive(values$results.file), comparison = reactive(input$set_comp2), data.type = "genes")
    mmr_modselection <- mmr_modselection[which(mmr_modselection[,1] %in% mod_list()[[input$Mod_Select]]),]
    lowerCI <- lowerCI[match(mmr_modselection[,1], rownames(lowerCI), nomatch = 0),which(colnames(lowerCI) %in% input$set_comp2)]
    upperCI <- upperCI[match(mmr_modselection[,1], rownames(upperCI), nomatch = 0),which(colnames(upperCI) %in% input$set_comp2)]
    mmr_names <- mmr_modselection[,2]
    mmr_probes <- mmr_modselection[,1]
    missing_symb <- which(sapply(mmr_names, function(x) identical("",x)))
    if(length(missing_symb) > 0){
      mmr_names[missing_symb] <- mmr_probes[missing_symb]
    }
    duplicates <- which(duplicated(mmr_names))
    if(sum(duplicates) > 0){
      mmr_names[duplicates] <- mmr_probes[duplicates]
    }
    mmr_modselection <- cbind(mmr_modselection, lowerCI, upperCI)
    mmr_modselection$Test.Statistic <- NULL
    
    if(nrow(mmr_modselection) == 0){return(NULL)}
    Index <- order(mmr_modselection$Log2FC, decreasing = T)
    mmr_modselection <- mmr_modselection[Index,]
    mmr_modselection <- cbind(1:length(Index), mmr_modselection)
    colnames(mmr_modselection) <- c("Index", colnames(mmr_modselection[,-1]))
    mmr_modselection <- mmr_modselection
    y = list(mmr_modselection = mmr_modselection, master = master)
    return(y)
  })

  plotHeight = function(){input$PlotHeight}
  plotWidth = function(){input$PlotWidth}
  plotHeight1 = function(){input$PlotHeight1}
  plotWidth1 = function(){input$PlotWidth1}
  plotHeight2 = function(){input$PlotHeight2}
  plotWidth2 = function(){input$PlotWidth2}
  plotres = function(){input$PlotRes}
  plotres1 = function(){input$PlotRes1}
  plotres2 = function(){input$PlotRes2}

  ranges <- reactiveValues(x = NULL, y = NULL)
  ranges2 <- reactiveValues(x = NULL, y = NULL)
  comp_plot1 <- reactive({
    if(is.null(master())){return(NULL)}
    if(is.null(comp_subset1())){return(NULL)}

    if(input$only_annotated){
      comp_subset1 <- comp_subset1()[which(comp_subset1()$Modulev2_Annotation != ""),]
    }
    else{
      comp_subset1 <- comp_subset1()
    }

    ylow = c()
    yhigh = c()

    if(min(comp_subset1$low) < 0 & max(comp_subset1$up) > 0){
      if(abs(min(comp_subset1$low)) >= max(comp_subset1$up)){
        ylow = min(comp_subset1$low)
        yhigh = -min(comp_subset1$low)
      }
      else{
        ylow = -max(comp_subset1$up)
        yhigh = max(comp_subset1$up)
      }
    }

    if(min(comp_subset1$low) > 0){
      ylow = -max(comp_subset1$up)
      yhigh = max(comp_subset1$up)
    }

    if(max(comp_subset1$up) < 0){
      ylow = min(comp_subset1$low)
      yhigh = -min(comp_subset1$low)
    }

    if(length(input$set_comp1) > 1){
      if(min(comp_subset1$Log2FC) < 0 & max(comp_subset1$Log2FC) > 0){
        if(abs(min(comp_subset1$Log2FC)) >= max(comp_subset1$Log2FC)){
          ylow = min(comp_subset1$Log2FC)
          yhigh = -min(comp_subset1$Log2FC)
        }
        else{
          ylow = -max(comp_subset1$Log2FC)
          yhigh = max(comp_subset1$Log2FC)
        }
      }
      if(min(comp_subset1$Log2FC) > 0){
        ylow = -max(comp_subset1$Log2FC)
        yhigh = max(comp_subset1$Log2FC)
      }
      if(max(comp_subset1$Log2FC) < 0){
        ylow = min(comp_subset1$Log2FC)
        yhigh = -min(comp_subset1$Log2FC)
      }
    }

    comp_subset1$ylow = round(ylow,1)
    comp_subset1$yhigh = round(yhigh,1)

    if(length(input$set_comp1) > 1){
      n = length(input$set_comp1)
      if(input$graphics6 == FALSE){
        line_colors = c("blue", "red","green","lightskyblue","purple","hotpink","brown","gold")
      }
      else{
        line_colors = input$ColorChoice1
      }
      if(input$showAnnotated){
        comp_subset1$pathway.name <- factor(paste(comp_subset1$pathway.name,comp_subset1$Modulev2_Annotation, sep = " "), levels = unique(paste(comp_subset1$pathway.name,comp_subset1$Modulev2_Annotation, sep = " ")))
      }
      #qusage_plot = ggplot(data = comp_subset1, aes(x = factor(Index), y = Log2FC, ymin = ylow, ymax = yhigh))
      qusage_plot = ggplot(data = comp_subset1, aes(x = pathway.name, y = Log2FC, ymin = ylow, ymax = yhigh))
      qusage_plot = qusage_plot + scale_x_discrete(labels = as.character(unique(comp_subset1$pathway.name)))
      #qusage_plot = qusage_plot + scale_x_discrete(breaks = 1:length(comp_subset1$Index), labels = as.character.factor(comp_subset1$pathway.name[comp_subset1$Index]))
      qusage_plot = qusage_plot + xlab("Modules") + ylab("Pathway Activity")
      qusage_plot = qusage_plot + scale_colour_manual(values = line_colors) + geom_line(aes(colour = Comparison, group = Comparison), size = 1) + geom_hline(yintercept = 0, colour = "black", size = .5)
      qusage_plot = qusage_plot + geom_point(aes(shape = SIG), size = 2) + scale_shape_manual(values = c(16,8))
    }
    else{
      if(input$showAnnotated){
        comp_subset1$pathway.name <- factor(paste(comp_subset1$pathway.name,comp_subset1$Modulev2_Annotation, sep = "_"), levels = c(paste(comp_subset1$pathway.name,comp_subset1$Modulev2_Annotation, sep = "_")))
      }
      qusage_plot = qplot(x = pathway.name, y = Log2FC, data = comp_subset1, ymin = ylow, ymax = yhigh, ylab = "Pathway Activity", xlab = "Modules")
      qusage_plot = qusage_plot + geom_point() + geom_errorbar(data = comp_subset1, aes(x = pathway.name, y = Log2FC, ymin = low, ymax = up))
      qusage_plot = qusage_plot + geom_hline(yintercept = 0, colour = "red", size = 1)
    }

    qusage_plot = qusage_plot + theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) #+ coord_cartesian(xlim = ranges$x, ylim = ranges$y)
    return(qusage_plot)

  })


  individual_modplot <- reactive({
    if(is.null(master())){return(NULL)}
    if(is.null(individual_modselect())){return(NULL)}
    mmr_modselection <- individual_modselect()$mmr_modselection
    master <- individual_modselect()$master
    ylow = c()
    yhigh = c()
    if(min(mmr_modselection$lowerCI) < 0 & max(mmr_modselection$upperCI) > 0){
      if(abs(min(mmr_modselection$lowerCI)) >= max(mmr_modselection$upperCI)){
        ylow = min(mmr_modselection$lowerCI)
        yhigh = -min(mmr_modselection$lowerCI)
      }
      else{
        ylow = -max(mmr_modselection$upperCI)
        yhigh = max(mmr_modselection$upperCI)
      }
    }
    if(min(mmr_modselection$lowerCI) > 0){
      ylow = -max(mmr_modselection$upperCI)
      yhigh = max(mmr_modselection$upperCI)
    }
    if(max(mmr_modselection$upperCI) < 0){
      ylow = min(mmr_modselection$lowerCI)
      yhigh = -min(mmr_modselection$lowerCI)
    }
    mmr_modselection$ylow = round(ylow, 1)
    mmr_modselection$yhigh = round(yhigh, 1)
    mmr_modselection$Pathway.Activity = master$Log2FC
    mod_plot = ggplot(data = mmr_modselection, aes(x = Index, y = Log2FC, ymin = ylow, ymax = yhigh)) + xlim(0, length(mmr_modselection$Index))
    mod_plot = mod_plot + annotate("rect", xmin = -Inf, xmax = Inf, ymin = master$low, ymax = master$up, alpha = .3, fill = "lightblue")
    mod_plot = mod_plot + scale_x_discrete(limits = as.character(mmr_modselection$Gene.Symbol[mmr_modselection$Index]))
    mod_plot = mod_plot + geom_point()
    mod_plot = mod_plot + geom_errorbar(data = mmr_modselection, aes(x = Index, y = Log2FC, ymin = lowerCI, ymax = upperCI))
    mod_plot = mod_plot + xlab("Gene.Symbol ID") + ylab("Probe Level Fold Change") + theme_bw() +
               theme(axis.text.x = element_text(angle = 45, hjust = 1)) + geom_hline(yintercept = 0, colour = "red", size = 1)
    mod_plot = mod_plot + geom_hline(aes(yintercept = Pathway.Activity), linetype = "dashed",colour = "black") + theme(plot.margin = unit(c(1,10,0,0), "lines"))
    mod_plot = mod_plot + annotation_custom(textGrob(label = "Pathway Activity", hjust = 0), xmin = length(mmr_modselection$Index) + 1.08,
                                            xmax = length(mmr_modselection$Index) + 1.08, ymin = master$Log2FC, ymax = master$Log2FC)
    gt <- ggplot_gtable(ggplot_build(mod_plot))
    gt$layout$clip[gt$layout$name == "panel"] <- "off"
    gt
  })

  output$GeneSetTab <- renderDataTable({
    if(is.null(master())){return(NULL)}
    if(is.null(individual_modselect())){return(NULL)}
    y <- individual_modselect()$mmr_modselection
    y$Gene.Symbol <- paste("<a href=http://www.genecards.org/cgi-bin/carddisp.pl?gene=",y$Gene.Symbol," target = '_blank'",'>',y$Gene.Symbol,"</a>",sep='')
    y <- y[,-1]
    escape = FALSE
    y
  }, escape = FALSE)

  output$GeneSetPlot <- renderPlot({
    if(is.null(master())){return(NULL)}
    if(is.null(individual_modplot())){return(NULL)}
    grid.draw(individual_modplot())
  },width = plotWidth2, height = 400)

  output$CompOverview <- renderDataTable({
    if(is.null(master())){return(NULL)}
    comp_overview()
  })

  output$foldchange1 <- renderPlot({
    if(is.null(master())){return(NULL)}
    comp_plot1()
  }, width = plotWidth1, height = 400)

  output$venn <- renderUI({
    if(is.null(master())){return(NULL)}
    if(is.null(comp_subset1())){return(NULL)}
    if(length(venn.data()) == 1){return(NULL)}
    else{
      plotOutput("venndiagram")
    }
  })

  output$venn.download <- renderUI({
    if(is.null(master())){return(NULL)}
    if(is.null(comp_subset1())){return(NULL)}
    if(length(venn.data()) == 1){return(NULL)}
    else{
      downloadButton("downloadVenn2", "Download Figure")
    }
  })

  venn.d <- reactive({
    if(is.null(master())){return(NULL)}
    color.choices = c("blue", "red","green","lightskyblue","purple","hotpink","brown","gold")
    if(length(venn.data()) == 2){
      color.choices = color.choices[1:2]
    }
    if(length(venn.data()) == 3){
      color.choices = color.choices[1:3]
    }
    if(length(venn.data()) == 4){
      color.choices = color.choices[1:4]
    }
    if(length(venn.data()) == 5){
      color.choices = color.choices[1:5]
    }
    if(input$graphics6 == FALSE){
      return(VennDiagram::venn.diagram(venn.data(), filename = NULL, lwd = 1, col = color.choices, cat.cex = .9, fil = color.choices, margin = .12, ext.text = FALSE,
                          euler.d = TRUE))
    }
    else{
      return(VennDiagram::venn.diagram(venn.data(), filename = NULL, lwd = 1, col = input$ColorChoice1, cat.cex = .9, fil = input$ColorChoice1, margin = .12, ext.text = FALSE,
                          euler.d = TRUE))
    }
  })

  output$venndiagram <- renderPlot({
    if(is.null(comp_subset1())){return(NULL)}
    grid.draw(venn.d())
  })

  output$MultipleCompTab <- renderDataTable({
    if(is.null(master())){return(NULL)}
    if(!is.null(values$annots)){
      if(input$only_annotated){
        comp_subset1 <- comp_subset1()[which(comp_subset1()$Modulev2_Annotation != ""),]
      } else{
        comp_subset1 <- comp_subset1()
      }
    }
    else{
      comp_subset1 <- comp_subset1()
    }
    comp_subset1 <- comp_subset1[,-c(1,11)]
    colnames(comp_subset1)[which(colnames(comp_subset1) == "p.Value")] <- "P.Value"
    comp_subset1[,c(1,9,2,3,4,8,5,6,7)]
  })

  output$downloadSigComps <- downloadHandler(

    filename = function() {paste(values$project.name,'_','Qusage_Sig_Comps_Table','.csv', sep='')  },
    content = function(file) {
      write.csv(comp_overview(), file,row.names = FALSE)
    }
  )

  output$downloadPlot2 <- downloadHandler(
    filename = function() {paste(values$project.name,'_','Multi_Comparisons_Plot','.png', sep = '')},
    content = function(file){
      png(file, width = (plotres1()/72)*plotWidth1(), height = (plotres1()/72)*480, res = plotres1())
      print(comp_plot1())
      dev.off()
    }
  )

  output$downloadVenn2 <- downloadHandler(
    filename = function() {paste(values$project.name,'_','Multi_Comparisons_Venn', '.png', sep = '')},
    content = function(file){
      png(file)
      grid.draw(venn.d())
      dev.off()
    }
  )

  output$downloadTable2 <- downloadHandler(
    filename = function() {paste(values$project.name,'_','Qusage_Data_Table_Multi_Comp','.csv', sep='')  },
    content = function(file) {
      comp_subset1 <- comp_subset1()[,-c(1,11)]
      comp_subset1 <- comp_subset1[,c(1,9,2,3,4,8,5,6,7)]
      write.csv(comp_subset1, file,row.names = FALSE)
    }
  )

  output$downloadPlot3 <- downloadHandler(
    filename = function() {paste(values$project.name,'_', 'Individual_GeneSet_Plot','.png', sep = '')},
    content = function(file){
      png(file, width = (plotres2()/72)*plotWidth2(), height = (plotres2()/72)*480, res = plotres2())
      grid.draw(individual_modplot())
      dev.off()
    }
  )

  output$downloadTable3 <- downloadHandler(
    filename = function() {paste(values$project.name,'_','Qusage_Individual_GeneSet_Data_Table','.csv', sep='')  },
    content = function(file) {
      write.csv(individual_modselect()$mmr_modselection[,-1], file,row.names = FALSE)
    }
  )

  ################### ROAST ############################

  output$roast <- renderMenu({
    if(is.null(values$roast.results)){
      return(strong(""))
    }
    if(is.null(values$roast.results) == FALSE){
      menuItem("Roast", icon = icon("th-list"), tabName = "roast")
    }
  })

  output$setStat <- renderUI({
    selectInput("setStat1", "Select gene set statistic:", choices = names(values$roast.results), selected = names(values$roast.results)[1])
  })

  roast.overview <- reactive({
    results <- values$roast.results[[which(names(values$roast.results) %in% input$setStat1)]]
    Comparison <- names(results)
    Raw <- FDR <- Bonf <- c()
    for(i in 1:length(results)){
      Bonferroni <- p.adjust(results[[i]]$PValue, method = "bonferroni")
      Raw[i] <- length(which(results[[i]]$PValue <= input$SigLevelR))
      FDR[i] <- length(which(results[[i]]$FDR <= input$SigLevelR))
      Bonf[i] <- length(which(Bonferroni <= input$SigLevelR))
    }
    overview <- data.frame(Comparison = Comparison, Raw = Raw, FDR = FDR, Bonf = Bonf)
    overview
  })

  roast.results <- reactive({
    results <- values$roast.results[[which(names(values$roast.results) %in% input$setStat1)]]
    for(i in 2:length(results)){
      results[[i]] <- results[[i]][match(rownames(results[[1]]), rownames(results[[i]]), nomatch = 0),]
    }
    Gene.set <- rownames(results[[1]])
    results <- do.call("cbind", results)
    results <- cbind(Gene.set, results)
    results
  })

  output$CompOverviewR <- renderDataTable({
    roast.overview()
  })

  ###################FLOW PART##########################

  output$flow.data <- renderMenu({
    if(is.null(values$flow.data)){
      return(strong(""))
    }
    else{
      return(menuItem("Flow", icon = icon("th-list"), tabName = "flow"))
    }
  })

  FlowMMR<-reactive({
    x<-values$flow.results
    return(x)
  })

  FClist <- reactive({
    fc_1 <- FlowMMR()[grep("^P.Value", colnames(FlowMMR()))]
    fc_2 <- FlowMMR()[grep("^FDR.P.Value", colnames(FlowMMR()))]
    fc_3 <- apply(fc_1, 2, p.adjust, method = "bonferroni")
    sumfc <- function(alpha){
      Raw <- apply(fc_1, 2, function(x) sum(x[!is.na(x)] <= alpha))
      FDR <- apply(fc_2, 2, function(x) sum(x[!is.na(x)] <= alpha))
      Bonf <- apply(fc_3, 2, function(x) sum(x[!is.na(x)] <= alpha))
      sumfc <- rbind(Raw, FDR, Bonf)
      return(sumfc)
    }
    x <- t(sumfc(input$alphaFlow_1))
    y <- data.frame(Comparison = gsub("P.Value.","",rownames(x)), x)
    rownames(y) <- NULL
    y
  })

  output$FlowOverview <- renderDataTable({
    FClist()
  })

  output$downloadFC <- downloadHandler(
    filename = function() {paste0('Flow_Analysis_Overview-Significant_Probes_under_', input$alphaFlow_1, '.csv')  },
    content = function(file) {
      write.csv(FClist(), file,row.names = FALSE)
    }
  )

  output$CompF <- renderUI({
    nam <- colnames(FlowMMR())
    comp.names <- nam[grep("Estimate.", nam)]
    comp.names <- gsub("Estimate.", "", comp.names)
    selectInput("compflow", "Comparison Selection:", comp.names, comp.names[1])
  })

  output$flowlisttable <-renderDataTable({
    y <- callModule(filterOpts, "flowResultsTable", data = reactive(values$flow.results), comparison = reactive(input$compflow), data.type = "flow")
    return(y)
  })

  output$downloadFL <- downloadHandler(
    filename = function() {paste0('Flow_Analysis_Lists-', input$compflow, '_under_',  input$alphaFlow_2, '_', input$methodF, '.csv')  },
    content = function(file) {
      write.csv(flowlist(), file, row.names = FALSE)
    }
  )
  
  FlowData <- reactive({
    x <- values$flow.data
    if(input$FlowTransform){
      x[,which(colnames(x) %in% FlowMMR()$Flow.variable)] <- log2(x[,which(colnames(x) %in% FlowMMR()$Flow.variable)]+1)
    }
    return(x)
  })

  FlowDataForDownload<-reactive({  if(input$FlowVarSet=="No Flow Data"){return(NULL)}
    x <- values$flow.data
    subsetindex<-which(x[,which(names(x) %in% values$f_responder_var)] %in% input$FlowSub)
    x[subsetindex,]
    x
  })

  output$FlowDataNames<-renderUI({
    selectInput("FlowPlotVars","Variable(s):",as.character(FlowMMR()$Flow.variable), multiple = TRUE, selected = as.character(FlowMMR()$Flow.variable)[1])
  })

  output$FlowSummary<-renderTable({
    x <- values$flow.results
    x[is.na(x)]<-1
    head(x)
  }, include.rownames = FALSE)
  
  output$flowPlotGroup1<-renderUI({
    x <- values$flow.data[,-which(colnames(values$flow.data) %in% values$flow.results$Flow.variable)]
    groups <- colnames(x)
    selectizeInput("flowPlotGroup1","Select grouping factor1:",groups, options = list(maxItems = 1), multiple=TRUE)
  })
  
  output$flowPlotGroup1Vals <- renderUI({
   x <- values$flow.data[,-which(colnames(values$flow.data) %in% values$flow.results$Flow.variable)]
   vals <- unique(x[,input$flowPlotGroup1]) 
   selectizeInput("flowPlotGroup1Vals", "Select grouping factor1 values:",vals,multiple = TRUE)
  })
  
  output$flowPlotGroup2 <- renderUI({
    x <- values$flow.data[,-which(colnames(values$flow.data) %in% values$flow.results$Flow.variable)]
    groups <- colnames(x)
    selectizeInput("flowPlotGroup2","Select grouping factor2:",groups, options = list(maxItems = 1), multiple=TRUE)
  })
  
  output$flowPlotGroup2Vals <- renderUI({
   x <- values$flow.data[,-which(colnames(values$flow.data) %in% values$flow.results$Flow.variable)]
   vals <- unique(x[,input$flowPlotGroup2]) 
   selectizeInput("flowPlotGroup2Vals", "Select grouping factor2 values:",vals,multiple = TRUE)
  })
  
  output$flowTrackSubjects <- renderUI({
    if(is.null(time.var()$flow) | is.null(input$flowPlotGroup1) | is.null(input$flowPlotGroup2) | is.null(subject.id()$flow)){return(NULL)}
    if(input$flowPlotGroup2 == time.var()$flow){
      return(
       checkboxInput("flowTrackSubjects", "Track subjects over time ?", FALSE)
      )
    } else{
      return(NULL)
    }
  })

  flowplot <- reactive({
    if(length(input$FlowPlotVars) == 0){return(NULL)}
    mydata <- dummy <- index <- myplot <- list()
    for(i in 1:length(input$FlowPlotVars)){
     mydata[[i]] <- select(FlowData(), c(input$FlowPlotVars[i], input$flowPlotGroup1, input$flowPlotGroup2, subject.id()$flow)) %>% mutate(Flow.variable = input$FlowPlotVars[i])
     if(!is.null(input$flowPlotGroup1Vals)){
      mydata[[i]] <- filter_at(mydata[[i]], .vars = input$flowPlotGroup1, any_vars(. %in% input$flowPlotGroup1Vals))
     }
     if(!is.null(input$flowPlotGroup2Vals)){
      mydata[[i]] <-  filter_at(mydata[[i]], .vars = input$flowPlotGroup2, any_vars(. %in% input$flowPlotGroup2Vals))
     }
      if(is.null(input$flowPlotGroup1)){
        if(input$flowbox){
          myplot[[i]] <- ggplot(data=mydata[[i]], aes_string(x = "Flow.variable", y=input$FlowPlotVars[i])) + geom_boxplot() + ggtitle(input$FlowPlotVars[i])
        } else{
          myplot[[i]] <- ggplot(data=mydata[[i]], aes_string(x = "Flow.variable", y=input$FlowPlotVars[i])) + geom_point() + ggtitle(input$FlowPlotVars[i]) 
        }
      } else{
        if(is.null(input$flowPlotGroup2)){
          if(is.numeric(mydata[[i]][,input$flowPlotGroup1])){
            mydata[[i]] <- mydata[[i]][order(mydata[[i]][,input$flowPlotGroup1]),]
            mydata[[i]][,input$flowPlotGroup1] <- as.factor(mydata[[i]][,input$flowPlotGroup1])
          }
        if(input$flowbox){
          myplot[[i]] <- ggplot(data=mydata[[i]], aes_string(x=input$flowPlotGroup1, y=input$FlowPlotVars[i], fill=input$flowPlotGroup1)) + geom_boxplot() + 
           ggtitle(input$FlowPlotVars[i])
        } else{
          myplot[[i]] <- ggplot(data=mydata[[i]], aes_string(x=input$flowPlotGroup1, y=input$FlowPlotVars[i], colour=input$flowPlotGroup1)) + geom_point() + ggtitle(input$FlowPlotVars[i]) 
        }
        } else{
          if(is.numeric(mydata[[i]][,input$flowPlotGroup1])){
            mydata[[i]] <- mydata[[i]][order(mydata[[i]][,input$flowPlotGroup1]),]
            mydata[[i]][,input$flowPlotGroup1] <- as.factor(mydata[[i]][,input$flowPlotGroup1])
          }
          if(is.numeric(mydata[[i]][,input$flowPlotGroup2])){
            mydata[[i]] <- mydata[[i]][order(mydata[[i]][,input$flowPlotGroup2]),]
            mydata[[i]][,input$flowPlotGroup2] <- as.factor(mydata[[i]][,input$flowPlotGroup2])
          }
          if(input$flowbox){
            myplot[[i]] <- ggplot(data=mydata[[i]], aes_string(x=input$flowPlotGroup2, y=input$FlowPlotVars[i], fill=input$flowPlotGroup1)) + geom_boxplot() + 
             ggtitle(input$FlowPlotVars[i])
          } else{
            myplot[[i]] <- ggplot(data=mydata[[i]], aes_string(x=input$flowPlotGroup2, y=input$FlowPlotVars[i], colour=input$flowPlotGroup1)) + geom_point() + 
             ggtitle(input$FlowPlotVars[i]) 
          }
          if(time.var()$flow == input$flowPlotGroup2){
           if(input$flowTrackSubjects){
            subject.id <- subject.id()$flow
            myplot[[i]] <- ggplot(data=mydata[[i]], aes_string(x=input$flowPlotGroup2, y=input$FlowPlotVars[i],group = subject.id,colour=input$flowPlotGroup1)) + 
             geom_point() + geom_line(aes_string(x=input$flowPlotGroup2, y=input$FlowPlotVars[i],group=subject.id, colour = input$flowPlotGroup1)) +
             ggtitle(input$FlowPlotVars[i])
           }
          }
        }
      }
      myplot[[i]] <- myplot[[i]] + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    }
    plots <- do.call(multiplot, c(myplot, cols = 2))
    return(plots)
  })

  output$FlowPlot<-renderPlot({
    flowplot()
  })

  output$FlowPlotSummary<-renderDataTable({
   if(length(input$FlowPlotVars) == 0){return(NULL)}
   results <- summarizeData(data = FlowData(), numeric.vars = input$FlowPlotVars, by = c(input$flowPlotGroup1, input$flowPlotGroup2))
   return(results)
  })

  output$downloadFlowResults <- downloadHandler(
    filename = function() {paste(values$project.name,'_',input$comparisonflow,'.csv', sep='')  },
    content = function(file) {
      write.csv(FlowMMR(), file,row.names = FALSE)
    }
  )

  output$downloadFlowData <- downloadHandler(
    filename = function() {paste(values$project.name,'_FlowData','.csv', sep='')  },
    content = function(file) {
      write.csv(FlowDataForDownload(), file, row.names = FALSE)
    }
  )

  output$downloadFlowSummaries <- downloadHandler(
    filename = function() {paste(values$project.name,'_',"FlowSummary_",input$FlowPlotVars[1],'.csv', sep='')  },
    content = function(file) {
      write.csv(FlowPlotSummary1(), file, row.names = FALSE)
    }
  )

  output$downloadFlowPlot <- downloadHandler(
    filename = function() {paste(values$project.name,'_','FlowPlot1','.png', sep = '')},
    content = function(file){
      png(file, width = 900)
      print(flowplot())
      dev.off()
    }
  )


  ###############END OF FLOW PART####################

  ############### METABOLOMICS PART #################

  output$metab.data <- renderMenu({
    if(is.null(values$metab.data)){
      return(strong(""))
    }
    else{
      return(menuItem("Metab", icon = icon("th-list"), tabName = "metab2",
                      menuSubItem("PCA", tabName = "pcaM"),
                      menuSubItem("Differential Analysis", tabName = "metab")))
    }
  })

  MetabMMR<-reactive({
    x <- values$metab.results
    return(x)
  })

  Mlist <- reactive({
    fc_1 <- MetabMMR()[grep("^P.Value", names(MetabMMR()), fixed = TRUE)]
    fc_2 <- apply(fc_1, 2, p.adjust, method = "fdr")
    fc_3 <- apply(fc_1, 2, p.adjust, method = "bonferroni")
    sumfc <- function(alpha){
      Raw <- apply(fc_1, 2, function(x) sum(x[!is.na(x)] <= alpha))
      FDR <- apply(fc_2, 2, function(x) sum(x[!is.na(x)] <= alpha))
      Bonf <- apply(fc_3, 2, function(x) sum(x[!is.na(x)] <= alpha))
      sumfc <- rbind(Raw, FDR, Bonf)
      return(sumfc)
    }
    x <- t(sumfc(input$alphaMetab_1))
    y <- data.frame(Comparison = substring(rownames(x), 13), x)
    rownames(y) <- NULL
    y
  })

  output$MetabOverview <- renderDataTable({
    Mlist()
  })

  output$downloadFC2 <- downloadHandler(
    filename = function() {paste0('Metab_Analysis_Overview-Significant_Probes_under_', input$alphaMetab_1, '.csv')  },
    content = function(file) {
      write.csv(Mlist(), file,row.names = FALSE)
    }
  )

  output$CompM <- renderUI({
    nam <- names(MetabMMR())
    p.names <- substring(nam[grep("Estimate of ", nam, fixed = TRUE)], 13)
    selectInput("compmetab", "Comparison Selection:", p.names, p.names[1])
  })

  metablist <- reactive({
    dat <- MetabMMR()
    x <- flowlistmaker(dat, input$compmetab, input$alphaMetab_2, input$methodM)
    dummy <- data.frame("No Variables Present")
    names(dummy) <- "Metab_Variable"
    if(identical(x,dummy)){return(x)}
    else{
      ind1 <- grep("Estimate", names(x), fixed = TRUE)
      ind2 <- grep("Test.statistic", names(x), fixed = TRUE)
      ind3 <- grep("P.Value", names(x), fixed = TRUE)
      ind4 <- grep("FDR", names(x), fixed = TRUE)
      ind5 <- grep("BONF", names(x), fixed = TRUE)
      x <- x[,c(1,ind1, ind2, ind3, ind4, ind5)]
      names(x) <- c("Metab_Variable","Estimate", "Test.statistic", "P.Value", "FDR", "BONF")
      return(x)
    }
  })

  output$metablisttable <-renderDataTable({
    if(is.null(metablist())){return(NULL)}
    metablist()
  })

  output$downloadME <- downloadHandler(
    filename = function() {paste0('Metab_Analysis_Lists-', input$compmetab, '_under_',  input$alphaMetab_2, '_', input$methodM, '.csv')  },
    content = function(file) {
      write.csv(metablist(), file, row.names = FALSE)
    }
  )

  MetabData<-reactive({
    x <- values$metab.data
    subsetindex<-which(x[,which(names(x) %in% values$m_responder_var)] %in% input$MetabSub)
    x[subsetindex,]
  })

  MetabDataForDownload<-reactive({
    x <- values$metab.data
    subsetindex<-which(x[,which(names(x) %in% values$m_responder_var)] %in% input$MetabSub)
    x[subsetindex,]
    x
  })

  MetabResult <- reactive({
    MetabMMR()
  })

  output$MetabResultTable<-renderDataTable({
    head(MetabResult())
  })

  output$MetabDataNames<-renderUI({
    selectInput("MetabPlotVars","Variable(s):",as.character(MetabMMR()$Metab.variable), multiple = TRUE, selected = as.character(MetabMMR()$Metab.variable)[1])
  })

  output$pcaAnnotM <- renderUI({
    dat <- values$metab.data
    num <- sapply(dat, is.numeric)
    groups <- dat[,which(num == FALSE),drop = FALSE]
    selectInput("pcaAnnot2M", "Select grouping factor:", colnames(groups), selected = colnames(groups)[which(colnames(groups) %in% values$m_responder_var)])
  })

  output$pcaAnnotValsM <- renderUI({
    dat <- values$metab.data
    num <- sapply(dat, is.numeric)
    groups <- dat[,which(num == FALSE),drop = FALSE]
    values <- unique(groups[,input$pcaAnnot2M])
    selectInput("pcaAnnValsM", "Select grouping factor values:", values, selected = values, multiple = TRUE)
  })

  output$pcaBlockingM <- renderUI({
    if(is.null(time.var()$metab)){return(NULL)}
    dat <- values$metab.data
    selectInput("pcaBlockM", "PCA by time:", c("All timepoints", unique(dat[,time.var()$metab])), selected = "All timepoints")
  })

  PCAM <- reactive({
    dat <- values$metab.data
    if(!is.null(time.var()$metab)){
      if(input$pcaBlockM == "All timepoints"){
        metabDat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM),which(colnames(dat) %in% as.character(MetabMMR()$Metab.variable))]
        dat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM),]
      }
      else{
        metabDat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM & dat[,time.var()$metab] %in% input$pcaBlockM),which(colnames(dat) %in% as.character(MetabMMR()$Metab.variable))]
        dat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM & dat[,time.var()$metab] %in% input$pcaBlockM),]
      }
    }
    else{
      metabDat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM),which(colnames(dat) %in% as.character(MetabMMR()$Metab.variable))]
      dat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM),]
    }
    sds <- sapply(metabDat, sd)
    if(length(which(sds == 0)) > 0){
      metabDat <- metabDat[,-which(sds == 0)]
    }
    pca <- prcomp(metabDat, scale = TRUE)
    z <- list(dat = dat, pca = pca)
  })

  PCAdatM <- reactive({
    pca <- PCAM()$pca
    dat <- PCAM()$dat
    num <- sapply(dat, is.numeric)
    groups = dat[,which(num == FALSE),drop = FALSE]
    annotations <- groups[,input$pcaAnnot2M]
    pcs <- data.frame(pca$x, annotations)
    colnames(pcs)[ncol(pcs)] <- "Group"
    pcs
  })

  plotw.pcaM <- function(){
    input$PlotWidthPCAM
  }

  ploth.pcaM <- function(){
    input$PlotHeightPCAM
  }

  observeEvent(input$showM, {
    shinyjs::toggle("screePlot2M")
  })

  output$screePlotM <- renderUI({
    plotOutput("screePlot2M")
  })

  output$PCAplot3dM <- renderUI({
    if(input$PCSnumM != 3){
      return(NULL)
    }
    else{
      return(plotOutput("pcaPlot3dM"))
    }
  })

  output$screePlot2M <- renderPlot({
    dat <- as.data.frame(summary(PCAM()$pca)[[length(summary(PCAM()$pca))]])
    dat <- as.data.frame(t(dat))
    dat <- cbind(PC = rownames(dat), dat)
    dat[,2] <- NULL
    dat <- reshape2::melt(dat, id = "PC")
    dat$PC <- factor(dat$PC, levels = dat$PC)
    p <- ggplot(data = dat[which(dat$PC %in% levels(dat$PC)[1:10]),], aes(x = PC, y = value, group = variable)) + geom_line(size = 1.5, aes(colour = variable))
    p <- p + geom_point(size = 3, shape = 21, fill = "white") + ylim(0,1) + ylab("Proportion of Variance") + theme_minimal()
    p
  })


  output$PCAplotM <- renderPlot({
    qplot(PC1, PC2, data = PCAdatM(), colour = Group, size = I(input$CircleSizePCAM))
  }, width = plotw.pcaM, height = ploth.pcaM)

  output$pcaPlot3dM <- renderPlot({
    pca3d::pca3d(PCAM()$pca, group = PCAdatM()$Group, bg = "black", legend = "topright")
  })

  output$MetabSummary<-renderTable({
    x <- values$metab.results
    x[is.na(x)]<-1
    head(x)
  }, include.rownames = FALSE)

  output$metabmax<-renderUI({ numericInput("MetabMax","Max value to be plotted for time:",max(MetabData()[,which(names(MetabData()) %in% time.var()$metab)]))  })
  output$metabmin<-renderUI({ numericInput("MetabMin","Min value to be plotted for time:",min(MetabData()[,which(names(MetabData()) %in% time.var()$metab)]))  })
  output$metabsub<-renderUI({
    x<-values$metab.data
    y<-unique(as.character(x[,which(names(x) %in% values$m_responder_var)]))
    selectInput("MetabSub","Responder levels:",y,y[1:length(y)],multiple=TRUE)
  })

  metabplot <- reactive({
    if(length(input$MetabPlotVars) == 0){return(NULL)}
    if(length(input$MetabSub) == 0){return(NULL)}
    if(is.numeric(input$MetabMin) == FALSE & is.numeric(input$MetabMax) == FALSE){return(NULL)}
    
    mysummary<-function(x){
      y<-c(mean(x),sd(x),length(x))
      names(y)<-c("Mean","Sd","N")
      return(y)
    }
    
    mydata <- sum1 <- summaries <- result <- myplot <- list()
    for(i in 1:length(input$MetabPlotVars)){
      if(!input$MetabTransform){
        mydata[[i]] <- data.frame(MetabVar=MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])],
                                  time=MetabData()[,which(names(MetabData()) %in% time.var()$metab)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% subject.id()$metab)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      } else{
        mydata[[i]] <- data.frame(MetabVar=log2(MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])]),
                                  time=MetabData()[,which(names(MetabData()) %in% time.var()$metab)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% subject.id()$metab)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      }
      sum1[[i]] <- aggregate(MetabVar~responder+time, data=mydata[[i]], mysummary)
      summaries[[i]] <- sum1[[i]][,3]
      result[[i]] <- as.data.frame(cbind(sum1[[i]][,c(1,2)],summaries[[i]]))
      names(result[[i]])<-c("ResponderStatus","Time",colnames(summaries[[i]]))
      myplot[[i]] <- ggplot(data=result[[i]],aes(x=Time, y=Mean,group=ResponderStatus,colour=ResponderStatus))+geom_point()+geom_line(aes(size=.7))+
        geom_errorbar(aes(ymin = Mean - 2*Sd, ymax = Mean + 2*Sd,size=.7)) +
        scale_size(range=c(.1, 2),guide=FALSE)+ xlim(input$MetabMin, input$MetabMax)+ggtitle(input$MetabPlotVars[i])
      if(input$MetabSamples){
        myplot[[i]] <- myplot[[i]] + geom_point(data=mydata[[i]],aes(x=time,y=MetabVar,group=subjectid,colour=responder,size=1))+
          geom_line(data=mydata[[i]],aes(x=time,y=MetabVar,group=subjectid,colour=responder,size=.25))
      }
    }
    z <- do.call(multiplot, c(myplot, cols = 2))
    return(z)
  })

  metabplot2 <- reactive({
    if(length(input$MetabPlotVars) == 0){return(NULL)}
    mydata <- dummy <- index <- myplot <- list()
    for(i in 1:length(input$MetabPlotVars)){
      if(!input$MetabTransform){
        mydata[[i]] <- data.frame(MetabVar=MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])],
                                          time=MetabData()[,which(names(MetabData()) %in% time.var()$metab)],
                                          subjectid=MetabData()[,which(names(MetabData()) %in% subject.id()$metab)],
                                          responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      } else{
        mydata[[i]] <- data.frame(MetabVar=log2(MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])]),
                                  time=MetabData()[,which(names(MetabData()) %in% time.var()$metab)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% subject.id()$metab)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      }
      mydata[[i]] <- mydata[[i]][order(mydata[[i]]$time,mydata[[i]]$responder),]
      mydata[[i]]$time<-factor(mydata[[i]]$time,ordered=T)
      mydata[[i]]$Time_Responder<-factor(paste(mydata[[i]]$time,mydata[[i]]$responder,sep="_"),ordered=T)
      dummy[[i]] <- data.frame(do.call(rbind,strsplit(levels(mydata[[i]]$Time_Responder),"_")))
      index[[i]] <- order(as.numeric(as.character(dummy[[i]]$X1)))
      mydata[[i]]$Time_Responder<-factor(paste(mydata[[i]]$time,mydata[[i]]$responder,sep="_"),levels(mydata[[i]]$Time_Responder)[index[[i]]])
      if(input$metabbox){
        myplot[[i]] <- ggplot(data=mydata[[i]],aes(x=time,y=MetabVar,fill=responder,colour=responder)) + geom_boxplot() + 
          ggtitle(input$MetabPlotVars[i])
      } else{
        myplot[[i]] <- ggplot(data=mydata[[i]],aes(x=Time_Responder,y=MetabVar,fill=responder,colour=responder)) + geom_point() + 
          theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(input$MetabPlotVars[i])
      }
    }
    z <- do.call(multiplot, c(myplot, cols = 2))
    return(z)
  })

  output$MetabPlot<-renderPlot({
    print(metabplot())
  })

  output$MetabPlot2<-renderPlot({
    print(metabplot2())
  })

  MetabPlotSummary1<-reactive({
    if(length(input$MetabPlotVars) == 0){return(NULL)}
    if(length(input$MetabSub) == 0){return(NULL)}
    
    mysummary<-function(x){
      y<-c(mean(x),sd(x),length(x))
      names(y)<-c("Mean","Sd","N")
      return(y)
    }
    
    mydata <- sum1 <- summaries <- result <- list()
    MetabVariable <- c()
    for(i in 1:length(input$MetabPlotVars)){
      if(!input$MetabTransform){
        mydata[[i]] <- data.frame(MetabVar=MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])],
                                  time=MetabData()[,which(names(MetabData()) %in% time.var()$metab)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% subject.id()$metab)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      } else{
        mydata[[i]] <- data.frame(MetabVar=log2(MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])]),
                                  time=MetabData()[,which(names(MetabData()) %in% time.var()$metab)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% subject.id()$metab)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      }
      sum1[[i]] <- aggregate(MetabVar~responder+time, data=mydata[[i]], mysummary)
      summaries[[i]] <- sum1[[i]][,3]
      result[[i]] <- as.data.frame(cbind(sum1[[i]][,c(1,2)],summaries[[i]]))
      names(result[[i]])<-c("ResponderStatus","Time",colnames(summaries[[i]]))
      MetabVariable <- c(MetabVariable, rep(input$MetabPlotVars[i], length(result[[i]][,i])))
    }
    
    z <- do.call(rbind, result)
    z <- cbind(MetabVariable, z)
    return(z)
  })

  output$normMetab<-renderUI({

    if(is.null(values$rowdend3)){
      if(ctrl()$metab == TRUE){
        try<-list("Baseline Median Normalized" = 1,
                  "Baseline Healthy Normalized" = 2)
      }

      if(ctrl()$metab == FALSE){
        try<-list("Baseline Median Normalized" = 1)
      }
    }

    if(!is.null(values$rowdend3)){
      if(ctrl()$metab == TRUE){
        try<-list("Baseline Mean Normalized" = 1,
                  "Baseline Healthy Normalized" = 2,
                  "All Samples Mean Normalized" = 3,
                  "All Samples Healthy Normalized"=4,
                  "All Samples Baseline Normalized"=5)
      }

      if(ctrl()$metab == FALSE){
        try<-list("Baseline Mean Normalized" = 1,
                  "All Samples Mean Normalized" = 3,
                  "All Samples Baseline Normalized"=5)
      }
    }

    selectInput("set3", "Select heatmap:",as.list(try))
  })

  heatmapdatam <-reactive({
    design <- design()$metab
    metabdat <- values$metab.data
    metabvars <- as.character(values$metab.results$Metab.variable)
    final_expression <- metabdat[,which(colnames(metabdat) %in% metabvars)]
    final_expression <- final_expression[,match(metabvars, colnames(final_expression), nomatch = 0)]
    rownames(final_expression) <- as.character(design()$metab$columnname)
    final_expression <- as.data.frame(t(final_expression))
    metabvars <- metabvars[match(rownames(final_expression), metabvars,nomatch = 0)]
    #Transcript.ID <- as.character(metabvars)
    #Gene.Symbol <- as.character(metabvars)
    final_expression <- log2(final_expression)
    #final_expression <- do.call("cbind", list(Transcript.ID = Transcript.ID,Gene.Symbol=Gene.Symbol, final_expression))
    final_expression <- final_expression[which(rownames(final_expression) %in% metablist()[,1]),]

    if (input$set3==1){#heatmapbase1
      if(ctrl()$metab == TRUE){
        base_sample_name <- design()$metab$columnname[which(design()$metab[,baseline.var()$metab] == baseline.val()$metab & design()$metab[,control.var()$metab] != values$m_control_val)]
        index <- which(colnames(final_expression) %in% base_sample_name)
      }
      if(ctrl()$metab == FALSE){
        base_sample_name <- design()$metab$columnname[which(design()$metab[,baseline.var()$metab] == baseline.val()$metab)]
        index <- which(colnames(final_expression) %in% base_sample_name)
      }
      exp_base_sam=final_expression[,index]
      des_base_sam=design()$metab[which(design()$metab$columnname%in%colnames(exp_base_sam)),]
      y<-manipulateData(y = exp_base_sam, x = des_base_sam,colname = "columnname")
    }
    if (input$set3==2){
      base_sample_name <- design()$metab$columnname[which(design()$metab[,baseline.var()$metab]==baseline.val()$metab | design()$metab[,control.var()$metab]==values$m_control_val)]
      index <- which(colnames(final_expression) %in% base_sample_name)
      exp_base_sam <- final_expression[, index]
      des_base_sam <- design()$metab[which(design()$metab$columnname %in% colnames(exp_base_sam)), ]
      y<-manipulateData(y=exp_base_sam,x=des_base_sam,colname ="columnname",ref.var=control.var()$metab,ref.val=values$m_control_val,long=FALSE,keep.ref=TRUE)
    }
    if (input$set3==3){
      y<-manipulateData(y=final_expression,x=design()$metab,colname="columnname")
    }
    if (input$set3==4){
      y <- manipulateData(y = final_expression, x = design()$metab, colname = "columnname", ref.var = control.var()$metab, ref.val = values$m_control_val, long = FALSE, keep.ref = TRUE)
    }
    if (input$set3==5){#heatmap3
      if(ctrl()$metab==TRUE){
        des_w_controls<-design()$metab[which(design()$metab$columnname %in% colnames(final_expression)),]
        des_wo_controls<-design()$metab[-which(design()$metab[,control.var()$metab]==values$m_control_val),]
        h5index<-which(colnames(final_expression) %in% des_wo_controls$columnname)
        y<-manipulateData(y=final_expression[,h5index],x=des_wo_controls,colname="columnname",ref.var=baseline.var()$metab,ref.val=baseline.val()$metab,long=TRUE,subject.id=subject.id()$metab,keep.ref=FALSE)
      }
      if(ctrl()$metab==FALSE){
        y<-manipulateData(y=final_expression,x=design()$metab,colname="columnname",ref.var=baseline.var()$metab,ref.val=baseline.val()$metab,long=TRUE,subject.id=subject.id()$metab,keep.ref=FALSE)
        
      }
    }
    z<-list(y=y)
    return(z)
  })

  heatmapnamem<-reactive({
    if(input$set3==1) heattxt<-"Baseline Median Normalized"
    if(input$set3==2) heattxt<-"Baseline Healthy Normalized"
    if(input$set3==3) heattxt<-"All Samples Median Normalized"
    if(input$set3==4) heattxt<-"All Samples Healthy Normalized"
    if(input$set3==5) heattxt<-"All Samples Normalized to each Subjects Baseline"
    heattxt
  })

  metabGraphParams <- eventReactive(input$go4, {
    params <- callModule(graphOptions, "metabGraphOptions")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution)
    return(params)
  })
  
  metabPlotWidth <- function(){metabGraphParams()$width}
  metabPlotHeight <- function(){metabGraphParams()$height}
  
  callModule(subsetAndOrderRenderUI, "metabSubOrder", des = reactive(design()$metab))
  
  metabRowCluster <- eventReactive(input$go4, {
    x <- heatmapdatam()$y$exprs.norm
    ddm <- NA
    if(input$metabRowCluster){
      dist <- dist(x)
      hcl <- fastcluster::hclust(dist)
      ddm <- as.dendrogram(hcl)
      Rowv <- rowMeans(x, na.rm = TRUE)
      ddm <- reorder(ddm, Rowv)
    }
    labelRows <- NULL
    y <- list(x = x, ddm = ddm, labelRows = labelRows)
    return(y)
  })
  
  metabClusterData <- eventReactive(input$go4,{
    x <- callModule(colCluster, "metabCluster", des = reactive(metabOrderedData()$colAnnot), data = reactive(metabOrderedData()$x))
    return(x)
  })
  
  metabOrderedData <- reactive({
    dat <- callModule(subsetAndOrder, "metabSubOrder", des = reactive(heatmapdatam()$y$design.norm), data = reactive(metabRowCluster()$x), 
                      sampleAnnot = reactive(sample.id()$metab))
    x <- dat$dat
    colAnnot <- dat$colAnnot
    design <- dat$design
    z <- list(x = x, colAnnot = colAnnot, design = design)
    return(z)
  })
  
  metabMaxRangeData <- eventReactive(input$go4, {
    x <- callModule(maxValues, "metabMaxValues", reactive(metabOrderedData()$x))
    return(x)
  })
  
  metabHeatColors <- eventReactive(input$go4, {
    x <- callModule(annColors, "metabSubOrder", reactive(metabOrderedData()$colAnnot))
    return(x)
  })
  
  output$heatmapm <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(metabMaxRangeData(),Rowv = metabRowCluster()$ddm,Colv = metabClusterData()$colddm, treeheight = metabGraphParams()$treeHeight, fontsize = metabGraphParams()$fontSize, cexRow = 1.2, 
                             annheight = metabGraphParams()$legendSize,color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = metabClusterData()$colAnnot,annColors = metabHeatColors(),labRow=metabRowCluster()$labelRows,
                             breaks=0)
                 }
    )
  }, width = metabPlotWidth, height = metabPlotHeight)
  

  output$downloadHeatmapm <- downloadHandler(
    filename = function() {paste('SignificantMetab_Heatmap','.png', sep = '')},
    content = function(file){
      x <- expression_matrixm()$x
      if(input$setcutoff2!=0){
        cut1<-as.numeric(input$setcutoff2)
        x[x>cut1]<-cut1
        x[x<(-cut1)]<--cut1
      }
      png(file, width = plotsize_mW(), height = plotsize_mH(), res = resolutionm())
      print(aheatmap2(x,Rowv=TRUE,Colv=opt_numClustm()$colddm,cexRow=1.2, treeheight = input$Metab_TreeHeight, fontsize = input$Metab_FontSize, annheight = input$Metab_LegendSize, color = colorRampPalette(c("navy", "yellow", "firebrick3"))(50),annCol = heatmap_colorsm()$groups,annColors= heatmap_colorsm()$first_color,labRow=NA,breaks=0))
      dev.off()
    }
  )

  heatmap_download2M <- reactive({
    heatmapdata <- cbind(expression_matrix2()$symb, expression_matrix2()$y$exprs.norm)
    heatmapdata <- cbind(expression_matrix2()$probeids, heatmapdata)
    return(heatmapdata)
  })

  #output$downloadHeatmap1 <- downloadHandler(
    #filename = function() {paste(values$project.name,'_',heatmapname1(),'.csv', sep='')  },
    #content = function(file) {
      #write.csv(heatmap_download2M(), file, row.names = FALSE)
    #}
  #)

  output$MetabPlotSummary<-renderDataTable({
    MetabPlotSummary1()
  })

  output$downloadMetabResults <- downloadHandler(
    filename = function() {paste(values$project.name,'_',input$comparisonmetab,'.csv', sep='')  },
    content = function(file) {
      write.csv(MetabResult(), file,row.names = FALSE)
    }
  )

  output$downloadMetabData <- downloadHandler(
    filename = function() {paste(values$project.name,'_MetabData','.csv', sep='')  },
    content = function(file) {
      write.csv(MetabDataForDownload(), file, row.names = FALSE)
    }
  )

  output$downloadMetabSummaries <- downloadHandler(
    filename = function() {paste(values$project.name,'_',"MetabSummary_",input$MetabPlotVars[1],'.csv', sep='')  },
    content = function(file) {
      write.csv(MetabPlotSummary1(), file, row.names = FALSE)
    }
  )

  output$downloadMetabPlot <- downloadHandler(
    filename = function() {paste(values$project.name,'_','MetabPlot1','.png', sep = '')},
    content = function(file){
      png(file, width = 900)
      print(metabplot())
      dev.off()
    }
  )

  output$downloadMetabPlot2 <- downloadHandler(
    filename = function() {paste(values$project.name,'_','MetabPlot2','.png', sep = '')},
    content = function(file){
      png(file, width = 900)
      print(metabplot2())
      dev.off()
    }
  )

  ############# END OF METABOLOMICS PART ################

  ###############Correlations########################
  
  output$correlations <- renderMenu({
    if(is.null(values$corrs)){
      return(strong(""))
    }
    else{
      return(menuItem("Correlations", icon = icon("bolt"), tabName = "corr"))
    }
  })
  
  output$TypeVariable <- renderUI({
    selectInput("TypeVariable1", "Choose Correlation Data:", choices = values$corr.names, selected = values$corr.names[1])
  })
  
  output$TypeVariable2 <- renderUI({
    selectInput("TypeVariable3", "Choose Correlation Data:", choices = values$corr.names, selected = values$corr.names[1])
  })
  
  output$TypeVariable4 <- renderUI({
    selectInput("TypeVariable5", "Choose Correlation Data:", choices = values$corr.names, selected = values$corr.names[1])
  })
  
  output$TypeVariable6 <- renderUI({
    selectInput("TypeVariable7", "Choose Correlation Data:", choices = values$corr.names, selected = values$corr.names[1])
  })
  
  output$var_switch <- renderUI({
    checkboxInput("var_switch", strong(paste0("Change Figure Rows to ", values$x.var[which(values$corr.names == input$TypeVariable1)])), value = FALSE)
  })
  
  corrResultsOverview <- reactive({
    correlations <- results <- Raw <- FDR <- Bonf <- list()
    for(i in 1:length(values$corrs)){
      corrs <- data.table::as.data.table(values$corrs[[i]][,c(2,1,3:ncol(values$corrs[[i]]))])
      corrs$FDR <- 1
      corrs$Bonf <- 1
      corrs[,FDR := p.adjust(Raw.P.Value, method = "fdr"), by = c(names(corrs)[c(2,3)])]
      corrs[,Bonf := p.adjust(Raw.P.Value, method = "bonferroni"), by = c(names(corrs)[c(2,3)])]
      corrs <- as.data.frame(corrs)
      corrs <- corrs[,c(2,1,3:ncol(corrs))]
      comps <- raw <- fdr <- bonf <- c()
      for(j in 1:length(unique(values$corrs[[i]][,3]))){
        comps[j] <- paste0(values$corr.names[i],"_",as.character(unique(values$corrs[[i]][,3])[j]))
        corrs.sub <- corrs[corrs[,3] == unique(corrs[,3])[j],]
        if(input$overviewCorrVal){
          if(input$selectCorrSign == "+"){
            corrs.sub <- corrs.sub[corrs.sub[,4] > input$selectCorrVal,]
          } else if(input$selectCorrSign == "-"){
            corrs.sub <- corrs.sub[corrs.sub[,4] < -input$selectCorrVal,]
          } else{
            corrs.sub <- corrs.sub[corrs.sub[,4] < -input$selectCorrVal | corrs.sub[,4] > input$selectCorrVal,]
          }
        }
        raw[j] <- length(which(corrs.sub$Raw.P.Value <= input$alphaCorr))
        fdr[j] <- length(which(corrs.sub$FDR <= input$alphaCorr))
        bonf[j] <- length(which(corrs.sub$Bonf <= input$alphaCorr))
      }
      results[[i]] <- data.frame(Correlation_Comparisons = comps, Raw = raw, FDR = fdr, Bonf = bonf)
      correlations[[i]] <- corrs
    }
    results <- do.call("rbind", results)
    z <- list(correlations = correlations, results = results)
  })
  
  output$corrOverview <- renderDataTable({
    withProgress(message = 'Making Results Table',
                 detail = 'This may take a while...', value = .1,{
                   corrResultsOverview()$results[order(corrResultsOverview()$results$Raw, decreasing = TRUE),]
                 }
    )
  })
  
  output$downloadOverviewCorrTable <- downloadHandler(
    filename = function() {paste(values$project.name, "_", "Correlation_Results_Overview_Table.csv")},
    content = function(file) {
      write.csv(corrResultsOverview()$results[order(corrResultsOverview()$results$Raw, decreasing = TRUE),], file, row.names = FALSE)
    }
  )
  
  output$subsetcorr <- renderUI({
    correlations <- values$corrs[[which(values$corr.names == input$TypeVariable1)]]
    if(input$var_switch == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    visit.name = colnames(correlations)[3]
    visit <- unique(correlations[,3])
    visit <- gtools::mixedsort(as.character(visit))
    selectInput("subsetcorr1", "", choices = visit, selected = visit, multiple = TRUE)
  })
  
  output$WithVariable1 <- renderUI({
    correlations <- values$corrs[[which(values$corr.names == input$TypeVariable1)]]
    if(input$var_switch == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    selectInput("WithVariable", "Choose Correlation Variable(s):", choices = as.character(gtools::mixedsort(unique(correlations$With))), selected = gtools::mixedsort(unique(correlations$With))[1], multiple = TRUE)
  })
  
  output$WithVariable2 <- renderUI({
    correlations <- values$corrs[[which(values$corr.names == input$TypeVariable3)]]
    if(input$var_switch2 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    selectInput("WithVariable3", "Choose Correlation Variable(s):", choices = as.character(gtools::mixedsort(unique(correlations$With))), selected = as.character(gtools::mixedsort(unique(correlations$With)))[1])
  })
  
  output$corr_Variable <- renderUI({
    correlations <- values$corrs[[which(values$corr.names == input$TypeVariable7)]]
    selectInput("corr_Variable2", paste("Choose", values$y.var[which(values$corr.names == input$TypeVariable7)], "Variable:", sep = " "), choices = as.character(gtools::mixedsort(unique(correlations$Variable))), selected = as.character(gtools::mixedsort(unique(correlations$With)))[1])
  })
  
  output$WithVariable4 <- renderUI({
    correlations <- values$corrs[[which(values$corr.names == input$TypeVariable7)]]
    selectInput("WithVariable5", paste("Choose ", values$x.var[which(values$corr.names == input$TypeVariable7)], " Variable:", sep = ""), choices = as.character(gtools::mixedsort(unique(correlations$With))), selected = as.character(gtools::mixedsort(unique(correlations$With)))[1])
  })
  
  output$uploadmod1 <- renderUI({
    if(input$var_switch == FALSE){
      return(checkboxInput("uploadmod", strong(paste("Upload ",values$y.var[which(values$corr.names == input$TypeVariable1)], " List:", sep = ""), style = "color:blue"), FALSE))
    } else{
      return(checkboxInput("uploadmod", strong(paste("Upload ",values$x.var[which(values$corr.names == input$TypeVariable1)], " List:", sep = ""), style = "color:blue"), FALSE))
    }
  })
  
  output$fileupload1 <- renderUI({
    if(input$uploadmod == TRUE){
      return(fileInput('modselect', '', accept = ".csv"))
    }
    else{
      return(NULL)
    }
  })
  
  output$uploadmod3 <- renderUI({
    if(input$var_switch3 == FALSE){
      return(checkboxInput("uploadmod2", strong(paste("Upload ",values$y.var[which(values$corr.names == input$TypeVariable5)], " List:", sep = ""), style = "color:blue"), FALSE))
    } else{
      return(checkboxInput("uploadmod2", strong(paste("Upload ",values$x.var[which(values$corr.names == input$TypeVariable5)], " List:", sep = ""), style = "color:blue"), FALSE))
    }
  })
  
  output$fileupload2 <- renderUI({
    if(input$uploadmod2 == TRUE){
      return(fileInput('modselect2', '', accept = ".csv"))
    }
    else{
      return(NULL)
    }
  })
  
  heatmap.data <- reactive({
    correlations <- corrResultsOverview()$correlations[[which(values$corr.names == input$TypeVariable1)]]
    if(input$var_switch == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    if(input$uploadmod == TRUE){
      modnames.corr <- read.csv(input$modselect$datapath, header = TRUE)
      modnames.corr <- as.character(modnames.corr[,1])
      modnames.corr <- gsub(".", "_", modnames.corr,fixed = TRUE)
      correlations <- correlations[which(correlations$Variable %in% modnames.corr),]
      
      col_anno <- list()
      col_anno2 <- list()
      dat <- list()
      dat2 <- list()
      keep_names <- list()
      
      names <- gtools::mixedsort(unique(as.character(correlations[,3])))
      
      if(input$subsetModcorr == TRUE){
        names <- input$subsetcorr1
      }
      
      for(j in 1:length(input$WithVariable)){
        correlations1 <- correlations[which(correlations$With %in% input$WithVariable[j]),]
        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat[[i]] <- dat[[i]][which(dat[[i]]$Variable %in% modnames.corr),]
          dat[[i]] <- as.character(dat[[i]]$Variable)
        }
        
        keep_names[[j]] <- Reduce(intersect, dat)
      }
      
      keep_names <- unlist(keep_names)
      
      for(j in 1:length(input$WithVariable)){
        correlations1 <- correlations[which(correlations$With %in% input$WithVariable[j]),]
        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat[[i]] <- dat[[i]][which(dat[[i]]$Variable %in% keep_names),]
          dat[[i]] <- dat[[i]][order(dat[[i]]$Variable),]
          dat[[i]] <- dat[[i]][,4]
          col_anno[[i]] <- input$WithVariable[j]
        }
        
        col_anno2[[j]] <- unlist(col_anno)
        dat2[[j]] <- do.call("cbind", dat)
        rownames(dat2[[j]]) <- sort(unique(keep_names))
        colnames(dat2[[j]]) <- names
      }
      
      col_anno <- data.frame(unlist(col_anno2))
      colnames(col_anno)[1] <- paste(values$x.var[which(values$corr.names == input$TypeVariable1)], "variable", sep = " ")
      if(input$var_switch){
        colnames(col_anno)[1] <- paste(values$y.var[which(values$corr.names == input$TypeVariable1)], "variable", sep = " ")
      }
      dat <- do.call("cbind", dat2)
      z <- list(col_anno = col_anno, dat = dat)
    } else{
      dat3 <- list()
      colnames3 <- list()
      rownames3 <- list()
      
      for(j in 1:length(input$WithVariable)){
        correlations1 <- correlations[which(correlations$With %in% input$WithVariable[j]),]
        
        dat <- list()
        sig <- list()
        cor_vals <- list()
        names <- gtools::mixedsort(unique(as.character(correlations1[,3])))
        
        if(input$subsetModcorr == TRUE){
          names <- input$subsetcorr1
        }
        
        if(input$corrval2 == TRUE){
          if(input$corrsign1 == "+"){
            for(i in 1:length(names)){
              dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
              cor_vals[[i]] <- dat[[i]][which(dat[[i]][,4] >= input$corrval3),]
              cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
            }
          }
          if(input$corrsign1 == "-"){
            for(i in 1:length(names)){
              dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
              cor_vals[[i]] <- dat[[i]][which(dat[[i]][,4] <= -input$corrval3),]
              cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
            }
          }
          if(input$corrsign1 == "Both"){
            for(i in 1:length(names)){
              dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
              cor_vals[[i]] <- dat[[i]][c(which(dat[[i]][,4] <= -input$corrval3),which(dat[[i]][,4] >= input$corrval3)),]
              cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
            }
          }
          
          cor_vals <- Reduce(union,cor_vals)
          correlations1 <- correlations1[which(correlations1$Variable %in% cor_vals),]
        }
        
        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          
          if(input$correction_method.corr == "Raw"){
            sig[[i]] <- dat[[i]][which(dat[[i]]$Raw.P.Value <= input$Alpha1),]
          }
          
          if(input$correction_method.corr == "FDR"){
            sig[[i]] <- dat[[i]][which(dat[[i]]$FDR <= input$Alpha1),]
          }
          
          if(input$correction_method.corr == "Bonferroni"){
            sig[[i]] <- dat[[i]][which(dat[[i]]$Bonf <= input$Alpha1),]
          }
          
          sig[[i]] <- as.character(sig[[i]]$Variable)
        }
        
        sigvars <- Reduce(union,sig)
        
        correlations1 <- correlations1[which(correlations1$Variable %in% sigvars),]
        
        dat2 <- list()
        for(i in 1:length(names)){
          dat2[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat2[[i]] <- dat2[[i]][which(dat2[[i]]$Variable %in% sigvars),]$Variable
        }
        
        dat2 <- Reduce(intersect, dat2)
        
        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat[[i]] <- dat[[i]][which(dat[[i]]$Variable %in% dat2),]
          dat[[i]] <- dat[[i]][order(dat[[i]]$Variable),]
          dat[[i]] <- dat[[i]][,4]
        }
        
        dat3[[j]] <- do.call("cbind", dat)
        colnames(dat3[[j]]) <- names
        rownames(dat3[[j]]) <- sort(dat2)
        colnames3[[j]] <- names
        rownames3[[j]] <- sort(dat2)
      }
      rownames3 <- Reduce(union, rownames3)
      dat2 <- list()
      col_anno <- list()
      col_anno2 <- list()
      
      for(j in 1:length(input$WithVariable)){
        correlations1 <- correlations[which(correlations$With %in% input$WithVariable[j]),]
        dat <- list()
        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat[[i]] <- dat[[i]][which(dat[[i]]$Variable %in% rownames3),]
          dat[[i]] <- dat[[i]][order(dat[[i]]$Variable),]
          dat[[i]] <- dat[[i]][,4]
          col_anno[[i]] <- input$WithVariable[j]
        }
        
        col_anno2[[j]] <- unlist(col_anno)
        dat2[[j]] <- do.call("cbind",dat)
        rownames(dat2[[j]]) <- sort(rownames3)
        colnames(dat2[[j]]) <- names
      }
      dat <- do.call("cbind", dat2)
      col_anno <- as.data.frame(unlist(col_anno2))
      colnames(col_anno)[1] <- paste(values$x.var[which(values$corr.names == input$TypeVariable1)], "variable", sep = " ")
      if(input$var_switch){
        colnames(col_anno)[1] <- paste(values$y.var[which(values$corr.names == input$TypeVariable1)], "variable", sep = " ")
      }
      z <- list(col_anno = col_anno, dat = dat)
    }
    
    return(z)
  })
  
  output$download_heatmap_data <- downloadHandler(
    filename = function() {paste(values$project.name, "_", "Correlation_heatmap_data.csv",sep = "")},
    content = function(file) {
      write.csv(heatmap.data()$dat, file, row.names = TRUE)
    }
  )
  
  row_clust.corr <- reactive({
    if(input$rowclustcorr == TRUE){return(TRUE)}
    else{
      return(NA)
    }
  })
  
  col_clust.corr <- reactive({
    if(input$colclustcorr == TRUE){return(TRUE)}
    else{
      return(NA)
    }
  })
  
  height1 <- function(){
    input$PlotHeight4
  }
  
  width1 <- function(){
    input$PlotWidth4
  }
  
  rows.plot <- reactive({
    if(nrow(heatmap.data()$dat) > 300){return(NA)}
    else{return(NULL)}
  })
  
  color.heatmap <- reactive({
    color_palette <- colorRampPalette(c("blue", "white", "red"))(1000)
    color_palette[c(495:505)] = "#FFFFFF"
    color_palette
  })
  
  plotresolution.corr <- reactive({
    input$PlotRes4
  })
  
  output$correlations_plotOverview <- renderPlot({
    if(ncol(heatmap.data()$dat) > 1){
      if(input$colorRange){
        return(aheatmap2(heatmap.data()$dat,Colv = col_clust.corr(),annCol = heatmap.data()$col_anno,labRow = rows.plot(),treeheight = input$corrTreeHeight, fontsize = input$corrFontSize, annheight = input$corrLegendSize, 
                         color = color.heatmap(), border_color = "grey60", Rowv = row_clust.corr(), breaks = seq(-1,1,by=.04)))
      }
      return(aheatmap2(heatmap.data()$dat,Colv = col_clust.corr(),annCol = heatmap.data()$col_anno,labRow = rows.plot(),treeheight = input$corrTreeHeight, fontsize = input$corrFontSize, color = color.heatmap(), 
                       annheight = input$corrLegendSize,border_color = "grey60", Rowv = row_clust.corr(), breaks = 0))
    }
    else{
      if(input$colorRange){
        return(aheatmap2(heatmap.data()$dat,Colv = col_clust.corr(),labRow = rows.plot(), treeheight = input$corrTreeHeight, fontsize = input$corrFontSize, color = color.heatmap(), border_color = "grey60", 
                         annheight = input$corrLegendSize,Rowv = row_clust.corr(), breaks = seq(-1,1,by=.04)))
      }
      return(aheatmap2(heatmap.data()$dat,Colv = col_clust.corr(),labRow = rows.plot(),treeheight = input$corrTreeHeight, fontsize = input$corrFontSize, color = color.heatmap(), border_color = "grey60", 
                       annheight = input$corrLegendSize,Rowv = row_clust.corr(), breaks = c(-1,0,1)))
    }
  }, height = height1, width = width1)
  
  output$download_corr_heatmap <- downloadHandler(
    filename = function() {paste(values$project.name,"_","Heatmap.png",sep = "")},
    content = function(file){
      png(file, width = (plotresolution.corr()/72)*width1(), height = (plotresolution.corr()/72)*height1(), res = plotresolution.corr())
      if(input$colorRange){
        print(aheatmap2(heatmap.data()$dat,Colv = col_clust.corr(),annCol = heatmap.data()$col_anno,labRow = rows.plot(),treeheight = input$corrTreeHeight, fontsize = input$corrFontSize, annheight = input$corrLegendSize, 
                        color = color.heatmap(), border_color = "grey60", Rowv = row_clust.corr(), breaks = seq(-1,1,by=.04)))
      } else{
        print(aheatmap2(heatmap.data()$dat,Colv = col_clust.corr(),annCol = heatmap.data()$col_anno,labRow = rows.plot(),treeheight = input$corrTreeHeight, fontsize = input$corrFontSize, color = color.heatmap(), 
                        annheight = input$corrLegendSize,border_color = "grey60", Rowv = row_clust.corr(), breaks = 0))
      }
      dev.off()
    }
  )
  
  output$Visit <- renderUI({
    
    correlations <- values$corrs[[which(values$corr.names == input$TypeVariable3)]]
    if(input$var_switch2 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    visit.name = colnames(correlations)[3]
    visit <- unique(correlations[,3])
    visit <- gtools::mixedsort(as.character(visit))
    selectInput("visit", paste("Correlations by"," ",visit.name, ":", sep = ""), choices = visit, selected = visit[1])
  })
  
  sub.dat <- reactive({
    correlations <- corrResultsOverview()$correlations[[which(values$corr.names == input$TypeVariable3)]]
    if(input$var_switch2){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    correlations <- correlations[which(correlations$With == input$WithVariable3),]
    correlations <- correlations[which(correlations[,3] == input$visit),]
    z <- list(correlations = correlations)
    return(z)
  })
  
  subset_correlations <- reactive({
    correlations <- sub.dat()$correlations
    
    if(input$corrval == TRUE){
      if(input$corrsign == "+"){
        correlations <- correlations[which(correlations[,4] >= input$corrval1),]
      }
      if(input$corrsign == "-"){
        correlations <- correlations[which(correlations[,4] <= -input$corrval1),]
      }
      if(input$corrsign == "Both"){
        correlations <- correlations[c(which(correlations[,4] <= -input$corrval1), which(correlations[,4] >= input$corrval1)),]
      }
    }
    
    if(input$correction_method.corr2 == "Raw"){
      correlations <- correlations[which(correlations$Raw.P.Value <= input$Alpha),]
    }
    
    if(input$correction_method.corr2 == "FDR"){
      correlations <- correlations[which(correlations$FDR <= input$Alpha),]
    }
    
    if(input$correction_method.corr2 == "Bonferroni"){
      correlations <- correlations[which(correlations$Bonf <= input$Alpha),]
    }
    
    correlations <- correlations[,-c(which(colnames(correlations) == "Base_subtracted"), which(colnames(correlations) == "NObs"),
                                     which(colnames(correlations) == "Sign_NegLog10_p"))]
    colnames(correlations)[1] <- values$y.var[which(values$corr.names == input$TypeVariable3)]
    colnames(correlations)[2] <- values$x.var[which(values$corr.names == input$TypeVariable3)]
    if(input$var_switch2){
      colnames(correlations)[1] <- values$x.var[which(values$corr.names == input$TypeVariable3)]
      colnames(correlations)[2] <- values$y.var[which(values$corr.names == input$TypeVariable3)]
    }
    return(correlations)
  })
  
  output$download_data <- downloadHandler(
    filename = function() {paste(values$project.name, "_", "Correlations_subset.csv")},
    content = function(file) {
      write.csv(subset_correlations(), file, row.names = FALSE)
    }
  )
  
  output$var_switch2 <- renderUI({
    checkboxInput("var_switch2", strong(paste("Swap ",values$y.var[which(values$corr.names == input$TypeVariable3)], " and ", values$x.var[which(values$corr.names == input$TypeVariable3)], " columns", sep = "")),
                  value = FALSE)
  })
  
  output$correlation_table <- renderDataTable({
    subset_correlations()
  })
  
  output$Visit2 <- renderUI({
    correlations <- values$corrs[[which(values$corr.names == input$TypeVariable5)]]
    if(input$var_switch3 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    visit.name = colnames(correlations)[3]
    visit <- unique(correlations[,3])
    visit <- gtools::mixedsort(as.character(visit))
    selectInput("visit2", paste("Correlations by", visit.name, ":", sep = " "), choices = visit, selected = visit[1])
  })
  
  output$subsetcorr2 <- renderUI({
    correlations <- values$corrs[[which(values$corr.names == input$TypeVariable5)]]
    if(input$var_switch3 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    var <- as.character(sort(unique(correlations$With)))
    selectInput("subsetcorr3", paste("Subset by 'with' variable:",sep = ""), choices = var, selected = var[1:5], multiple = TRUE)
  })
  
  correlation.data <- reactive({
    #correlations <- values$corrs[[which(values$corr.names == input$TypeVariable5)]]
    correlations <- corrResultsOverview()$correlations[[which(values$corr.names == input$TypeVariable5)]]
    if(input$var_switch3 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    correlations <- correlations[which(correlations[,3] == input$visit2),]
    
    if(input$subsetModcorr2 == TRUE){
      correlations <- correlations[which(correlations$With %in% input$subsetcorr3),]
    }
    
    if(input$var_switch3 == TRUE){
      y <- values$x.var[which(values$corr.names == input$TypeVariable5)]
      x <- values$y.var[which(values$corr.names == input$TypeVariable5)]
    }
    else{
      y <- values$y.var[which(values$corr.names == input$TypeVariable5)]
      x <- values$x.var[which(values$corr.names == input$TypeVariable5)]
    }
    dat <- list()
    cor_vals <- list()
    sig <- list()
    names <- as.character(unique(correlations$With))
    
    if(input$corrval4 == TRUE){
      if(input$corrsign2 == "+"){
        for(i in 1:length(names)){
          dat[[i]] <- correlations[which(correlations$With == names[i]),]
          cor_vals[[i]] <- dat[[i]][which(dat[[i]][,4] >= input$corrval5),]
          cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
        }
      }
      if(input$corrsign2 == "-"){
        for(i in 1:length(names)){
          dat[[i]] <- correlations[which(correlations$With == names[i]),]
          cor_vals[[i]] <- dat[[i]][which(dat[[i]][,4] <= -input$corrval5),]
          cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
        }
      }
      if(input$corrsign2 == "Both"){
        for(i in 1:length(names)){
          dat[[i]] <- correlations[which(correlations$With == names[i]),]
          cor_vals[[i]] <- dat[[i]][c(which(dat[[i]][,4] <= -input$corrval5),which(dat[[i]][,4] >= input$corrval5)),]
          cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
        }
      }
      
      cor_vals <- Reduce(union,cor_vals)
      correlations <- correlations[which(correlations$Variable %in% cor_vals),]
    }
    
    
    for(i in 1:length(names)){
      dat[[i]] <- correlations[which(correlations$With == names[i]),]
      if(input$correction_method.corr3 == "Raw"){
        sig[[i]] <- dat[[i]][which(dat[[i]]$Raw.P.Value <= input$Alpha2),]
      }
      if(input$correction_method.corr3 == "FDR"){
        sig[[i]] <- dat[[i]][which(dat[[i]]$FDR <= input$Alpha2),]
      }
      if(input$correction_method.corr3 == "Bonferroni"){
        sig[[i]] <- dat[[i]][which(dat[[i]]$Bonf <= input$Alpha2),]
      }
      sig[[i]] <- as.character(sig[[i]]$Variable)
    }
    
    sigvars <- Reduce(union,sig)
    
    correlations <- correlations[which(correlations$Variable %in% sigvars),]
    
    correlation.type <- colnames(correlations)[4]
    
    if(input$uploadmod2 == TRUE){
      modnames.corr <- read.csv(input$modselect2$datapath, header = TRUE)
      modnames.corr <- as.character(modnames.corr[,1])
      modnames.corr <- gsub(".", "_", modnames.corr,fixed = TRUE)
      correlations <- correlations[which(correlations$Variable %in% modnames.corr),]
    }
    
    n = length(unique(correlations$With))
    cor <- list()
    cor_sub <- list()
    names <- unique(correlations$With)
    
    for(i in 1:n){
      cor[[i]] <- correlations[which(correlations$With == names[i]),]
      
      if(i > 1){
        cor[[i]] <- cor[[i]][match(cor[[i-1]]$Variable, cor[[i]]$Variable, nomatch = 0),]
      }
      
      if(input$correction_method.corr3 == "Raw"){
        cor_sub[[i]] <- cor[[i]][,which(colnames(cor[[i]]) %in% c(correlation.type, "Raw.P.Value"))]
      }
      if(input$correction_method.corr3 == "FDR"){
        cor_sub[[i]] <- cor[[i]][,which(colnames(cor[[i]]) %in% c(correlation.type, "FDR"))]
      }
      if(input$correction_method.corr3 == "Bonferroni"){
        cor_sub[[i]] <- cor[[i]][,which(colnames(cor[[i]]) %in% c(correlation.type, "Bonf"))]
      }
      colnames(cor_sub[[i]]) <- c(paste(names[i], "r.val", sep = "."), paste(names[i], "pVal", sep = "."))
    }
    
    mat1 <- do.call("cbind", cor_sub)
    mat1 <- as.matrix(mat1)
    rownames(mat1) <- cor[[1]]$Variable
    mat1 <- as.data.frame(mat1)
    
    t = mat1 #mat1 is what you created with the correlation script.
    t$modName<-rownames(t)
    t.pval=reshape2::melt(t[c(length(t),grep("pVal",colnames(t), fixed = TRUE))]) #combine all columns with "pVal" into one loooooong object.
    t.rval=reshape2::melt(t[c(length(t),grep("r.val",colnames(t), fixed = TRUE))]) #combine all columns with "r.val" into one loooooong object.
    GraphFrame=cbind(t.pval,t.rval[,3])  #concaternate them into one matrix
    if(input$correction_method.corr3 == "Raw"){
      colnames(GraphFrame)=c(y,"Correlation","Raw.pVal","rVal")  #change column names
    }
    if(input$correction_method.corr3 == "FDR"){
      colnames(GraphFrame)=c(y,"Correlation","FDR.pVal","rVal")  #change column names
    }
    if(input$correction_method.corr3 == "Bonferroni"){
      colnames(GraphFrame)=c(y,"Correlation","Bonf.pVal","rVal")  #change column names
    }
    
    GraphFrame[,which(colnames(GraphFrame) == y)] = factor(GraphFrame[,which(colnames(GraphFrame) == y)],levels=unique(GraphFrame[,which(colnames(GraphFrame) == y)],order=T))  #this is super important as it makes sure the order on the axis is correct!
    GraphFrame$Correlation <- gsub(".pVal", "",GraphFrame$Correlation, fixed = TRUE)
    z <- list(GraphFrame = GraphFrame, y = y, x = x)
    return(z)
  })
  
  output$download_plot_data <- downloadHandler(
    filename = function() {paste(values$project.name, "_", "correlations_data.csv")},
    content = function(file) {
      write.csv(correlation.data()$GraphFrame, file, row.names = FALSE)
    }
  )
  
  height <- function(){
    input$PlotHeight3
  }
  
  width <- function(){
    input$PlotWidth3
  }
  
  plotresolution.corr1 <- reactive({
    input$PlotRes3
  })
  
  
  correlations_makePlot <- reactive({
    y <- correlation.data()$y
    x <- correlation.data()$x
    GraphFrame <- correlation.data()$GraphFrame
    if(input$correction_method.corr3 == "Raw"){
      GraphFrame <- GraphFrame[which(GraphFrame$Raw.pVal <= input$Alpha2),]
      p <- GraphFrame$Raw.pVal
    }
    if(input$correction_method.corr3 == "FDR"){
      GraphFrame <- GraphFrame[which(GraphFrame$FDR.pVal <= input$Alpha2),]
      p <- GraphFrame$FDR.pVal
    }
    if(input$correction_method.corr3 == "Bonferroni"){
      GraphFrame <- GraphFrame[which(GraphFrame$Bonf.pVal <= input$Alpha2),]
      p <- GraphFrame$Bonf.pVal
    }
    p[p < .0001] <- .0001 #set log-10 transformed p-values <4 (=0.0001) to 4
    p[p > .1] <- .1
    RV <- ifelse(GraphFrame$rVal>0,GraphFrame$rVal^4,(GraphFrame$rVal^4)*-1)
    
    if(length(p)/length(unique(GraphFrame$Correlation)) <= 260){
      if(input$Alpha2 > .05 & input$Alpha2 <= .075){
        graph <- ggplot(data = GraphFrame, aes(Correlation, GraphFrame[,1],colour=RV, size = p), environment = environment()) + labs(y = y, x = x)  + 
          scale_size_continuous("P-value",range=c(12,4),limits = c(min(p), .1), breaks = c(0.0001,0.025,0.05,0.075), labels = c(".0001", "0.025", "0.05", "0.075")) + 
          geom_point(colour="black",aes(size = p),shape=21,alpha=I(1)) + geom_point(alpha=I(.75))  + theme_minimal()  +
          theme(panel.background=element_rect(fill="white"),
                panel.grid = element_line(),panel.grid.major.y=element_blank(),
                panel.grid.major.x = element_blank(),
                axis.text.y=element_text(hjust=0),
                axis.text.x=element_text(angle=45,vjust=1,hjust=1)) +
          scale_x_discrete(expand=c(0,1))
      }
      if(input$Alpha2 > .075 & input$Alpha2 <= .1){
        graph <- ggplot(data = GraphFrame, aes(Correlation, GraphFrame[,1],colour=RV, size = p), environment = environment()) + labs(y = y, x = x)  + 
          scale_size_continuous("P-value",range=c(12,4),limits = c(min(p), .1), breaks = c(0.0001,0.025,0.05,0.075,0.1),
                                labels = c(".0001", "0.025", "0.05", "0.075","0.1")) + geom_point(colour="black",aes(size = p),shape=21,alpha=I(1)) + 
          geom_point(alpha=I(.75))  + theme_minimal()  +
          theme(panel.background=element_rect(fill="white"),
                panel.grid = element_line(),panel.grid.major.y=element_blank(),
                panel.grid.major.x = element_blank(),
                axis.text.y=element_text(hjust=0),
                axis.text.x=element_text(angle=45,vjust=1,hjust=1)) +
          scale_x_discrete(expand=c(0,1))
      }
      if(input$Alpha2 > .1){
        graph <- ggplot(data = GraphFrame, aes(Correlation, GraphFrame[,1],colour=RV, size = p), environment = environment()) + labs(y = y, x = x)  + 
          scale_size_continuous("P-value",range=c(12,4),limits = c(min(p), .1), breaks = c(0.0001,0.025,0.05,0.075,0.1),
                                labels = c(".0001", "0.025", "0.05", "0.075","> 0.1")) + geom_point(colour="black",aes(size = p),shape=21,alpha=I(1)) + 
          geom_point(alpha=I(.75))  + theme_minimal()  +
          theme(panel.background=element_rect(fill="white"),
                panel.grid = element_line(),panel.grid.major.y=element_blank(),
                panel.grid.major.x = element_blank(),
                axis.text.y=element_text(hjust=0),
                axis.text.x=element_text(angle=45,vjust=1,hjust=1)) +
          scale_x_discrete(expand=c(0,1))
      }
      if(input$Alpha2 <= .05){
        graph <- ggplot(data = GraphFrame, aes(Correlation, GraphFrame[,1],colour=RV, size = p), environment = environment()) + 
          labs(y = y, x = x)  + scale_size_continuous("P-value",range=c(12,4),limits = c(min(p), .1), breaks = c(0.0001,0.025,0.05),
                                                      labels = c(".0001","0.025", "0.05")) + geom_point(colour="black",aes(size = p),shape=21,alpha=I(1)) + 
          geom_point(alpha=I(.75))  + theme_minimal()  +
          theme(panel.background=element_rect(fill="white"),
                panel.grid = element_line(),panel.grid.major.y=element_blank(),
                panel.grid.major.x = element_blank(),
                axis.text.y=element_text(hjust=0),
                axis.text.x=element_text(angle=45,vjust=1,hjust=1)) +
          scale_x_discrete(expand=c(0,1))
      }
    }
    if(length(p)/length(unique(GraphFrame$Correlation)) > 260){
      graph <- ggplot(data = GraphFrame, aes(Correlation, GraphFrame[,1],colour=RV, size = p), environment = environment()) + labs(y = y, x = x)  + scale_size_continuous("P-value",range=c(12,4),limits = c(min(p), .06), breaks = c(round(min(p),4),round((min(p)+.05)/2,4),.05)) + geom_point(colour="black",aes(size = p),shape=21,alpha=I(1)) + geom_point(alpha=I(.75))  + theme_minimal()  +
        theme(panel.background=element_rect(fill="white"),
              panel.grid = element_line(),panel.grid.major.y=element_blank(),
              panel.grid.major.x = element_blank(),
              axis.text.y=element_blank(),
              axis.text.x=element_text(angle=45,vjust=1,hjust=1)) +
        scale_x_discrete(expand=c(0,1)) + scale_y_discrete(breaks = NULL)
    }
    if(input$bubbleColorRange){
      graph <- graph + scale_color_gradient2(paste(values$corr.method,"'s r",sep = ""),guide="colorbar",low="navy", high="red", midpoint=0, limits = c(-1,1))
    } else{
      graph <- graph + scale_color_gradient2(paste(values$corr.method,"'s r",sep = ""),guide="colorbar",low="navy", high="red", midpoint=0) 
    }
    return(graph)
  })
  
  output$correlations_plot <- renderPlot({
    correlations_makePlot()
  }, height = height, width = width)
  
  output$download_corr_plot <- downloadHandler(
    filename = function() {paste(values$project.name, "_","significant_correlations_plot.png")},
    content = function(file){
      png(file, width = (plotresolution.corr1()/72)*width(), height = (plotresolution.corr1()/72)*height(), res = plotresolution.corr1())
      print(correlations_makePlot())
      dev.off()
    }
  )
  
  output$Visit3 <- renderUI({
    correlations <- values$corrs[[which(values$corr.names == input$TypeVariable7)]]
    visit.name = colnames(correlations)[3]
    visit <- unique(correlations[,3])
    visit <- gtools::mixedsort(as.character(visit))
    selectInput("visit3", paste("Correlations by"," ",visit.name, ":", sep = ""), choices = visit, selected = visit[1])
  })
  
  
  scatter_plot <- reactive({
    correlations <- corrResultsOverview()$correlations[[which(values$corr.names == input$TypeVariable7)]]
    correlation_file <- values$corr.files[[which(values$corr.names == input$TypeVariable7)]]
    x <- correlation_file[,input$WithVariable5][which(correlation_file[,colnames(correlations)[3]] == input$visit3)]
    y <- correlation_file[,input$corr_Variable2][which(correlation_file[,colnames(correlations)[3]] == input$visit3)]
    z <- list(x = x, y = y)
    return(z)
  })
  
  scatter_width <- function(){
    input$PlotWidth5
  }
  
  scatter_height <- function(){
    input$PlotHeight5
  }
  
  plot_res5 <- reactive({
    input$PlotRes5
  })
  
  
  axis_text_size <- reactive({
    input$axis_text_size
  })
  
  axis_label_size <- reactive({
    input$axis_label_size
  })
  
  scatter_makePlot <- reactive({
    correlations <- corrResultsOverview()$correlations[[which(values$corr.names == input$TypeVariable7)]]
    if(input$log_scale == TRUE){
      dat <- data.frame(x = log2(scatter_plot()$x + 1), y = log2(scatter_plot()$y + 1))
    }
    else{
      dat <- data.frame(x = scatter_plot()$x, y = scatter_plot()$y)
    }
    pearson.r <- cor.test(dat$x, dat$y)$estimate
    p.val <- cor.test(dat$x, dat$y)$p.value
    scat.plot <-  ggplot(data = dat, aes(x = x, y = y)) + geom_point(size = input$Point_size) + theme_bw()+
      labs(x = paste(input$WithVariable5, colnames(correlations)[3], input$visit3, sep = " "), y = paste(input$corr_Variable2, colnames(correlations)[3], input$visit3, sep = " ")) +
      theme(axis.text = element_text(size = axis_text_size()), axis.title = element_text(size = axis_label_size()))
    
    if(input$plot_reg == TRUE){
      scat.plot <- scat.plot + geom_smooth(method = "lm", se = FALSE)
    }
    if(input$plot_loess == TRUE){
      if(input$plot_reg == TRUE){
        scat.plot <- scat.plot + geom_smooth(method = "lm", se = FALSE)
      }
      else{
        scat.plot <- scat.plot + geom_smooth(method = "loess", se = FALSE, span = input$span)
      }
    }
    grob <- grid::grobTree(textGrob(paste("Pearson r = ", round(pearson.r, 4),"\n P-Value = ", round(p.val, 4), sep = ""), x = .99, y=.965, just=1,
                                    gp=gpar(col="blue", fontsize=14)))
    scat.plot <- scat.plot + annotation_custom(grob)
    z <- list(scatplot = scat.plot, dat = dat)
    return(z)
  })
  
  
  output$correlations_scatter_plot <- renderPlot({
    scatter_makePlot()$scatplot
  }, width = scatter_width, height = scatter_height)
  
  
  output$download_scatter_data <- downloadHandler(
    filename = function() {correlations <- values$corrs[[which(values$corr.names == input$TypeVariable7)]]
    paste(values$project.name, "_",input$corr_Variable2, "vs", input$WithVariable5, "_", colnames(correlations)[3], input$visit3,"_data.csv")},
    content = function(file) {
      dat <- scatter_makePlot()$dat
      colnames(dat) <- c(input$WithVariable5, input$corr_Variable2)
      write.csv(dat, file, row.names = FALSE)
    }
  )
  
  output$download_scatter <- downloadHandler(
    filename = function() {correlations <- values$corrs[[which(values$corr.names == input$TypeVariable7)]]
    paste(values$project.name, "_",input$corr_Variable2, "vs", input$WithVariable5, "_", colnames(correlations)[3], input$visit3,".png")},
    content = function(file){
      png(file, width = (plot_res5()/72)*width(), height = (plot_res5()/72)*height(), res = plot_res5())
      print(scatter_makePlot()$scatplot)
      dev.off()
    }
  )
  
  ################End of Correlations Part###################

  })
