#require(shiny)
#library(ggplot2)
#library(RColorBrewer)
#library(fastcluster)
#library(NMF)
#library(grid)
#library(clValid)
#library(qusage)
#library(VennDiagram)
#library(shinydashboard)
#library(gtools)
#library(scales)
#library(reshape2)
#library(data.table)
#library(pca3d)
#library(shinyjs)
#library(stringr)
library(ggplot2)

tabs.content <- list(list(Title = "Gene Lists", Content = fluidRow(
  box(title = "Filtering Options", width = 4, status = "info", solidHeader = TRUE,
      uiOutput("Comparison1"),
      filterOptsUI("dgeResultsTable"),
      #checkboxInput("merge", "Merge module information", FALSE),
      numericInput('modmaplmmres', "Plot resolution (for downloaded plot):", min = 72, max = 400, value = 72, step = 1),
      checkboxInput("DownloadOptions", strong("Download multiple genelists at once:", style = "color:blue"), FALSE),
      conditionalPanel(condition = "input.DownloadOptions",
                       uiOutput("selectComps"),
                       textInput("ziptext", label = "Filename Input", value = "All_Comparisons_Raw.05"),
                       downloadButton('downloadSelComp', 'Download selected genelists')
      )
  ),
  box(title = "Results Table", width = 8, status = "success", solidHeader = TRUE,
      uiOutput('downloadModMap'),
      uiOutput('moduleMap'),
      helpText("Right click on hyperlinks to open in new window"),
      downloadButton('downloadData', 'Download Table'),
      dataTableOutput("genelisttable")
  )
)), list(Title = "Diagnostics", Content = fluidRow(
  box(title = "P-Value Distribution Assesment", width = 12, status = "info", solidHeader = TRUE,
      plotOutput("distplot"), plotOutput("genelistgraph"), 
      textOutput("intro"),
      dataTableOutput("numtable")
  )
)), list(Title = "Significant Variables Heatmap", Content = fluidRow(
  box(title = "Heatmap Options", width = 4, status = "info", solidHeader = TRUE,
      div(style = "display:inline-block", actionButton("go2", "Plot")),
      div(style = "display:inline-block", infoPopup("Plot", 'The heatmap will not update until the "Plot" button is clicked.
                                                    This allows the user to make multiple adjustments at once, without having to wait for 
                                                    each individual adjustment to update on the heatmap.', placement = "right", trigger = "click")),
      uiOutput("Comparison3"),
      filterOptsUI("dgeHeatmap"),
      uiOutput('test1'),
      div(style = "display:inline-block", checkboxInput("rowCluster", strong("Row Cluster"), value = FALSE)),
      div(style = "display:inline-block", infoPopup("Row Cluster", "Based on the PC performance, it might not be recommended to cluster the rows if the number of rows exceed 7000",
                                                    placement = "right", trigger = "click")),
      br(),
      maxValuesUI("dgeMaxValues"),
      br(),
      subsetAndOrderUI("dgeSubOrder"),
      br(),
      colClusterUI("dgeCluster"),
      br(),
      graphOptionsUI("dgeGraphOptions")
      ),
  box(title = "Heatmap", width = 8, status = "warning", solidHeader = TRUE,
      infoPopup("Help Message", 'The heat map below is constructed on individual samples for a number of scenarios,
                specifically for baseline samples only (cross sectional) or all samples at all time points.  For baseline samples,
                heatmaps can be generated based on normalizing the expression data to the median, or to a control group if applicable.
                When all samples at all time points are to be plotted, heatmaps can be generated by normalizing to the median,
                a control group, or each subjects own baseline value. Only samples that have a corresponding baseline sample are
                included in the map. The initial graph of the heat map may not be very appealing depending on the number of samples.
                The inputs on the left have a wide variety of user options that range from the type of normalized data, clustering rows
                and columns, subsetting samples and probes, etc. These options are consistent across all the unsupervised analysis plots.
                One addition, unique to the probe level heat map is the "Max value on color key" option that specifies the coloring legend
                for the heatmap index. The default is set to +/- 2. If the user would like the index to have the most extreme red and blue
                to be set to a value of +/- 4 then user simply needs to enter 4. The user can also enter 0 which will make the limits based
                on the max and min of the entire expression file.',
                placement = "bottom", trigger = "click"),
      helpText(""),
      downloadButton('downloadHeatmap1', 'Download Data'),
      downloadButton('downloadHeatmap2', 'Download Figure'),
      plotOutput("heatmap1")
  )
  )), list(Title = "Venn Diagram", Content =  fluidRow(
    box(title = "Options", width = 4, status = "info", solidHeader = TRUE,
        filterOptsUI("dgeVenn"),
        uiOutput("vennComparison"),
        selectInput("UorI", "Intersection or union:", c("Intersection" = 1, "Union" = 2), selected = 1),
        uiOutput("include"),
        uiOutput("exclude")
    ),
    column(width = 8,
           box(title = "Venn Diagram", width = NULL, status = "warning", solidHeader = TRUE,
               downloadButton('downloadVennPic', 'Download Figure'),
               plotOutput("vennDiagram")
           ),
           box(title = "Venn Results Table", width = NULL, status = "success", solidHeader = TRUE,
               downloadButton('downloadVennData', 'Download Data'),
               dataTableOutput("vennIntersection")
           )
    )
  )), list(Title = "Modular DGE Analysis", Content =  fluidRow(
    box(title = "Options", width = 4, status = "info", solidHeader = TRUE,
        actionButton("goModDge", "Plot"),
        br(),
        div(style = "display:inline-block", checkboxInput(inputId = "compSelect", label = strong("Comparison(s) selection:", style = "color:blue"), value = FALSE)),
        div(style = "display:inline-block", helpPopup("Comparison(s) selection", "This option allows the user to select specific comparisons of interest")),
        conditionalPanel(condition = "input.compSelect == true",
                         uiOutput("Comparison2")),
        uiOutput("dgeModSelection"),
        br(),
        div(style = "display:inline-block", checkboxInput("uploadModules", strong("Upload modules", style = "color:blue"), FALSE)),
        div(style = "display:inline-block", infoPopup("Upload modules", "Allows the user to provide their own list of modules (CSV) to plot. The CSV file should contain a single column named 'PROBE_ID' or 'SYMBOL', 
                                                      depending on whether the list provided is the PROBE ID's or gene symbols.", placement = "right", trigger = "click")),
        conditionalPanel(condition = "input.uploadModules",
                         fileInput('modSelect', '', multiple = FALSE, accept=c(".csv"))
        ),
        filterOptsUI("modDgeMap"),
        br(),
        div(style = "display:inline-block", checkboxInput("LMMdeleterows", "Delete all zero rows", FALSE)),
        div(style = "display:inline-block", infoPopup("Delete all zero rows", 'Rows with all zeros (all white rows) will be deleted from the heat map.',
                                                      placement = "right", trigger = "click")),
        br(),
        checkboxInput("modDgeCluster", "Cluster rows", FALSE),
        checkboxInput("colCluster","Cluster columns", FALSE),
        br(),
        graphOptionsUI("modDgeGraphOptions", varType = "modules")
        ),
    box(title = "Module DGE Heatmap", width = 8, status = "warning", solidHeader = TRUE,
        downloadButton('downloadModDgeData', 'Download Data'),
        downloadButton('downloadModDgeMap', 'Download Figure'),
        plotOutput("modDgeMap")
    )
  )))

#Increase maximum file size input; currently set to 1GB -- Not sure if we need more.
options(shiny.maxRequestSize=1000*1024^2)
shinyServer(function(input,output, session){

  setBookmarkExclude(c("file1"))
  output$test<-renderUI({
    if(is.null(values$h3_rowdendro)){
      if(values$hc ==TRUE){
        try<-list("All Samples Median Normalized" = 3,
                  "All Samples Healthy Normalized" = 4,
                  "Non-Healthy Samples Median Normalized" = 6)
      }

      if(values$hc == FALSE){
        try<-list("All Samples Median Normalized" = 3)
      }
    }

    if(!is.null(values$h3_rowdendro)){
      if(values$hc == TRUE){
        try<-list("Baseline Median Normalized" = 1,
                  "Baseline Healthy Normalized" = 2,
                  "All Samples Median Normalized" = 3,
                  "All Samples Healthy Normalized"= 4,
                  "All Samples Baseline Normalized"=5)
      }

      if(values$hc == FALSE){
        try<-list("Baseline Median Normalized" = 1,
                  "All Samples Median Normalized" = 3,
                  "All Samples Baseline Normalized"=5)
      }
    }
    selectInput("set", "Select heatmap:",as.list(try))
  })

  dir.projects <- reactive({
    "C:/Users/e89628/Documents/Intern/BartDownloadFilesForTesting/BART"
  })

  list.projects <- reactive({
    list.files(dir.projects())
  })

  get.wd <- eventReactive(input$uploadserver,{return(getwd())})


  fileindex<-reactive({
    index1<-c()
    index1[1]<-which(input$file1$name == "pvca1.png")
    index1[2]<-which(input$file1$name == "pvca2.png")
    index1[3]<-which(input$file1$name == "Unsupervised.Rdata")
    index1
  })

  values <- reactiveValues()

  updateData <- function(path, route){
    vars <- load(file = path, envir = .GlobalEnv)
    values$sample_id <- NULL
    values$responder_var <- NULL
    values$final_expression <- NULL
    values$qusage_results <- NULL
    values$flow_data <- NULL
    values$results_file <- NULL
    values$mod1 <- NULL
    values$mod2 <- NULL
    values$illumina <- NULL
    values$moduleinfo2 <- NULL
    values$correlations <- NULL
    values$ModulesTF <- NULL
    values$baylorMod <- TRUE
    values$BaylorTF <- NULL
    values$base_ctrl <- NULL
    values$long_ctrl <- NULL
    values$long_base <- NULL
    values$roast_results <- NULL
    values$numbGenes <- NULL
    values$PaloValue <- NULL
    values$quantileValue <- NULL
    values$SDcutoff <- NULL
    values$Approx_num_probes <- NULL
    values$Filter_text <- NULL
    values$BatchCorrectionTF <- NULL
    values$Batch_Variable <- NULL
    values$Batch_text <- NULL
    values$MixedModelDescription <- NULL
    setwd(route)

    for (var in vars){
      values[[var]] <- get(var, .GlobalEnv)
    }
    return(values)
  }

  observe({
    if(is.null(input$file1)) return(NULL)
    mypath<-input$file1[[fileindex()[3], 'datapath']]
    updateData(mypath, tempdir())
  })

  output$versionbox <- renderValueBox({
    valueBox(
      paste0("Software Version: BETA \nRelease Date: TBD"), version$version.string, icon = icon("th-list"),
      color = "purple"
    )
  })

  output$version <- renderPrint({
    writeLines("Software Version: BETA \nRelease Date: TBD")
    writeLines(version$version.string)
  })

  output$path <- renderText({
    path <- values$project_name
    path
  })


  ############ Design File and Summary Statistics ##############################

  output$SumStat <- renderMenu({
    if(is.null(values$design)){
      return(strong(""))
    }
    if(is.null(values$design) == FALSE){
      if(length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) == 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("PVCA", tabName = "pvca")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("PVCA", tabName = "pvca"),
                        menuSubItem("Fast QC Report", tabName = "fastqc")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) > 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("PVCA", tabName = "pvca"),
                        menuSubItem("QC files upload", tabName = "qcupload")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("Fast QC Report", tabName = "fastqc")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) > 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("QC files upload", tabName = "qcupload")))
      }
      if(length(which(input$file1$name %in% grep(".png", input$file1$name, value = TRUE, fixed = TRUE))) == 0 &
         length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) > 0 &
         length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) > 0){
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("Fast QC Report", tabName = "fastqc"),
                        menuSubItem("QC files upload", tabName = "qcupload")))
      }
      else{
        return(menuItem("Summary Stats and QC", icon = icon("table"), tabName = "summarystats",
                        menuSubItem("Design file", tabName = "design"),
                        menuSubItem("Summary Statistics", tabName = "summary"),
                        menuSubItem("PVCA", tabName = "pvca"),
                        menuSubItem("Fast QC Report", tabName = "fastqc"),
                        menuSubItem("QC files upload", tabName = "qcupload")))
      }
    }
  })


  output$designDataTable<- renderDataTable({
    values$design
  })

  output$downloadDesign <- downloadHandler(

    filename = function() {paste(values$project_name,'_Design','.csv', sep='')  },
    content = function(file) {
      write.csv(values$design, file, row.names = FALSE)
    }
  )

  output$downloadSummary0 <- downloadHandler(

    filename = function() {'SummaryStats_Table1.csv'},
    content = function(file) {
      write.csv(table_0(), file, row.names = FALSE)
    }
  )

  output$downloadSummary1 <- downloadHandler(

    filename = function() {'SummaryStats_Table2.csv'},
    content = function(file){
      write.csv(table_1(), file,row.names = FALSE)
    }
  )

  output$downloadSummary2 <- downloadHandler(

    filename = function() {'SummaryStats_Table3.csv'},
    content = function(file) {
      write.csv(table_2(), file,row.names = FALSE)
    }
  )

  output$summaryName<-renderUI({
    selectInput("summary_var", "Variable for summary statistics:", names(values$design),selected=values$summary_var)
  })

  output$timeVar<-renderUI({
    selectInput("time_var", "Time variable:*", values$time_var,selected=values$time_var)
  })

  output$respVar<-renderUI({
    selectInput("responder_var", "By variable (i.e. responder status):", names(values$design),selected=values$responder_var)
  })

  output$patientVar<-renderUI({
    selectInput("patient_id", "Patient ID variable:*", values$patient_id,selected=values$patient_id)
  })

  output$summary0Text<-renderUI({
    HTML(paste(strong("Table 1:"), "Summary statistics by", input$responder_var, "for",input$summary_var,sep=" "))
  })

  output$summary1Text<-renderUI({
    HTML(paste(strong("Table 2: "), "Summary statistics by Time and", input$responder_var, "for",input$summary_var,sep=" "))
  })

  output$summary2Text <- renderUI({
    HTML(paste(strong("Table 3: "), "Frequency of Longitudinal Profiles by", input$responder_var, sep = " "))
  })

  data_unique <- reactive({
    values$design[!duplicated(values$design[, values$patient_id]), ]
  })

  table0_cont <- reactive({
    sum0 <- aggregate(as.formula(paste(input$summary_var, "~", values$patient_id)), data = values$design, sd)
    sum0 <- as.data.frame(sum0)
    if(sum(sum0[[2]], na.rm = T) == 0){
      mysummary<-function(x){y<-c(length(x),mean(x),median(x),sd(x),min(x),max(x))
      names(y)<-c("N","Mean","Median","Sd","Min.","Max.")
      return(y)}

      sum1<-aggregate(as.formula(paste(input$summary_var,"~",input$responder_var)), data= data_unique(), mysummary)
      summaries<- as.data.frame(sum1[,2])
      result<-as.data.frame(cbind(sum1[,c(1)],summaries))
      names(result)<-c("Responder Status",colnames(summaries))
      result
    }
    else{
      result <- data.frame(Warning = "Variable is time dependent. Look at table below.")
    }
  })

  table0_cat <- reactive({
    sum0 <- aggregate(as.formula(paste(input$summary_var, "~", values$patient_id)), data = values$design, summary)
    sum01 <- sum0[,2]
    sum01[sum01 > 0] <- 1
    sums <- apply(sum01, 1, sum)
    check <- F
    if(all(sums == 1)) {check <- T}

    if(check == T){

      mysummary<-function(x){y<-summary(x)
      y<-c(length(x),y)
      names(y)<-c("N", names(summary(x)))
      return(y)}

      sum1<-aggregate(as.formula(paste(input$summary_var,"~",input$responder_var)), data = data_unique(), mysummary)
      summaries<- as.data.frame(sum1[,2])
      summaries2 = list()
      for(i in 1:nrow(summaries[,-1])){
        summaries2[[i]] = paste(summaries[i,-1], " ", "(", round(100*(summaries[i,-1]/summaries[i,1]), 2), "%",")", sep = "")
      }

      summaries2 = do.call("rbind", summaries2)

      result<- cbind(as.data.frame(sum1[,1]),summaries[,1], summaries2)
      names(result)<-c("Responder Status", "N", names(summaries[,-1]))
      result
    }

    else{
      result <- data.frame(Warning = "Variable is time dependent. Look at table below.")
    }
  })

  table_0 <- reactive({
    if(is.numeric(values$design[[input$summary_var]])){
      table0_cont()
    }

    else{
      table0_cat()
    }
  })

  table_1 <- reactive({
    if(is.numeric(values$design[[input$summary_var]])){
      mysummary<-function(x){y <- c(length(x), mean(x), median(x), sd(x), min(x), max(x))
      names(y)<-c("N", "Mean", "Median", "Sd", "Min.","Max.")
      return(y)}
      sum1<-aggregate(as.formula(paste(input$summary_var,"~",values$time_var,"+",input$responder_var)), data = values$design, mysummary)
      summaries<- as.data.frame(sum1[,3])

      result<- data.frame(cbind(sum1[,c(1,2)],summaries))
      names(result)<-c("Time","Responder Status",colnames(summaries))
      result
    }

    else{
      mysummary<-function(x){y<-summary(x)
      y<-c(length(x),y)
      names(y)<-c("N",names(summary(x)))
      return(y)}
      sum1<-aggregate(as.formula(paste(input$summary_var,"~",values$time_var,"+",input$responder_var)), data= values$design, mysummary)
      summaries<- as.data.frame(sum1[,3])
      result<- data.frame(cbind(sum1[,c(1,2)],summaries))
      names(result)<-c("Time","Responder Status",colnames(summaries))
      result
    }
  })

  table_2 <- reactive({
    x<-values$design
    names(x)[which(names(x)==values$time_var)]<-"Time"
    names(x)[which(names(x)==input$responder_var)]<-"Responder"
    names(x)[which(names(x)==values$patient_id)]<-"PATIENT_ID"

    timelevel<-unique(x$Time[order(x$Time)])
    x$Time2<-factor(x$Time,levels=timelevel)
    freqs<-aggregate(Time2~PATIENT_ID,data=x,table)

    y<-unlist(apply(as.matrix(freqs[,-1]),1,function(x){paste(timelevel[which(x>0)],collapse=",")}))

    newx<-data.frame(freqs[,1],y)
    names(newx)<-c("PATIENT_ID","course")

    dum<-c()
    for(i in 1:dim(newx)[1]){
      dum[i]<-which(x$PATIENT_ID==newx$PATIENT_ID[i])[1]}
    n1<-names(newx)
    n2<-"Responder"
    newx<-data.frame(newx,x$Responder[dum])
    names(newx)<-c(n1,n2)
    z<-aggregate(Responder~course,data=newx,table)

    if(length(z[,2]) == 1){
      z2<- as.data.frame(z[,2,drop = F])
    }

    if(length(z[,2]) > 1){
      z2 <- as.data.frame(z[,2])
    }

    z[,1] <- as.character(z[,1])
    sum_cols <- colSums(z2)
    result <- rbind(data.frame(z[,1], stringsAsFactors = F), "Total")

    if(length(z[,2] == 1)){
      result2 <- rbind(data.frame(z[,2,drop = F]), sum_cols)
    }

    if(length(z[,2]) > 1){
      result2 <- rbind(data.frame(z[,2]), sum_cols)
    }

    result3<- data.frame(cbind(result,result2))
    names(result3)<-c("Time Course",colnames(z2))
    result3$Total <- rowSums(result3[,-1])
    result3
  })

  dig <- function(){
    as.numeric(input$digits)
  }
  
  output$summary0 <- renderTable({
    table_0()
  }, digits = dig, include.rownames = FALSE)
  
  output$summary1 <- renderTable({
    table_1()
  }, digits = dig, include.rownames = FALSE)
  
  output$summary2 <- renderTable({
    table_2()
  }, digits = dig, include.rownames = FALSE)


  ################# PVCA ##################################

  output$PVCA1 <- renderImage({
    if (is.null(input$file1)){return(NULL)}
    if(is.na(fileindex()[1]) == TRUE){
      filename <- 'datapath'
    }
    else{
      filename<-input$file1[[fileindex()[1], 'datapath']]
    }

    # Return a list containing the filename and alt text
    list(src = filename,
         alt = "Principle Component 3D PLOT",
         height=300,
         width=700)

  }, deleteFile = FALSE)

  output$PVCA2 <- renderImage({
    if (is.null(input$file1)){return(NULL)}
    if(is.na(fileindex()[2]) == TRUE){
      filename <- 'datapath'
    }
    else{
      filename<-input$file1[[fileindex()[2], 'datapath']]
    }

    # Return a list containing the filename and alt text
    list(src = filename,
         alt = "PVCA Summary")

  }, deleteFile = FALSE)


  ######################### QC Metrics ################################
  output$qc_select <- renderUI(
    if(length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) < 1){
      return(NULL)
    }
    else{
      qcnames <- grep(".html", input$file1$name, value = TRUE, fixed = TRUE)
      if(length(qcnames) > 1){
        names <- c()
        for(i in 1:length(qcnames)){
          names[i] <- sub("_S.*", "", qcnames[i])
        }
        selectInput("fqc_samples", "Select sample:", names)
      }
    }
  )

  output$qc_select2 <- renderUI(
    if(length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      qcnames <- grep(".html", input$file1$name, value = TRUE, fixed = TRUE)
      if(length(qcnames) > 1){
        selectInput("fqc_read", "Select read:", c("R1", "R2"))
      }
    }
  )

  output$fqc <- renderUI(
    if(length(which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      qcnames <- grep(".html", input$file1$name, value = TRUE, fixed = TRUE)
      index <- which(input$file1$name %in% grep(".html", input$file1$name, value = TRUE, fixed = TRUE))
      if(length(qcnames) == 1){
        return(includeHTML(input$file1$datapath[index]))
      }
      if(length(qcnames) > 1){
        names <- c()
        check <- c()
        for(i in 1:length(qcnames)){
          names[i] <- sub("_S.*", "", qcnames[i])
        }
        for(i in 1:length(qcnames)){
          check[i] <- grepl(input$fqc_read, qcnames[i], fixed = TRUE) & grepl(input$fqc_samples, qcnames[i], fixed = TRUE)
        }
        return(includeHTML(input$file1$datapath[index][check]))
      }
    }
  )


  output$dropdown <- renderUI(
    if(length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      qcnames <- grep(".csv", input$file1$name, value = TRUE, fixed = TRUE)
      index <- which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))
      selectInput("qcTab", "Select QC table:", qcnames)
    }
  )

  output$dropdowncolumns <- renderUI(
    if(length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      qctab <- read.csv(input$file1$datapath[which(input$file1$name == input$qcTab)], header = TRUE)
      numeric <- sapply(qctab, is.numeric)
      qctab <- qctab[,numeric]
      selectInput("qcCols", "Select metrics to plot:", colnames(qctab))
    }
  )

  output$QCbox <- renderUI(
    if(length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      return(plotOutput("qcbox"))
    }
  )

  output$coordflip <- renderUI(
    if(length(which(input$file1$name %in% grep(".csv", input$file1$name, value = TRUE, fixed = TRUE))) == 0){return(NULL)}
    else{
      checkboxInput("coord_flip", "Flip coordinates", FALSE)
    }
  )

  qc.width <- function(){
    input$qcplotsizew
  }

  qc.height <- function(){
    input$qcplotsizeh
  }

  axis_label_size_qc <- reactive({
    input$axis_label_sizeqc
  })

  axis_text_size_qc <- reactive({
    input$axis_text_sizeqc
  })

  output$qcbox <- renderPlot({
    qctab <- read.csv(input$file1$datapath[which(input$file1$name == input$qcTab)], header = TRUE)
    qcplot <- ggplot(data = qctab[,c(1,which(colnames(qctab) %in% input$qcCols))], aes(x = X)) + geom_bar(aes_string(weight = input$qcCols), fill="blue4")
    qcplot <- qcplot + theme(axis.text.x = element_text(hjust = 1, angle = 90), axis.text = element_text(size = axis_text_size_qc()),
                             axis.title = element_text(size = axis_label_size_qc())) + xlab("Samples") + ylab(input$qcCols)
    if(input$coord_flip){
      qcplot <- qcplot + coord_flip()
      qcplot
    }
    else{
      qcplot
    }
  }, height = qc.height, width = qc.width)

  output$downloadQC <- downloadHandler(

    filename = function() {paste("QC_Plot_",input$qcCols, ".png", sep = "")},
    content = function(file) {
      png(file, width = input$qcplotsizew, height = input$qcplotsizeh)
      qctab <- read.csv(input$file1$datapath[which(input$file1$name == input$qcTab)], header = TRUE)
      qcplot <- ggplot(data = qctab[,c(1,which(colnames(qctab) %in% input$qcCols))], aes(x = X)) + geom_bar(aes_string(weight = input$qcCols), fill="blue4")
      qcplot <- qcplot + theme(axis.text.x = element_text(hjust = 1, angle = 90), axis.text = element_text(size = axis_text_size_qc()),
                               axis.title = element_text(size = axis_label_size_qc())) + xlab("Samples") + ylab(input$qcCols)
      if(input$coord_flip){
        qcplot <- qcplot + coord_flip()
        print(qcplot)
      }
      else{
        print(qcplot)
      }
      dev.off()
    }
  )

  ######################### Create Module Percentage Matrices ############################

  module_matrices <- reactive({
    mod1 <- mod2 <- mod3 <- NULL
    z <- list(mod1 = mod1, mod2 = mod2, mod3 = mod3)
    return(z)
  })

  ######################### Unsupervised Side Menu ###############################

output$Unsupervised <- renderMenu({
  if(is.null(values$final_expression)){
      return(strong(""))
  }
  
  if(is.null(values$long_base) & is.null(values$long_ctrl) & is.null(values$base_ctrl)){
    return(menuItem("Unupervised Analysis", icon = icon("line-chart"), tabName = "unsupervised",
                    menuSubItem("Probe Level Heat Maps", tabName = "probeheatmap"))
    )
  }
  
  if(is.null(values$long_base) & is.null(values$long_ctrl) & !is.null(values$base_ctrl)){
    return(menuItem("Unupervised Analysis", icon = icon("line-chart"), tabName = "unsupervised",
                    menuSubItem("Probe Level Heat Maps", tabName = "probeheatmap"),
                    menuItem("Module Maps", icon = icon("angle-double-right"), tabName = "moduleMap"))
    )
  }
  
  if((!is.null(values$long_base) | !is.null(values$long_ctrl)) & is.null(values$base_ctrl)){
    return(menuItem("Unupervised Analysis", icon = icon("line-chart"), tabName = "unsupervised",
                    menuSubItem("Probe Level Heat Maps", tabName = "probeheatmap"),
                    menuItem("Module Maps", icon = icon("angle-double-right"), tabName = "moduleMap"))
    )
  }
  
  if((!is.null(values$long_base) | !is.null(values$long_ctrl)) & !is.null(values$base_ctrl)){
    return(menuItem("Unupervised Analysis", icon = icon("line-chart"), tabName = "unsupervised",
                    menuSubItem("Probe Level Heat Maps", tabName = "probeheatmap"),
                    menuItem("Module Maps", icon = icon("angle-double-right"), tabName = "moduleMap"))
    )
  }
    
  })


  #################################### Module Maps ############################
  
  output$baseOrCtrl <- renderUI({
    if(is.null(values$long_ctrl) & is.null(values$long_base) & is.null(values$base_ctrl)){return(NULL)}
    if(is.null(values$long_ctrl) & is.null(values$long_base) & !is.null(values$base_ctrl)){
      return(
        selectInput("baseOrCtrl", "Proportions With Respect to Baseline or Controls:", choices = c("With Respect to Controls"))
      )
    }
    if(!is.null(values$long_ctrl) & !is.null(values$long_base)){
      return(
        selectInput("baseOrCtrl", "Proportions With Respect to Baseline or Controls:", choices = c("With Respect to Baseline", "With Respect to Controls"), 
                    selected = "With Respect to Baseline")
      )
    } else if(!is.null(values$long_ctrl)) {
      return(
        selectInput("baseOrCtrl", "Proportions With Respect to Baseline or Controls:", choices = c("With Respect to Controls"))
      )
    } else if(!is.null(values$long_base)) {
      return(
        selectInput("baseOrCtrl", "Proportions With Respect to Baseline or Controls:", choices = c("With Respect to Baseline"))
      )
    }
  })
  
  output$modSelection <- renderUI({
    if(!values$baylorMod){return(NULL)}
    selectizeInput("moduleSelection", "Module to include:", c("All", "First Round", "First Two Rounds", "First Three Rounds", "First Four Rounds", "First Five Rounds",
                                                              "First Six Rounds", "First Seven Rounds", "First Eight Rounds"), "First Six Rounds")
  })
  
  modData <- reactive({
    if(is.null(input$baseOrCtrl)){return(NULL)}
    if(input$baseOrCtrl == "With Respect to Baseline"){
      dat <- 100*(values$long_base-1)
    } 
    if(input$baseOrCtrl == "With Respect to Controls"){
      if(!is.null(values$base_ctrl) & is.null(values$long_ctrl)){
        dat <- 100*(values$base_ctrl-1)
      } else{
        dat <- 100*(values$long_ctrl-1) 
      }
    } 
    if(values$baylorMod){
      if(input$moduleSelection == "First Round"){
        dat <- dat[1:2,]
      } else if(input$moduleSelection == "First Two Rounds"){
        dat <- dat[1:5,]
      } else if(input$moduleSelection == "First Three Rounds"){
        dat <- dat[1:11,]
      } else if(input$moduleSelection == "First Four Rounds"){
        dat <- dat[1:27,]
      } else if(input$moduleSelection == "First Five Rounds"){
        dat <- dat[1:42,]
      } else if(input$moduleSelection == "First Six Rounds"){
        dat <- dat[1:62,]
      } else if(input$moduleSelection == "First Seven Rounds"){
        dat <- dat[1:97,]
      } else if(input$moduleSelection == "First Eight Rounds"){
        dat <- dat[1:208,]
      } 
    }
    des <- values$design
    dist <- dist(dat)
    hcl <- fastcluster::hclust(dist)
    ddm <- as.dendrogram(hcl)
    Rowv <- rowMeans(dat, na.rm = TRUE)
    ddm <- reorder(ddm, Rowv)
    des <- des[match(colnames(dat), des[,values$sample_id], nomatch = 0),]
    x <- list(dat = dat, ddm = ddm, des = des)
    return(x)
  })
  
  modGraphParams <- eventReactive(input$goMod,{
    params <- callModule(graphOptions, "modGraphOptions", varType = "modules")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    circleSize <- params$circleSize
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution, 
                   circleSize = circleSize)
    return(params)
  })
  
  modWidth <- function(){modGraphParams()$width}
  modHeight <- function(){modGraphParams()$height}
  
  callModule(subsetAndOrderRenderUI, "modSubOrder", des = reactive(values$design), groupingVar = reactive(values$responder_var))
  callModule(clusterAssociationRenderUI, "modAssociation", data = reactive(values$design), groupingVar = reactive(values$responder_var))
  
  modRowCluster <- eventReactive(input$goMod,{
    dat<- callModule(uploadVarsRowCluster, "mod", data = reactive(modData()$dat), dendro = reactive(modData()$ddm))
    x <- dat$x
    ddm <- dat$ddm
    labelRows <- dat$labelRows
    y <- list(x = x, ddm = ddm, labelRows = labelRows)
    return(y)
  })
  
  modClusterData <- eventReactive(input$goMod,{
    x <- callModule(colCluster, "modCluster", des = reactive(modOrderedData()$colAnnot), data = reactive(modOrderedData()$x))
    return(x)
  })
  
  modGen_clustTab <- reactive({
    x <- callModule(clusterAssociation, "modAssociation", des = reactive(modOrderedData()$design), hclObj = reactive(modClusterData()$hcl))
    return(x)
  })
  
  modOrderedData <- eventReactive(input$goMod,{
    dat <- callModule(subsetAndOrder, "modSubOrder", des = reactive(modData()$des), data = reactive(modRowCluster()$x), 
                      sampleAnnot = reactive(values$sample_id), groupingVar = reactive(values$responder_var))
    x <- dat$dat
    colAnnot <- dat$colAnnot
    design <- dat$design
    z <- list(x = x, colAnnot = colAnnot, design = design)
    return(z)
  })
  
  modColors <- eventReactive(input$goMod,{
    x <- callModule(annColors, "modSubOrder", reactive(modOrderedData()$colAnnot))
    return(x)
  })
  
  output$modHeatmap <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(modOrderedData()$x,Rowv = modRowCluster()$ddm, Colv = modClusterData()$colddm, circle_size = modGraphParams()$circleSize, treeheight = modGraphParams()$treeHeight, fontsize = modGraphParams()$fontSize, cexRow = 1.2, 
                             annheight = modGraphParams()$legendSize,color = colorRampPalette(c("blue", "white", "red"))(100),annCol = modClusterData()$colAnnot,annColors = modColors(),
                             breaks=0)
                   #x <- heatmapr(modOrderedData()$x)
                   #heatmaply(modOrderedData()$x, node_type = "scatter")
                 }
    )
  }, width = modWidth, height = modHeight)
  
  output$downloadModPlot3Other <- downloadHandler(
    filename = function() {paste(values$project_name, '_Longitudinal_ModuleMap','.png', sep = '')},
    content = function(file){
      res <- modGraphParams()$resolution
      height <- modGraphParams()$height
      width <- modGraphParams()$width
      png(file, width = (res/72)*width, height = (res/72)*height, res = res)
      print(aheatmap2(modOrderedData()$x,Rowv = modRowCluster()$ddm, Colv = modClusterData()$colddm, circle_size = modGraphParams()$circleSize, treeheight = modGraphParams()$treeHeight, fontsize = modGraphParams()$fontSize, cexRow = 1.2, 
                      annheight = modGraphParams()$legendSize,color = colorRampPalette(c("blue", "white", "red"))(100),annCol = modClusterData()$colAnnot,annColors = modColors(),
                      breaks=0))
      dev.off()
    }
  )
  
  output$downloadModMap3Other <- downloadHandler(
    filename = function() {paste(values$project_name,'_Longitudinal_ModuleMapData','.csv', sep='')  },
    content = function(file) {
      write.csv(heatDataDownload(), file, row.names = TRUE)
    }
  )


  output$modOptimalNumber <- renderText({
    paste("Optimal number of clusters =", modClusterData()$opt_num )
  })
  
  output$modClusterPlot <- renderPlot({
    barplot(modClusterData()$d, names.arg = 2:round(nrow(modOrderedData()$colAnnot)/2), xlab = "Number of Clusters", ylab = "Dunn's Index")
  })

  output$downloadClusterPlot2Other <- downloadHandler(
    filename = function() {paste(values$project_name,'_','Cluster_Plot_Longitudinal','.png', sep = '')},
    content = function(file){
      png(file, width = 800)
      print(barplot(modClusterData()$d, names.arg = 2:round(nrow(modOrderedData()$colAnnot)/2), xlab = "Number of Clusters", ylab = "Dunn's Index"))
      dev.off()
    }
  )
  
  output$cluster_output3Other <- renderTable({
    if(is.null(modGen_clustTab())){return(NULL)}
    modGen_clustTab()$table1
  }, include.rownames = FALSE, digits = 0)
  
  output$explanation2Other <- renderText({
    if(is.null(modGen_clustTab())){return(NULL)}
    if(ncol(modGen_clustTab()$table2) > 1){
      print("The table below is the table the tests are run on. It is the same as the table above, except the columns with zero counts have been deleted.")
    }
  })
  
  output$cluster_tab2Other <- renderTable({
    if(is.null(modGen_clustTab())){return(NULL)}
    if(ncol(modGen_clustTab()$table2) > 1){
      modGen_clustTab()$table2
    }
  }, include.rownames = FALSE)
  
  output$chisquare_test3Other <- renderText({
    if(is.null(modGen_clustTab())){return(NULL)}
    if(ncol(modGen_clustTab()$table2) > 1){
      if(modGen_clustTab()[[3]]$p.value < .001){
        paste("Chi_square statistic = ", round(modGen_clustTab()[[3]]$statistic, 2), ",", "p-value < .001")
      }
      else{
        paste("Chi-Square Test Statistic = ", round(modGen_clustTab()[[3]]$statistic, 2), ",", "p-value =", round(modGen_clustTab()[[3]]$p.value, 3))
      }
    }
  })
  
  output$fisher3Other <- renderText({
    if(is.null(modGen_clustTab())){return(NULL)}
    if(ncol(modGen_clustTab()$table2) > 1){
      if(modGen_clustTab()[[4]]$p.value < .001){
        paste("Fishers Exact Test: p-value < .001")
      }
      else{
        paste("Fishers Exact Test: p-value = ", round(modGen_clustTab()[[4]]$p.value, 3))
      }
    }
  })

  ##################################### Probe Level Heat Map #####################################

  heatmapdata<-reactive({
    if (input$set==1){#heatmapbase1
      if(values$hc == TRUE){
        base_sample_name <- values$design$columnname[which(values$design[,values$baseline_var] == values$baseline_val & values$design[,values$control_var] != values$control_val)]
        ind1 <- which(colnames(values$final_expression) %in% c("PROBE_ID", "SYMBOL"))
        ind2 <- which(colnames(values$final_expression) %in% base_sample_name)
      }
      if(values$hc == FALSE){
        base_sample_name <- values$design$columnname[which(values$design[,values$baseline_var] == values$baseline_val)]
        ind1 <- which(colnames(values$final_expression) %in% c("PROBE_ID", "SYMBOL"))
        ind2 <- which(colnames(values$final_expression) %in% base_sample_name)
      }
        exp_base_sam <- values$final_expression[, c(ind1, ind2)]
        des_base_sam <- values$design[which(values$design$columnname %in% colnames(exp_base_sam)),]
        dataManipulate(y = exp_base_sam, x = des_base_sam, 
                       colname = "columnname", format = "Probes", 
                       allsamples = TRUE)
        y<-dataManipulate(y = exp_base_sam, x = des_base_sam,colname = "columnname", format = "Probes",allsamples = TRUE)
        ddm<-values$h1b_rowdendro
        colddm<-values$h1b_coldendro
    }
    if (input$set==2){#heatmapbase2
      base_sample_name <- values$design$columnname[which(values$design[,values$baseline_var]==values$baseline_val | values$design[,values$control_var]==values$control_val)]
      ind1 <- which(colnames(final_expression) %in% c("PROBE_ID", "SYMBOL"))
      ind2 <- which(colnames(final_expression) %in% base_sample_name)
      exp_base_sam <- values$final_expression[, c(ind1, ind2)]
      des_base_sam <- values$design[which(values$design$columnname %in% colnames(exp_base_sam)), ]
      y<-dataManipulate(y=exp_base_sam,x=des_base_sam,colname ="columnname",ref_var=values$control_var,ref_level=values$control_val,long=FALSE,keep=TRUE,format="Probes",allsamples=FALSE)
      ddm<-values$h2b_rowdendro
      colddm<-values$h2b_coldendro
    }
    if(input$set==3){#heatmap1
      y<-dataManipulate(y=values$final_expression,x=values$design,colname="columnname",format="Probes",allsamples=TRUE)
      ddm<-values$h1_rowdendro
      colddm<-values$h1_coldendro
    }
    if(input$set==4){#heatmap2
      y <- dataManipulate(y = values$final_expression, x = values$design, colname = "columnname", ref_var = values$control_var, ref_level = values$control_val, long = FALSE, keep = TRUE, format = "Probes", allsamples = FALSE)
      ddm<-values$h2_rowdendro
      colddm<-values$h2_coldendro
    }
    if(input$set==5){#heatmap3
      if(values$hc==TRUE){
        des_w_controls<-values$design[which(values$design$columnname %in% colnames(values$final_expression)),]
        des_wo_controls<-values$design[-which(values$design[,values$control_var]==values$control_val),]
        h5index<-c(1,2,which(colnames(values$final_expression) %in% des_wo_controls$columnname))
        y<-dataManipulate(y=values$final_expression[,h5index],x=des_wo_controls,colname="columnname",ref_var=values$baseline_var,ref_level=values$baseline_val,long=TRUE,subjects=values$patient_id,keep=FALSE,format="Probes",allsamples=FALSE)
      }
      if(values$hc==FALSE){
        y<-dataManipulate(y=values$final_expression,x=values$design,colname="columnname",ref_var=values$baseline_var,ref_level=values$baseline_val,long=TRUE,subjects=values$patient_id,keep=FALSE,format="Probes",allsamples=FALSE)
      }
      ddm<-values$h3_rowdendro
      colddm<-values$h3_coldendro
    }
    z<-list(y=y,ddm=ddm,colddm=colddm)
    return(z)
  })

  heatmapname<-reactive({
    if(input$set==1) heattxt<-"Baseline Median Normalized"
    if(input$set==2) heattxt<-"Baseline Healthy Normalized"
    if(input$set==3) heattxt<-"All Samples Median Normalized"
    if(input$set==4) heattxt<-"All Samples Healthy Normalized"
    if(input$set==5) heattxt<-"All Samples Normalized to each Subjects Baseline"
    return(heattxt)
  })
  
  graphParams <- eventReactive(input$go, {
    params <- callModule(graphOptions, "unsupervisedGraphOptions")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution)
    return(params)
  })
  
  plotWidth <- function(){graphParams()$width}
  plotHeight <- function(){graphParams()$height}
  
  callModule(subsetAndOrderRenderUI, "unsupervisedSubOrder", des = reactive(values$design), groupingVar = reactive(values$responder_var))
  callModule(clusterAssociationRenderUI, "unsupervisedAssociation", data = reactive(values$design), groupingVar = reactive(values$responder_var))
  
  rowCluster <- eventReactive(input$go, {
    dat<- callModule(uploadVarsRowCluster, "transcripts", data = reactive(heatmapdata()$y$heatexp), dendro = reactive(heatmapdata()$ddm))
    x <- dat$x
    ddm <- dat$ddm
    labelRows <- dat$labelRows
    y <- list(x = x, ddm = ddm, labelRows = labelRows)
    return(y)
  })
  
  clusterData <- eventReactive(input$go,{
    x <- callModule(colCluster, "unsupervisedCluster", des = reactive(orderedData()$colAnnot), data = reactive(orderedData()$x))
    return(x)
  })
  
  gen_clustTab <- reactive({
    x <- callModule(clusterAssociation, "unsupervisedAssociation", des = reactive(orderedData()$design), hclObj = reactive(clusterData()$hcl))
    return(x)
  })

  orderedData <- reactive({
    dat <- callModule(subsetAndOrder, "unsupervisedSubOrder", des = reactive(heatmapdata()$y$heatdes), data = reactive(rowCluster()$x), 
                    sampleAnnot = reactive(values$sample_id), groupingVar = reactive(values$responder_var))
    x <- dat$dat
    colAnnot <- dat$colAnnot
    design <- dat$design
    z <- list(x = x, colAnnot = colAnnot, design = design)
    return(z)
  })
  
  maxRangeData <- eventReactive(input$go, {
    x <- callModule(maxValues, "unsupervisedMaxValues", reactive(orderedData()$x))
    return(x)
  })
  
  heatColors <- eventReactive(input$go, {
    x <- callModule(annColors, "unsupervisedSubOrder", reactive(orderedData()$colAnnot))
    return(x)
  })
  
  output$heatmap <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(maxRangeData(),Rowv = rowCluster()$ddm,Colv = clusterData()$colddm, treeheight = graphParams()$treeHeight, fontsize = graphParams()$fontSize, cexRow = 1.2, 
                             annheight = graphParams()$legendSize,color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = clusterData()$colAnnot,annColors = heatColors(),labRow=rowCluster()$labelRows,
                             breaks=0)
                 }
    )
  }, width = plotWidth, height = plotHeight)
  
  output$downloadModPlot4 <- downloadHandler(
    filename = function() {paste('Gene_Level_Heatmap','.png', sep = '')},
    content = function(file){
      png(file, width = (plotresolution2()/72)*plot_width(), height = (plotresolution2()/72)*plot_height(), res = plotresolution2())
        print(aheatmap2(maxRangeData(),Rowv = rowCluster()$ddm,Colv = clusterData()$colddm, treeheight = input$TreeHeight, fontsize = input$FontSize, cexRow = 1.2, 
                        annheight = Legend_Size(),color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = clusterData()$colAnnot,annColors = heatColors(),labRow=rowCluster()$labelRows, 
                        breaks=0))
      dev.off()
    }
  )
  
  output$downloadHeatmap <- downloadHandler(
    filename = function() {paste(values$project_name,'_',heatmapname(),'.csv', sep='')  },
    content = function(file) {
      write.csv(heatDataDownload(), file, row.names = TRUE)
    }
  )
  
  heatDataDownload <- reactive({
    x <- orderedData()$x
    if(is.na(rowCluster()$ddm)){
      if(is.na(clusterData()$colddm)){
        x <- x
      } else {
        x <- x[,order.dendrogram(clusterData()$colddm)]
      }
    } else {
      if(is.na(clusterData()$colddm)){
        x <- x[order.dendrogram(rowCluster()$ddm),]
      } else {
        x <- x[order.dendrogram(rowCluster()$ddm), order.dendrogram(clusterData()$colddm)]
        x <- x[nrow(x):1,]
      }
    }
    return(x)
  })


  output$clusterPlot <- renderPlot({
    barplot(clusterData()$d, names.arg = 2:round(nrow(orderedData()$colAnnot)/2), xlab = "Number of Clusters", ylab = "Dunn's Index")
  })

  output$downloadClusterPlot3 <- downloadHandler(
    filename = function() {paste('Cluster_Plot_ProbeLevel','.png', sep = '')},
    content = function(file){
      png(file, width = 800)
      print(barplot(opt_NumClust2()$d, names.arg = 2:round(nrow(heatmap_order()$design_ordered)/2), xlab = "Number of Clusters", ylab = "Dunn's Index"))
      dev.off()
    }
  )

  output$OptimalNumber <- renderText({
    paste("Optimal number of clusters =", clusterData()$opt_num )
  })

  output$cluster_output4 <- renderTable({
    if(is.null(gen_clustTab())){return(NULL)}
    gen_clustTab()$table1
  }, include.rownames = FALSE, digits = 0)

  output$explanation3 <- renderText({
    if(is.null(gen_clustTab())){return(NULL)}
    if(ncol(gen_clustTab()$table2) > 1){
      print("The table below is the table the tests are run on. It is the same as the table above, except the columns with zero counts have been deleted.")
    }
  })

  output$cluster_tab3 <- renderTable({
    if(is.null(gen_clustTab())){return(NULL)}
    if(ncol(gen_clustTab()$table2) > 1){
      gen_clustTab()$table2
    }
  }, include.rownames = FALSE)

  output$chisquare_test4 <- renderText({
    if(is.null(gen_clustTab())){return(NULL)}
    if(ncol(gen_clustTab()$table2) > 1){
      if(gen_clustTab()[[3]]$p.value < .001){
        paste("Chi_square statistic = ", round(gen_clustTab()[[3]]$statistic, 2), ",", "p-value < .001")
      }
      else{
        paste("Chi-Square Test Statistic = ", round(gen_clustTab()[[3]]$statistic, 2), ",", "p-value =", round(gen_clustTab()[[3]]$p.value, 3))
      }
    }
  })

  output$fisher4 <- renderText({
    if(is.null(gen_clustTab())){return(NULL)}
    if(ncol(gen_clustTab()$table2) > 1){
      if(gen_clustTab()[[4]]$p.value < .001){
        paste("Fishers Exact Test: p-value < .001")
      }
      else{
        paste("Fishers Exact Test: p-value = ", round(gen_clustTab()[[4]]$p.value, 3))
      }
    }
  })


  ################################# DGE ###########################################

  output$diffge <- renderMenu({
    if(is.null(values$results_file)){
      return(strong(""))
    }
    else{
      return(menuItem("DGE", icon = icon("area-chart"), tabName = "dge",
                      menuSubItem("Overview", tabName = "overview"),
                      menuSubItem("Gene List Maker", tabName = "genelistmaker"),
                      menuSubItem("Gene Search", tabName = "genesearch")))
    }
  })

  siglist <- reactive({
    results_file <- values$results_file
    sigcomp0 <- results_file[grep(("PROBE_ID|Estimate of|Test.statistic|P.Value"), names(results_file))]
    sigcomp1 <- sigcomp0[grep("Estimate of", names(sigcomp0))]
    sigcomp2 <- sigcomp0[grep("P.Value", names(sigcomp0))]
    sigcomp3 <- data.frame(apply(sigcomp2, 2, p.adjust, method="fdr"))
    colnames(sigcomp3) <- gsub("P.Value","FDR.P.Value",colnames(sigcomp3))
    sigcomp4 <- data.frame(apply(sigcomp2, 2, p.adjust, method="bonferroni"))
    colnames(sigcomp4) <- gsub("P.Value","Bonf.P.Value",colnames(sigcomp4))

    TF_Raw <- data.frame(sigcomp2 <= input$alphalevel2)
    TF_FDR <- data.frame(sigcomp3 <= input$alphalevel2)
    TF_Bonf <- data.frame(sigcomp4 <= input$alphalevel2)
    TF_Raw1 <- data.frame(sigcomp2 <= input$alphalevel2)
    TF_FDR1 <- data.frame(sigcomp3 <= input$alphalevel2)
    TF_Bonf1 <- data.frame(sigcomp4 <= input$alphalevel2)
    TF_p <- data.frame(sigcomp1 > 0)
    TF_pRaw <- TF_Raw + TF_p
    TF_pFDR <- TF_FDR + TF_p
    TF_pBonf <- TF_Bonf + TF_p
    TF_n <- data.frame(sigcomp1 < 0)
    TF_nRaw <- TF_Raw + TF_n
    TF_nFDR <- TF_FDR + TF_n
    TF_nBonf <- TF_Bonf + TF_n
    if(input$sigsign == "All (include 0)"){
      Raw <- apply(sigcomp2, 2, function(x) sum(x[!is.na(x)] < input$alphalevel2))
      names(Raw) <- gsub("P.Value for ", "", names(Raw))
      FDR <- apply(sigcomp3, 2, function(x) sum(x[!is.na(x)] < input$alphalevel2))
      names(FDR) <- gsub("FDR.P.Value.for.", "", names(FDR))
      Bonf <- apply(sigcomp4, 2, function(x) sum(x[!is.na(x)] < input$alphalevel2))
      names(Bonf) <- gsub("Bonf.P.Value.for.", "", names(Bonf))
      sigtab <- rbind(Raw, FDR, Bonf)
    }

    if(input$sigsign == "+"){
      Raw <- apply(TF_pRaw, 2, function(x) sum(x[!is.na(x)] == 2))
      names(Raw) <- gsub("P.Value for ", "", names(Raw))
      FDR <- apply(TF_pFDR, 2, function(x) sum(x[!is.na(x)] == 2))
      names(FDR) <- gsub("FDR.P.Value.for.", "", names(FDR))
      Bonf <- apply(TF_pBonf, 2, function(x) sum(x[!is.na(x)] == 2))
      names(Bonf) <- gsub("Bonf.P.Value.for.", "", names(Bonf))
      sigtab <- rbind(Raw, FDR, Bonf)
    }

    if(input$sigsign == "-"){
      Raw <- apply(TF_nRaw, 2, function(x) sum(x[!is.na(x)] == 2))
      names(Raw) <- gsub("P.Value for ", "", names(Raw))
      FDR <- apply(TF_nFDR, 2, function(x) sum(x[!is.na(x)] == 2))
      names(FDR) <- gsub("FDR.P.Value.for.", "", names(FDR))
      Bonf <- apply(TF_nBonf, 2, function(x) sum(x[!is.na(x)] == 2))
      names(Bonf) <- gsub("Bonf.P.Value.for.", "", names(Bonf))
      sigtab <- rbind(Raw, FDR, Bonf)
    }
    x <- t(sigtab)
    y <- cbind(Comparison = rownames(x), x)
    rownames(y) <- NULL
    z <- data.frame(y)
    for(i in 2:4){
      z[, i] <- as.numeric(levels(z[, i])[z[, i]])
    }
    y <- list(z = z, TF_Raw = TF_Raw, TF_FDR = TF_FDR, TF_Bonf = TF_Bonf, TF_Raw1 = TF_Raw1, TF_FDR1 = TF_FDR1, TF_Bonf1 = TF_Bonf1)

    return(y)
  })

  output$sigcomptable <- renderDataTable({
    withProgress(message = 'Making the table',
                 detail = 'This may take a while...', value = 1,{
                   siglist()$z[order(siglist()$z$Raw,decreasing=TRUE),]
                 })
  })
  
  index <- reactive({
    which(names(values$results_file)==pcomp())
  })
  
  pcomp <- reactive({
    x <- sub("^", "P.Value for ", input$comparison)
    x
  })

  plottitle1 <- reactive({
    paste("Distribution of Raw p-values for", input$comparison)
  })

  output$distplot<-renderPlot({
    y<-max(hist(values$results_file[, index()])$density)
    hist(values$results_file[,index()], freq=FALSE, xlim=c(0,1), ylim=c(0,y),main=plottitle1(),
         xlab="Raw p-value's", ylab="Density")
    lines(c(0,1),c(1,1),lwd=2,lty=2)
  })

  plotdata <-reactive({
    mymatrix<-c()
    index2<-c(0.001,0.01,1:19/20)
    for (i in 1:21){mymatrix<-rbind(mymatrix,c(mycorrection(values$results_file[,index()],index2[i],"RAW"),mycorrection(values$results_file[,index()],index2[i],"FDR"),mycorrection(values$results_file[,index()],index2[i],"BONF")))}
    mydata<-data.frame(cbind(index2,mymatrix))
    names(mydata)<-c("alpha","raw","fdr","bonf")
    data.frame(mydata)
  })

  output$numtable <-renderDataTable({
    numtab<-cbind(plotdata()[,1],plotdata()[,2:4]*dim(values$results_file)[1])
    names(numtab)<-c("Alpha", "Raw", "FDR", "Bonf")
    return(numtab)
  })
  
  sel_genelists <- reactive({
    if(length(grep("All", input$comparisons_download, fixed = TRUE)) > 0){
      nam <- names(values$results_file)
      index <- grep("P.Value",nam,fixed=T)
      p.names <- nam[index]
      comps <- gsub("P.Value for ", "", p.names)
    }
    else{
      comps <- input$comparisons_download
    }
    x.all <- list()
    for(i in 1:length(comps)){
      x <- callModule(filterOpts, "dgeResultsTable", data = reactive(values$results_file), comparison = reactive(comps[i]),"genes")
      x.all[[i]] <- x
    }
    names(x.all) <- comps
    return(x.all)
  })

  sig_ind <- reactive({
    dat <- callModule(filterOpts, "modDgeMap", data = reactive(values$results_file), data.type = "percents", geneList = reactive(moduleinfo1))
    prop_matrix <- dat$prop_matrix
    prop_matrix2 <- dat$prop_matrix2
    z <- list(prop_matrix = prop_matrix, prop_matrix2 = prop_matrix2)
    return(z)
  })
  
  ModMap_Comparison <- reactive({
    numgen <- function(x){
      d<-c()
      odd<-2*(1:20)-1
      if(length(x)==1){
        return(odd[1:x])}
      if(length(x)>1){
        for(i in 1:length(x)){d<-c(d,odd[1:x[i]])}
        return(d)}
    }
    numgen2 <- function(x){
      d<-c()
      odd<-2*(1:8)-1
      for (i in 1:length(x)){d<-c(d,rep(odd[9-i],x[i]))}
      return(d)
    }
    colorvar = sig_ind()$prop_matrix[1:97,input$comparison]+1
    colgrp <- findInterval(colorvar,seq(0,2,length.out=10))
    colfunc <- colorRampPalette(c("blue","white", "red"))
    collist <- colfunc(length(unique(colgrp)))
    mycolors <- collist[colgrp]
    mycolors = colorvar
    df2 <- data.frame(
      x = numgen(c(2,3,6,16,15,20,20,15)),
      y = c(numgen2(c(2,3,6,16,15,20,20,15))),
      z = mycolors
    )
    test<-ggplot(df2, aes(xmin=x-1,xmax=x+1,ymin=y-1,ymax=y+1),environment=environment())+
      theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),panel.grid.major = element_blank()
            ,panel.grid.minor = element_blank()
            ,panel.border = element_blank())+geom_rect(fill="white", colour="black")+
      scale_y_continuous(breaks=c(15,13,11,9,7,5,3,1), labels=c("M1","M2","M3","M4","M5","M6","M7","M7 (21-35)"),limits=c(0,40))+
      scale_x_continuous(breaks=(2*(1:20)-1),labels=1:20,limits=c(0,40))
    
    test2<-test+coord_cartesian(xlim = c(0, 40), ylim=c(0, 16))
    test3<-test2+geom_point(aes(x=x,y=y,size=500,colour=z))+
      scale_colour_gradient2(low="blue", high="red", guide="colorbar",midpoint=1)+
      theme(axis.title.x=element_blank(),axis.title.y=element_blank(),legend.position = "none") + scale_size_continuous(limits=c(1,500))
    
    if(is.null(values$ModulesTF) == FALSE){
      if(values$ModulesTF == FALSE){return(NULL)}
      if(values$ModulesTF == TRUE){return(test3)}
    }
    else{
      return(test3)
    }
  })
  
  output$moduleMap <- renderUI({
    if(!values$baylorMod){return(NULL)}
    plotOutput('modMap')
  })
  
  output$modMap <- renderPlot({
    ModMap_Comparison()
  }, width = 700, height = 190)
  
  output$downloadModMap <- renderUI({
    if(!values$baylorMod){return(NULL)}
    downloadButton('downloadModuleMap', "Download Figure")
  })
  
  output$downloadModuleMap <- downloadHandler(
    filename = function() {paste('ModMap_Comparison','.png', sep = '')},
    content = function(file){
      png(file, width = (mod_map_lmm_res()/72)*700, height = (mod_map_lmm_res()/72)*190, res = mod_map_lmm_res())
      print(ModMap_Comparison())
      dev.off()
    }
  )

  output$genelisttable <-renderDataTable({
    y <- callModule(filterOpts, "dgeResultsTable", data = reactive(values$results_file), comparison = reactive(input$comparison),"genes")
    y$SYMBOL <- paste("<a href=http://www.genecards.org/cgi-bin/carddisp.pl?gene=",y$SYMBOL," target = '_blank'",'>',y$SYMBOL,"</a>",sep='')
    escape = FALSE
    y
  },escape=FALSE)

  sig_exp_file <- reactive({
    g <- callModule(filterOpts, "dgeHeatmap", data = reactive(values$results_file), comparison = reactive(input$comparison2),"genes")
    g <- values$final_expression[which(values$final_expression$PROBE_ID %in% g$PROBE_ID),]
    z = list(g = g)
    return(z)
  })

  output$test1<-renderUI({
    if(is.null(values$h3_rowdendro)){
      if(values$hc == TRUE){
        try<-list("Baseline Median Normalized" = 1,
                  "Baseline Healthy Normalized" = 2)
      }
      if(values$hc == FALSE){
        try<-list("Baseline Median Normalized" = 1)
      }
    }
    if(!is.null(values$h3_rowdendro)){
      if(values$hc == TRUE){
        try<-list("Baseline Median Normalized" = 1,
                  "Baseline Healthy Normalized" = 2,
                  "All Samples Median Normalized" = 3,
                  "All Samples Healthy Normalized"=4,
                  "All Samples Baseline Normalized"=5)
      }
      if(values$hc == FALSE){
        try<-list("Baseline Median Normalized" = 1,
                  "All Samples Median Normalized" = 3,
                  "All Samples Baseline Normalized"=5)
      }
    }
    selectInput("set1", "Select heatmap:",as.list(try))
  })


  heatmapdata2 <-reactive({
    final_expression <- sig_exp_file()$g
    if (input$set1==1){#heatmapbase1
      if(values$hc == TRUE){
        base_sample_name <- values$design$columnname[which(values$design[,values$baseline_var] == values$baseline_val & values$design[,values$control_var] != values$control_val)]
        ind1 <- which(colnames(final_expression) %in% c("PROBE_ID", "SYMBOL"))
        ind2 <- which(colnames(final_expression) %in% base_sample_name)
      }
      if(values$hc == FALSE){
        base_sample_name <- values$design$columnname[which(values$design[,values$baseline_var] == values$baseline_val)]
        ind1 <- which(colnames(final_expression) %in% c("PROBE_ID", "SYMBOL"))
        ind2 <- which(colnames(final_expression) %in% base_sample_name)
      }
      exp_base_sam <- final_expression[, c(ind1, ind2)]
      des_base_sam <- values$design[which(values$design$columnname %in% colnames(exp_base_sam)),]
      dataManipulate(y = exp_base_sam, x = des_base_sam, 
                     colname = "columnname", format = "Probes", 
                     allsamples = TRUE)
      y<-dataManipulate(y = exp_base_sam, x = des_base_sam,colname = "columnname", format = "Probes",allsamples = TRUE)
    }
    if (input$set1==2){#heatmapbase2
      base_sample_name <- values$design$columnname[which(values$design[,values$baseline_var]==values$baseline_val | values$design[,values$control_var]==values$control_val)]
      ind1 <- which(colnames(final_expression) %in% c("PROBE_ID", "SYMBOL"))
      ind2 <- which(colnames(final_expression) %in% base_sample_name)
      exp_base_sam <- final_expression[, c(ind1, ind2)]
      des_base_sam <- values$design[which(values$design$columnname %in% colnames(exp_base_sam)), ]
      y<-dataManipulate(y=exp_base_sam,x=des_base_sam,colname ="columnname",ref_var=values$control_var,ref_level=values$control_val,long=FALSE,keep=TRUE,format="Probes",allsamples=FALSE)
    }
    if(input$set1==3){#heatmap1
      y<-dataManipulate(y=final_expression,x=values$design,colname="columnname",format="Probes",allsamples=TRUE)
    }
    if(input$set1==4){#heatmap2
      y <- dataManipulate(y = final_expression, x = values$design, colname = "columnname", ref_var = values$control_var, ref_level = values$control_val, long = FALSE, keep = TRUE, format = "Probes", allsamples = FALSE)
    }
    if(input$set1==5){#heatmap3
      if(values$hc==TRUE){
        des_w_controls<-values$design[which(values$design$columnname %in% colnames(final_expression)),]
        des_wo_controls<-values$design[-which(values$design[,values$control_var]==values$control_val),]
        h5index<-c(1,2,which(colnames(final_expression) %in% des_wo_controls$columnname))
        y<-dataManipulate(y=final_expression[,h5index],x=des_wo_controls,colname="columnname",ref_var=values$baseline_var,ref_level=values$baseline_val,long=TRUE,subjects=values$patient_id,keep=FALSE,format="Probes",allsamples=FALSE)
      }
      if(values$hc==FALSE){
        y<-dataManipulate(y=final_expression,x=values$design,colname="columnname",ref_var=values$baseline_var,ref_level=values$baseline_val,long=TRUE,subjects=values$patient_id,keep=FALSE,format="Probes",allsamples=FALSE)
      }
    }
    z<-list(y=y)
    return(z)
  })

  heatmapname1<-reactive({
    if(input$set1==1) heattxt<-"Baseline Median Normalized"
    if(input$set1==2) heattxt<-"Baseline Healthy Normalized"
    if(input$set1==3) heattxt<-"All Samples Median Normalized"
    if(input$set1==4) heattxt<-"All Samples Healthy Normalized"
    if(input$set1==5) heattxt<-"All Samples Normalized to each Subjects Baseline"
    heattxt
  })
  
  dgeGraphParams <- eventReactive(input$go2, {
    params <- callModule(graphOptions, "dgeGraphOptions")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution)
    return(params)
  })
  
  dgePlotWidth <- function(){dgeGraphParams()$width}
  dgePlotHeight <- function(){dgeGraphParams()$height}
  
  callModule(subsetAndOrderRenderUI, "dgeSubOrder", des = reactive(values$design), groupingVar = reactive(values$responder_var))
  
  dgeRowCluster <- eventReactive(input$go2, {
    x <- heatmapdata2()$y$heatexp 
    ddm <- NA
    if(input$rowCluster){
      dist <- dist(x)
      hcl <- fastcluster::hclust(dist)
      ddm <- as.dendrogram(hcl)
      Rowv <- rowMeans(x, na.rm = TRUE)
      ddm <- reorder(ddm, Rowv)
    }
    labelRows <- NULL
    y <- list(x = x, ddm = ddm, labelRows = labelRows)
    return(y)
  })
  
  dgeClusterData <- eventReactive(input$go2,{
    x <- callModule(colCluster, "dgeCluster", des = reactive(dgeOrderedData()$colAnnot), data = reactive(dgeOrderedData()$x))
    return(x)
  })
  
  dgeOrderedData <- reactive({
    dat <- callModule(subsetAndOrder, "dgeSubOrder", des = reactive(heatmapdata2()$y$heatdes), data = reactive(dgeRowCluster()$x), 
                      sampleAnnot = reactive(values$sample_id), groupingVar = reactive(values$responder_var))
    x <- dat$dat
    colAnnot <- dat$colAnnot
    design <- dat$design
    z <- list(x = x, colAnnot = colAnnot, design = design)
    return(z)
  })
  
  dgeMaxRangeData <- eventReactive(input$go2, {
    x <- callModule(maxValues, "dgeMaxValues", reactive(dgeOrderedData()$x))
    return(x)
  })
  
  dgeHeatColors <- eventReactive(input$go2, {
    x <- callModule(annColors, "dgeSubOrder", reactive(dgeOrderedData()$colAnnot))
    return(x)
  })
  
  output$heatmap1 <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(dgeMaxRangeData(),Rowv = dgeRowCluster()$ddm,Colv = dgeClusterData()$colddm, treeheight = dgeGraphParams()$treeHeight, fontsize = dgeGraphParams()$fontSize, cexRow = 1.2, 
                             annheight = dgeGraphParams()$legendSize,color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = dgeClusterData()$colAnnot,annColors = dgeHeatColors(),labRow=dgeRowCluster()$labelRows,
                             breaks=0)
                 }
    )
  }, width = dgePlotWidth, height = dgePlotHeight)
  
  output$downloadHeatmap2 <- downloadHandler(
    filename = function() {paste('Gene_Level_Heatmap','.png', sep = '')},
    content = function(file){
      png(file, width = (plotresolution2()/72)*plot_width(), height = (plotresolution2()/72)*plot_height(), res = plotresolution2())
      print(aheatmap2(maxRangeData(),Rowv = rowCluster()$ddm,Colv = clusterData()$colddm, treeheight = input$TreeHeight, fontsize = input$FontSize, cexRow = 1.2, 
                      annheight = Legend_Size(),color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = clusterData()$colAnnot,annColors = heatColors(),labRow=rowCluster()$labelRows, 
                      breaks=0))
      dev.off()
    }
  )
  
  output$downloadHeatmap1 <- downloadHandler(
    filename = function() {paste(values$project_name,'_',heatmapname(),'.csv', sep='')  },
    content = function(file) {
      write.csv(heatDataDownload(), file, row.names = TRUE)
    }
  )
  
  heatDataDownload2 <- reactive({
    x <- dgeOrderedData()$x
    if(is.na(dgeRowCluster()$ddm)){
      if(is.na(dgeClusterData()$colddm)){
        x <- x
      } else {
        x <- x[,order.dendrogram(dgeClusterData()$colddm)]
      }
    } else {
      if(is.na(dgeClusterData()$colddm)){
        x <- x[order.dendrogram(dgeRowCluster()$ddm),]
      } else {
        x <- x[order.dendrogram(dgeRowCluster()$ddm), order.dendrogram(dgeClusterData()$colddm)]
        x <- x[nrow(x):1,]
      }
    }
    return(x)
  })

  output$Comparison1 <- renderUI({
    nam <- names(values$results_file)
    index <- grep("P.Value",nam,fixed=T)
    p.names <- nam[index]
    p.names <- gsub("P.Value for ", "", p.names)
    selectInput("comparison", "Comparison:", p.names, p.names[1])
  })

  output$Comparison2 <- renderUI({
    nam <- names(values$results_file)
    index <- grep("P.Value",nam,fixed=T)
    p.names <- nam[index]
    p.names <- gsub("P.Value for ", "", p.names)
    selectInput("comparison_LMM", "Comparison:", p.names, p.names[1], multiple = TRUE)
  })
  
  output$Comparison3 <- renderUI({
    nam <- names(values$results_file)
    index <- grep("P.Value",nam,fixed=T)
    p.names <- nam[index]
    p.names <- gsub("P.Value for ", "", p.names)
    selectInput("comparison2", "Comparison:", p.names, p.names[1], multiple = TRUE)
  })
  
  output$selectComps <- renderUI({
    nam <- names(values$results_file)
    index <- grep("P.Value",nam,fixed=T)
    p.names <- nam[index]
    p.names <- gsub("P.Value for ", "", p.names)
    p.names <- c("All", p.names)
    selectInput("comparisons_download", "Comparison:", p.names, p.names[1], multiple = TRUE)
  })
  
  gensymb.search <- reactive({
    dat <- values$results_file
    genlist <- unique(dat$SYMBOL)
    genlist
  })

  probe.search <- reactive({
    dat <- values$results_file
    selectedprobes <- dat$PROBE_ID[which(dat$SYMBOL %in% input$specgene)]
    selectedprobes
  })

  output$specgene1 <- renderUI({
    genlist <- gensymb.search()
    withProgress(message = '',
                 detail = 'Generating the Options...', value = 1,{
                   selectizeInput("specgene", "Gene symbol selection:",
                                  choices = genlist,
                                  selected = genlist[1],options = list(maxOptions = 30))
                 })
  })

  output$probeid1 <- renderUI({
    if(is.null(input$specgene)){return(NULL)}
    else{
      selectedprobes <- probe.search()
      selectizeInput("probeid", "Probe ID selection:", multiple = TRUE, selectedprobes,selected=selectedprobes[1], options = list(maxOptions = 30))
    }
  })

  output$genTable <- renderUI({
    actionButton("go3", "Generate table")
  })

  sgl_flat <- reactive({
    results_file <- values$results_file
    sgl <- results_file[grep("P.Value", names(results_file), fixed = TRUE)]
    sgl_1 <- apply(sgl, 2, p.adjust, method = "fdr")
    colnames(sgl_1) <- gsub("P.Value","FDR.P.Value",colnames(sgl_1))
    sgl_2 <- apply(sgl, 2, p.adjust, method = "bonferroni")
    colnames(sgl_2) <- gsub("P.Value","Bonf.P.Value",colnames(sgl_2))
    sgl_flat <- data.frame(results_file, sgl_1, sgl_2)
    sgl_flat
  })

  specgenelist <- eventReactive(input$go3,{
    m_newsgl <- function(sss){
      newsgl_SYMBOL <- sgl_flat()[which(sgl_flat()$SYMBOL %in% sss),][,-2]
      comparisons <- gsub("Estimate.of.", "", colnames(newsgl_SYMBOL)[grep("Estimate", colnames(newsgl_SYMBOL), fixed = TRUE)])
      dat <- reshape2::melt(newsgl_SYMBOL, id.vars = "PROBE_ID")
      dat$variable <- gsub(".for.",".of.",dat$variable, fixed = TRUE)
      splt <- as.data.frame(stringr::str_split_fixed(dat$variable, ".of.",2))
      colnames(splt) <- c("variable", "Comparison")
      dat <- do.call("cbind", list(PROBE_ID = as.character(dat[,1]), splt, value = dat$value))
      newdat <- reshape2::dcast(dat, PROBE_ID + Comparison ~ variable)
      newdat <- newdat[,c(1,2,4,7,6,5,3)]
      return(newdat)
    }
    xx_0 <- m_newsgl(input$specgene)
    xx <- xx_0[which(xx_0$PROBE_ID %in% input$probeid),]
    xx
  })

  output$specgenetable <- renderDataTable({
    specgenelist()
  })

  output$genelistgraph<-renderPlot({
    plot(plotdata()$alpha,plotdata()$raw,type="l",main="Multiple Testing Comparison Plot",col="black",xlim=c(0,1),ylim=c(0,1),xlab=expression(alpha),ylab="% of Total Probes in Gene List")
    lines(plotdata()$alpha,plotdata()$fdr,col="red",lwd=2)
    lines(plotdata()$alpha,plotdata()$bonf,col="green")
    legend("bottomright",legend=c("Raw P-value","FDR","Bonf."), lty=c(1,1,1),col=c("black","red","green") )
    axis(4,at=1:10/10,labels=round(1:10/10*dim(values$results_file)[1],0))
    lines(c(0,1),c(0,1),lty=2)
  })

  output$downloadCG <- downloadHandler(
    filename = function(){paste0("Gene_Search_List","_", input$specgene,"_with_selected_probes", ".csv")},
    content = function(file){
      write.csv(specgenelist(), file,row.names = FALSE)
    }
  )

  output$downloadSC <- downloadHandler(
    filename = function() {paste("Significance_Comparison_Overview", '_', input$alphalevel2, '.csv', sep = '') },
    content = function(file){
      write.csv(siglist()$z, file,row.names = FALSE)
    }
  )

  output$downloadData <- downloadHandler(
    filename = function() {paste(substring(pcomp(),12),'_',input$correction_method1,input$alphalevel1,'.csv', sep='')  },
    content = function(file) {
      y <- callModule(filterOpts, "dgeResultsTable", data = reactive(values$results_file), comparison = reactive(input$comparison),"genes")
      write.csv(y, file,row.names = FALSE)
    }
  )
  
  output$downloadSelComp <- downloadHandler(
    filename = function() {paste(input$ziptext,".zip", sep = "")},
    content = function(file) {
      file.names <- c()
      for(i in 1:length(sel_genelists())){
        file.names[i] <- paste(names(sel_genelists())[i], "_", input$correction_method1, input$alphalevel1, ".csv", sep = "")
        write.csv(sel_genelists()[[i]], file = paste(names(sel_genelists())[i], "_", input$correction_method1, input$alphalevel1, ".csv", sep = ""), row.names = FALSE)
      }
      zip(zipfile = file, files = file.names)
    },
    contentType = "application/zip"
  )

  output$readme <-renderText({paste("The following reports are designed to investigate the results of Differential Gene Expression Analysis.
                                    Below is a summary by a biostatistics team member of the statistical model that was conducted for this project.
                                    The following tabs provide the user with the ability to create their own gene lists for any comparison the analysis conducted.
                                    In the DGE: Gene Lists tab, the user can create the list using raw p-value thresholds or multiple testing corrections by tweaking the inputs on the left hand side of interface.
                                    In addition to the list, a module map of the first Seven rounds of the Baylor Modules is produced.  The percentages are calculated by taking the significant probes in the current gene list
                                    and calculating the percentages of significant probes that are significantly up or down regulated.") })
  output$intro <-renderText({paste("Number of probes in Gene list by method and alpha parameter.")})
  
  output$dgeTabs <- renderUI({
    if(is.null(values$long_base) & is.null(values$long_ctrl) & is.null(values$base_ctrl)){
      tabs <- lapply(1:(length(tabs.content)-1), function(i) tabPanel(tabs.content[[i]]$Title, tabs.content[[i]]$Content))
      return(do.call(tabBox, args = c(tabs, list(title = "DGE Results", width = 12, id = "dgeResults"))))
    }
    else {
      tabs <- lapply(1:length(tabs.content), function(i) tabPanel(tabs.content[[i]]$Title, tabs.content[[i]]$Content))
      return(do.call(tabBox, args = c(tabs, list(title = "DGE Results", width = 12, id = "dgeResults"))))
    }
  })

  modDgeGraphParams <- eventReactive(input$goModDge,{
    params <- callModule(graphOptions, "modDgeGraphOptions", varType = "modules")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    circleSize <- params$circleSize
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution, 
                   circleSize = circleSize)
    return(params)
  })
  
  modDgePlotWidth <- function(){modDgeGraphParams()$width}
  modDgePlotHeight <- function(){modDgeGraphParams()$height}
  
  output$dgeModSelection <- renderUI({
    if(!values$baylorMod){return(NULL)}
    selectizeInput("dgeModuleSelection", "Module to include:", c("All", "First Round", "First Two Rounds", "First Three Rounds", "First Four Rounds", "First Five Rounds",
                                                              "First Six Rounds", "First Seven Rounds", "First Eight Rounds"), "First Six Rounds")
  })
  
  modDgeData <- eventReactive(input$goModDge,{
    dat <- sig_ind()$prop_matrix
    ddm <- NA
    colddm <- NA
    if(input$compSelect){
      dat <- dat[,match(input$comparison_LMM, colnames(dat), nomatch = 0)]
    }
    if(values$baylorMod){
      if(input$dgeModuleSelection == "First Round"){
        dat <- dat[1:2,]
      } else if(input$dgeModuleSelection == "First Two Rounds"){
        dat <- dat[1:5,]
      } else if(input$dgeModuleSelection == "First Three Rounds"){
        dat <- dat[1:11,]
      } else if(input$dgeModuleSelection == "First Four Rounds"){
        dat <- dat[1:27,]
      } else if(input$dgeModuleSelection == "First Five Rounds"){
        dat <- dat[1:42,]
      } else if(input$dgeModuleSelection == "First Six Rounds"){
        dat <- dat[1:62,]
      } else if(input$dgeModuleSelection == "First Seven Rounds"){
        dat <- dat[1:97,]
      } else if(input$dgeModuleSelection == "First Eight Rounds"){
        dat <- dat[1:208,]
      } 
    }
    if(input$uploadModules){
      modNames <- read.csv(input$modSelect$datapath, header = TRUE)
      dat <- dat[which(rownames(dat) %in% modNames[,1]),]
    }
    if(input$modDgeCluster){
      ddm <- FALSE
    }
    if(input$colCluster){
      colddm <- TRUE
    }
    z <- list(dat = dat, ddm = ddm, colddm = colddm)
    return(z)
  })
  
  output$modDgeMap <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(modDgeData()$dat,Rowv = modDgeData()$ddm,Colv = modDgeData()$colddm,circle_size = modDgeGraphParams()$circleSize, treeheight = modDgeGraphParams()$treeHeight, fontsize = modDgeGraphParams()$fontSize, cexRow = 1.2, 
                             annheight = modDgeGraphParams()$legendSize,color = colorRampPalette(c("blue", "white", "red"))(100),breaks=0)
                 }
    )
  }, width = modDgePlotWidth, height = modDgePlotHeight)
  
  output$downloadModDgeMap <- downloadHandler(
    filename = function() {paste(values$project_name,"_LMM_ModuleMap",'_',input$correction_method1,input$alphalevel1,'.png', sep='')},
    content = function(file) {
      png(file, width = (modDgeGraphParams()$resolution/72)*modDgeGraphParams()$width, height = (modDgeGraphParams()$resolution/72)*modDgeGraphParams()$height, 
          res = modDgeGraphParams()$resolution)
      print(aheatmap2(modDgeData()$dat,Rowv = modDgeData()$ddm,Colv = modDgeData()$colddm,circle_size = modDgeGraphParams()$circleSize, treeheight = modDgeGraphParams()$treeHeight, fontsize = modDgeGraphParams()$fontSize, cexRow = 1.2, 
                      annheight = modDgeGraphParams()$legendSize,color = colorRampPalette(c("blue", "white", "red"))(100),breaks=0))
      dev.off()
    }
  )


  output$downloadModDgeData <- downloadHandler(

    filename = function() {paste(values$project_name,"_LMM_ModuleData",'_',input$correction_method1,input$alphalevel1,'.csv', sep='')},
    content = function(file) {
      write.csv(modDgeData()$dat, file)
    }
  )

  output$vennComparison <- renderUI({
    nam <- names(values$results_file)
    index <- grep("P.Value",nam,fixed=T)
    p.names <- nam[index]
    p.names <- gsub("P.Value for ", "", p.names)
    selectInput("Vcomparison", "Comparison:", p.names, p.names[1], multiple = TRUE)
  })

  output$include <- renderUI({
    n = length(input$Vcomparison)
    Vcomparison = input$Vcomparison
    selectInput("Include", "Include:", Vcomparison, Vcomparison[1:n], multiple = TRUE)
  })

  output$exclude <- renderUI({
    comparisons <- setdiff(input$Vcomparison, input$Include)
    selectInput("Exclude", "Exclude:", comparisons, comparisons[1], multiple = TRUE)
  })

  venndata <- reactive({
    venn.data <- list()
    for(i in 1:length(input$Vcomparison)){
      venn.data[[i]] <- callModule(filterOpts, "dgeVenn", reactive(values$results_file), reactive(input$Vcomparison[i]), "genes")
      venn.data[[i]] <- as.character(venn.data[[i]][,1])
    }
    names(venn.data) <- input$Vcomparison
    if(length(venn.data) > 5){
    venn.data <- venn.data[1:5]
    }
    return(venn.data)
  })

  Venn.intersection <- reactive({
    if(is.null(venndata())){return(NULL)}
    venndata1 <- venndata()[which(names(venndata()) %in% input$Include)]
    intersections <- Reduce(intersect, venndata1)
    n = length(input$Exclude)
    if(n > 0){
      venndata2 <- venndata()[which(names(venndata()) %in% input$Exclude)]
      venndata2 = unlist(venndata2)
      excl <- list(intersections, venndata2)
      intersections <- Reduce(setdiff, excl)
    }
    return(intersections)
  })
  
  output$testing <- renderText({
    length(venndata())
  })

  Venn.union <- reactive({
    if(is.null(venndata())){return(NULL)}
    venndata1 <- venndata()[which(names(venndata()) %in% input$Include)]
    unions <- Reduce(union, venndata1)
    n = length(input$Exclude)
    if(n > 0){
      venndata2 <- venndata()[which(names(venndata()) %in% input$Exclude)]
      venndata2 <- unlist(venndata2)
      excl <- list(unions, venndata2)
      unions <- Reduce(setdiff, excl)
    }
    return(unions)
  })

  genelist2 <- reactive({
    n = length(input$Include)
    comp <- input$Include
    fcomp <- list()
    for(i in 1:n){
      fcomp[[i]] <- c(paste0("Estimate of ", input$Include[i]), paste0("Test.statistic for ", input$Include[i]),
                      paste0("P.Value for ", input$Include[i]))
    }
    if(input$UorI == 1){
      y <- which(values$results_file[,1] %in% Venn.intersection())
      cols <- list()
      for(i in 1:n){
        #cols[[i]] <- grep(fcomp[i], colnames(values$results_file))
        cols[[i]] <- match(fcomp[[i]], colnames(values$results_file))
      }
    }
    if(input$UorI == 2){
      y <- which(values$results_file[,1] %in% Venn.union())
      cols <- list()
      for(i in 1:n){
        #cols[[i]] <- grep(fcomp[i], colnames(values$results_file))
        cols[[i]] <- match(fcomp[[i]], colnames(values$results_file))
      }
    }
    x = list()
    pcols = list()
    pvals_fdr = list()
    pvals_bonf = list()
    pvals <- list()
    estimates <- list()
    tstats <- list()
    for(i in 1:n){
      if(i == 1){
        x[[i]] <- values$results_file[y,c(1,2,cols[[i]])]
      }
      if(i > 1){
        x[[i]] <- values$results_file[y,cols[[i]]]
      }
      pvals[[i]] <- grep("^P.Value", colnames(x[[i]]))
      estimates[[i]] <- grep("^Estimate", colnames(x[[i]]))
      tstats[[i]] <- grep("^Test.statistic", colnames(x[[i]]))
      if(i == 1){
        x[[i]] <- x[[i]][,c(1,2,estimates[[i]],pvals[[i]])]
      }
      if(i > 1){
        x[[i]] <- x[[i]][,c(estimates[[i]],pvals[[i]])]
      }
    }
    for(i in 1:n){
      if(i == 1){
        colnames(x[[i]]) = c("PROBE_ID", "SYMBOL", "Log2FC","P.Value")
      }
      if(i > 1){
        colnames(x[[i]]) = c("Log2FC", "P.Value")
      }
    }
    if(n > 1){
      for(i in 1:n){
        if(i == 1){
          colnames(x[[i]]) = c("PROBE_ID", "SYMBOL", paste("Log2FC for", comp[i], sep = " "), paste("P.Value for", comp[i], sep =" "))
        }
        if(i > 1){
          colnames(x[[i]]) = c(paste("Log2FC for", comp[i], sep = " "), paste("P.Value for", comp[i], sep = " "))
        }
      }
    }
    x = do.call("cbind", x)
    if(nrow(x) == 0){
      x <- data.frame("No Genes Present")
      names(x) <- "PROBE_ID"
    }
    return(x)
  })

  output$vennIntersection <- renderDataTable({
    y <- genelist2()
    y$SYMBOL <- paste("<a href=http://www.genecards.org/cgi-bin/carddisp.pl?gene=",y$SYMBOL," target = '_blank'",'>',y$SYMBOL,"</a>",sep='')
    escape = FALSE
    y
  }, escape = FALSE)

  output$vennDiagram <- renderPlot({
    dummy <- data.frame("No Genes Present")
    names(dummy) <- "PROBE_ID"
    if(identical(genelist2(),dummy)){return(NULL)}
    color.choices = c("blue", "green", "red", "orange","purple")
    if(length(venndata()) == 1){
      color.choices = color.choices[1]
    }
    if(length(venndata()) == 2){
      color.choices = color.choices[1:2]
    }
    if(length(venndata()) == 3){
      color.choices = color.choices[1:3]
    }
    if(length(venndata()) == 4){
      color.choices = color.choices[1:4]
    }
    if(length(venndata()) == 5){
      color.choices = color.choices
    }
    grid.draw(VennDiagram::venn.diagram(venndata(), filename = NULL, lwd = 1, col = color.choices, cat.cex = .9, fil = color.choices, margin = .12, ext.text = FALSE,
                           euler.d = TRUE))
  })

  output$downloadVennData <- downloadHandler(
    filename = function() {paste0("VennDiagram_", input$UorI, '.csv')  },
    content = function(file) {
      dummy <- data.frame("No Genes Present")
      names(dummy) <- "PROBE_ID"
      if(identical(genelist2(),dummy)){return(NULL)}
      write.csv(genelist2(), file,row.names = FALSE)
    }
  )

  output$downloadVennPic <- downloadHandler(
    filename = function() {paste0("VennDiagram_", input$UorI, '.png')  },
    content = function(file) {
      dummy <- data.frame("No Genes Present")
      names(dummy) <- "PROBE_ID"
      if(identical(genelist2(),dummy)){return(NULL)}
      color.choices = c("blue", "green", "red", "orange","purple")
      if(length(venndata()) == 1){
        color.choices = color.choices[1]
      }
      if(length(venndata()) == 2){
        color.choices = color.choices[1:2]
      }
      if(length(venndata()) == 3){
        color.choices = color.choices[1:3]
      }
      if(length(venndata()) == 4){
        color.choices = color.choices[1:4]
      }
      if(length(venndata()) == 5){
        color.choices = color.choices
      }
      png(file)
      grid.draw(VennDiagram::venn.diagram(venndata(), filename = NULL, lwd = 1, col = color.choices, cat.cex = .9, fil = color.choices, margin = .12, ext.text = FALSE,euler.d = TRUE))
      dev.off()
    }
  )


  output$downloadLMMModMap2 <- downloadHandler(
    filename = function() {paste('LMMModMap','.png', sep = '')},
    content = function(file){
      png(file, width = (resolution1()/72)*LMMmap1(), height = (resolution1()/72)*LMMmap2(), res = resolution1())
      if(min(lmm_module()$dat) >= 0 & max(lmm_module()$dat) > 0){
        print(aheatmap2(lmm_module()$dat, Rowv = lmm_module()$rowv, circle_size = input$LMMradius, fontsize = input$LMMFont, Colv = NA , color = lmm_module()$color_palette[500:1000]))
      }
      if(max(lmm_module()$dat) <= 0 & min(lmm_module()$dat) < 0){
        print(aheatmap2(lmm_module()$dat, Rowv = lmm_module()$rowv, circle_size = input$LMMradius, fontsize = input$LMMFont, Colv = NA , color = lmm_module()$color_palette[1:500]))
      }
      if(min(lmm_module()$dat) < 0 & max(lmm_module()$dat) >0){
        print(aheatmap2(lmm_module()$dat, Rowv = lmm_module()$rowv, circle_size = input$LMMradius, fontsize = input$LMMFont, Colv = NA , color = lmm_module()$color_palette))
      }
      if(all(lmm_module()$dat == 0)){
        return(NULL)
      }
      dev.off()
    }
  )

  mod_map_lmm_res <- reactive({
    input$modmaplmmres
  })

  output$download_modmap_comparison <- downloadHandler(
    filename = function() {paste('ModMap_Comparison','.png', sep = '')},
    content = function(file){
      png(file, width = (mod_map_lmm_res()/72)*700, height = (mod_map_lmm_res()/72)*190, res = mod_map_lmm_res())
      print(ModMap_Comparison())
      dev.off()
    }
  )


############## QUSAGE #####################

  output$qusage <- renderMenu({
    if(is.null(values$qusage_results)){
      return(strong(""))
    }
    if(is.null(values$qusage_results) == FALSE){
      menuItem("Q-Gen", icon = icon("filter"), tabName = "qusage")
    }
  })

  output$genesets <- renderUI({
    if(is.null(values$qusage_results)){
      return(NULL)
    }
    else{
     if(is.list(values$qusage_results) & !is.data.frame(values$qusage_results)){
       if(is.null(names(values$qusage_results))){
         return(selectInput("genesets1", "Select geneset definition:", choices = c(1:length(values$qusage_results))))
       }
       if(!is.null(names(values$qusage_results))){
         return(selectInput("genesets1", "Select geneset definition:", choices = c(names(values$qusage_results))))
       }
     }
      else{
        return(NULL)
      }
    }
  })

  master <- reactive({
    if(is.null(values$qusage_results)){return(NULL)}
    if(is.null(input$genesets1)){
      qusage_results <- values$qusage_results
    }
    if(!is.null(input$genesets1)){
      if(!is.null(names(values$qusage_results))){
        qusage_results <- values$qusage_results[[input$genesets1]]
      }
      else{
        qusage_results <- values$qusage_results[[as.numeric(input$genesets1)]]
      }
    }
    master <- qusage_results
    colnames(master)[which(colnames(master) == "log.fold.change")] <- "Log2FC"
    unique_comp <- unique(master$Comparison)
    sub_uniquecomp <- list()
    n = length(unique_comp)
    for(i in 1:n){
      sub_uniquecomp[[i]] <- which(master$Comparison == unique_comp[i])
    }
    bonf <- list()
    for(i in 1:n){
      bonf[[i]] <- p.adjust(master$p.Value[sub_uniquecomp[[i]]], method = "bonferroni")
    }
    bonf <- unlist(bonf)
    master$Bonf <- bonf
    if(!is.null(values$illumina)){
      if(values$illumina == FALSE){
        if(is.null(values$moduleinfo2)){
          master$pathway.name <- gsub("_", ".", master$pathway.name)
        }
      }
    }
    n2 <- length(module_annotations[,1])
    mod.ann <- list()
    master$Modulev2_Annotation <- ""
    for(i in 1:n2){
      mod.ann[[i]] <- which(master$pathway.name %in% module_annotations[,1][i])
    }
    for(i in 1:n2){
      master$Modulev2_Annotation[mod.ann[[i]]] <- as.character(module_annotations[,2][i])
    }
    if(is.null(values$BaylorTF)){
      mod.annot <- module_annotations
      mod.annot <- mod.annot[match(master$pathway.name[which(master$pathway.name %in% mod.annot$Module)], mod.annot$Module, nomatch = 0),]
      master$pathway.name <- as.character(master$pathway.name)
      master$pathway.name[which(master$pathway.name %in% mod.annot$Module)] <- paste(mod.annot$Modulev2_Annotation,mod.annot$Module,sep=" ")
      master$pathway.name <- as.factor(master$pathway.name)
    }
    return(master)
  })

  mod_list <- reactive({
    if(is.null(values$illumina) == FALSE){
      if(values$illumina == FALSE){
        if(is.null(values$moduleinfo2)){
          modnames<-unique(moduleinfo2$Module)
          y<-unlist(strsplit(as.character(modnames),".",fixed=TRUE))
          y <- unlist(modnames)
          y<-matrix(y,byrow=T,nrow=260,ncol=2)
          sortmodnames<-as.character(modnames)[order(y[,1],y[,2])]
          Modulelist<-list(as.character(moduleinfo2$SYMBOL[which(moduleinfo2$Module==sortmodnames[1])]),as.character(moduleinfo2$SYMBOL[which(moduleinfo2$Module==sortmodnames[2])]))
          for(i in 3:length(sortmodnames)){Modulelist<-c(Modulelist,list(as.character(moduleinfo2$SYMBOL[which(moduleinfo2$Module==sortmodnames[i])])))}
          names(Modulelist)<-sortmodnames
        }
        else{
          modnames<-unique(values$moduleinfo2$Module)
          y<-unlist(strsplit(as.character(modnames),".",fixed=TRUE))
          y<-matrix(y,byrow=T,nrow=260,ncol=2)
          sortmodnames<-as.character(modnames)[order(y[,1],y[,2])]
          Modulelist<-list(as.character(values$moduleinfo2$SYMBOL[which(values$moduleinfo2$Module==sortmodnames[1])]),as.character(values$moduleinfo2$SYMBOL[which(values$moduleinfo2$Module==sortmodnames[2])]))
          for(i in 3:length(sortmodnames)){Modulelist<-c(Modulelist,list(as.character(values$moduleinfo2$SYMBOL[which(values$moduleinfo2$Module==sortmodnames[i])])))}
          names(Modulelist)<-sortmodnames
        }
      }
      else{
        Modulelist <- Modulelist
        mod.anno <- names(Modulelist)[which(names(Modulelist) %in% module_annotations[,1])]
        module_annotations2 <- module_annotations[match(mod.anno, module_annotations[,1], nomatch=0),]
        names(Modulelist)[which(names(Modulelist) %in% module_annotations2[,1])] <- paste(module_annotations2[,2], module_annotations2[,1], sep=" ")
      }
    }
    if(is.null(values$illumina)){
      Modulelist <- Modulelist
      mod.anno <- names(Modulelist)[which(names(Modulelist) %in% module_annotations[,1])]
      module_annotations2 <- module_annotations[match(mod.anno, module_annotations[,1], nomatch=0),]
      names(Modulelist)[which(names(Modulelist) %in% module_annotations2[,1])] <- paste(module_annotations2[,2], module_annotations2[,1], sep=" ")
    }
    return(Modulelist)
  })


  output$Comparisons <- renderUI({
    selectInput("set_comp", "Comparison selection:", choices = levels(master()$Comparison), selected = levels(master()$Comparison)[1])
  })

  output$Comparisons1 <- renderUI({
    selectInput("set_comp1", "Comparison(s) selection:", choices = levels(master()$Comparison), selected = levels(master()$Comparison)[1], multiple = T)
  })

  output$Comparisons2 <- renderUI({
    selectInput("set_comp2", "Comparison selection:", choices = levels(master()$Comparison), selected = levels(master()$Comparison)[1])
  })

  output$Comparisons3 <- renderUI({
    selectInput("set_comp3", "Comparison selection:", choices = levels(master()$Comparison), selected = levels(master()$Comparison)[1])
  })

  output$Module_Select1 <- renderUI({
    selectInput("Mod_Select1", "Module selection:", choices = names(mod_list()), selected = names(mod_list()[1]))
  })

  output$PaloOrFirst1  <- renderUI({
    if(length(input$set_comp1) <= 1){return(NULL)}
    else{
      selectInput("PaloOrFirst", "Significant gene sets:", choices = c("In at least one comparison chosen" = 1, "In first comparison chosen" = 2), selected = 1)
    }
  })

  output$ColorChoice <- renderUI({
    if(length(input$set_comp1) <= 1){return(NULL)}
    else{
      cols = c("blue", "red","green","lightskyblue","purple","hotpink","brown","gold")
      selectInput("ColorChoice1", "Choose line colors:", choices = cols, selected = cols[1:length(input$set_comp1)], multiple = T)
    }
  })

  multi_testing <- reactive({
    Multi_testing1 = input$Multi_testing1
    Multi_testing1
  })

  multi_testing2 <- reactive({
    Multi_testing2 = input$Multi_testing2
    Multi_testing2
  })
  
  comp_subset1 <- reactive({
    master <- callModule(filterOpts, "qusFcPlot", data = master, comparison = reactive(input$set_comp1), data.type = "geneSets", 
                         paloOrFirst = reactive(input$PaloOrFirst))
    return(master)
  })


output$Module_Select <- renderUI({
    master <- master()[which(master()$Comparison %in% input$set_comp2),]
    pathways <- master$pathway.name
    selectInput("Mod_Select", "Module selection:", choices = gtools::mixedsort(as.character(pathways)), selected = gtools::mixedsort(as.character(pathways))[1])
  })

  venn.data <- reactive({
    if(is.null(master())){return(NULL)}
    master <- comp_subset1()
    unique.comparison <- unique(master$Comparison)
    n = length(unique.comparison)
    master1 <- list()
    for(i in 1:n){
      master1[[i]] <- subset(master, Comparison == unique.comparison[i])
    }
    names(master1) <- as.character(unique.comparison)
    for(i in 1:n){
      master1[[i]] <- master1[[i]]$pathway.name[which(master1[[i]]$SIG == "Significant")]
    }
    master1
  })

  comp_overview <- reactive({
    if(is.null(master())){return(NULL)}
    master1 = master()[which(master()$p.Value <= input$SigLevel),]
    master2 = master()[which(master()$FDR <= input$SigLevel),]
    master3 = master()[which(master()$Bonf <= input$SigLevel),]
    if(nrow(master1) == 0 & nrow(master2) == 0 & nrow(master3) == 0){return(NULL)}
    if(input$foldchange.q == "+"){
      master1 = master1[which(master1$Log2FC > 0),]
      master2 = master2[which(master2$Log2FC > 0),]
      master3 = master3[which(master3$Log2FC > 0),]
    }
    if(input$foldchange.q == "-"){
      master1 = master1[which(master1$Log2FC < 0),]
      master2 = master2[which(master2$Log2FC < 0),]
      master3 = master3[which(master3$Log2FC < 0),]
    }
    if(nrow(master1) > 0){
      master_sig1 = aggregate(Comparison ~ Comparison, data = master1, FUN = table)
      master_sig1 = as.matrix(master_sig1)
      master_sig1 = as.data.frame(master_sig1)
      colnames(master_sig1) = sub("Comparison.", "",colnames(master_sig1))
      master_sig1 = t(master_sig1)
      master_sig1 = as.data.frame(master_sig1)
      master_sig1 = cbind(rownames(master_sig1), master_sig1[,1])
      master_sig1 = as.data.frame(master_sig1)
    }
    if(nrow(master2) > 0){
      master_sig2 = aggregate(Comparison ~ Comparison, data = master2, FUN = table)
      master_sig2 = as.matrix(master_sig2)
      master_sig2 = as.data.frame(master_sig2)
      colnames(master_sig2) = sub("Comparison.", "",colnames(master_sig2))
      master_sig2 = t(master_sig2)
      master_sig2 = as.data.frame(master_sig2)
      master_sig2 = cbind(rownames(master_sig2), master_sig2[,1])
      master_sig2 = as.data.frame(master_sig2)
    }
    if(nrow(master3) > 0){
      master_sig3 = aggregate(Comparison ~ Comparison, data = master3, FUN = table)
      master_sig3 = as.matrix(master_sig3)
      master_sig3 = as.data.frame(master_sig3)
      colnames(master_sig3) = sub("Comparison.", "",colnames(master_sig3))
      master_sig3 = t(master_sig3)
      master_sig3 = as.data.frame(master_sig3)
      master_sig3 = cbind(rownames(master_sig3), master_sig3[,1])
      master_sig3 = as.data.frame(master_sig3)
    }
    if(nrow(master1) > 0 & nrow(master2) > 0 & nrow(master3) > 0){
      master_sig = cbind(master_sig1, master_sig2[,-1], master_sig3[,-1])
      master_sig[,2] = as.numeric(as.character(master_sig[,2]))
      master_sig[,3] = as.numeric(as.character(master_sig[,3]))
      master_sig[,4] = as.numeric(as.character(master_sig[,4]))
      colnames(master_sig) = c("Comparison", "Raw", "FDR", "Bonf")
      master_sig = master_sig[order(master_sig$Raw, decreasing = T),]
    }
    if(nrow(master1) > 0 & nrow(master2) > 0 & nrow(master3) == 0){
      master_sig = cbind(master_sig1, master_sig2[,-1], 0)
      master_sig[,2] = as.numeric(as.character(master_sig[,2]))
      master_sig[,3] = as.numeric(as.character(master_sig[,3]))
      master_sig[,4] = as.numeric(as.character(master_sig[,4]))
      colnames(master_sig) = c("Comparison", "Raw", "FDR", "Bonf")
      master_sig = master_sig[order(master_sig$Raw, decreasing = T),]
    }
    if(nrow(master1) > 0 & nrow(master2) == 0 & nrow(master3) > 0){
      master_sig = cbind(master_sig1, 0, master_sig3[,-1])
      master_sig[,2] = as.numeric(as.character(master_sig[,2]))
      master_sig[,3] = as.numeric(as.character(master_sig[,3]))
      master_sig[,4] = as.numeric(as.character(master_sig[,4]))
      colnames(master_sig) = c("Comparison", "Raw", "FDR", "Bonf")
      master_sig = master_sig[order(master_sig$Raw, decreasing = T),]
    }
    if(nrow(master1) > 0 & nrow(master2) == 0 & nrow(master3) == 0){
      master_sig = cbind(master_sig1, 0, 0)
      master_sig[,2] = as.numeric(as.character(master_sig[,2]))
      master_sig[,3] = as.numeric(as.character(master_sig[,3]))
      master_sig[,4] = as.numeric(as.character(master_sig[,4]))
      colnames(master_sig) = c("Comparison", "Raw", "FDR", "Bonf")
      master_sig = master_sig[order(master_sig$Raw, decreasing = T),]
    }
    return(master_sig)
  })

  individual_modselect <- reactive({
    if(is.null(master())){return(NULL)}
    master = master()[which(master()$Comparison == input$set_comp2 & master()$pathway.name == input$Mod_Select), ,drop = F]
    lowerCI = values$lowerCI
    upperCI = values$upperCI
    rownames(lowerCI) <- rownames(upperCI) <- as.character(values$results_file[,1])
    mmr_modselection <- callModule(filterOpts, "qusIndFcPlot", data = reactive(values$results_file), comparison = reactive(input$set_comp2), data.type = "genes")
    mmr_modselection <- mmr_modselection[which(mmr_modselection[,1] %in% mod_list()[[input$Mod_Select]]),]
    lowerCI <- lowerCI[match(mmr_modselection[,1], rownames(lowerCI), nomatch = 0),which(colnames(lowerCI) %in% input$set_comp2)]
    upperCI <- upperCI[match(mmr_modselection[,1], rownames(upperCI), nomatch = 0),which(colnames(upperCI) %in% input$set_comp2)]
    mmr_names <- mmr_modselection[,2]
    mmr_probes <- mmr_modselection[,1]
    missing_symb <- which(sapply(mmr_names, function(x) identical("",x)))
    if(length(missing_symb) > 0){
      mmr_names[missing_symb] <- mmr_probes[missing_symb]
    }
    duplicates <- which(duplicated(mmr_names))
    if(sum(duplicates) > 0){
      mmr_names[duplicates] <- mmr_probes[duplicates]
    }
    mmr_modselection <- cbind(mmr_modselection, lowerCI, upperCI)
    mmr_modselection$Test.Statistic <- NULL
    
    if(nrow(mmr_modselection) == 0){return(NULL)}
    Index <- order(mmr_modselection$Log2FC, decreasing = T)
    mmr_modselection <- mmr_modselection[Index,]
    mmr_modselection <- cbind(1:length(Index), mmr_modselection)
    colnames(mmr_modselection) <- c("Index", colnames(mmr_modselection[,-1]))
    mmr_modselection <- mmr_modselection
    y = list(mmr_modselection = mmr_modselection, master = master)
    return(y)
  })

  plotHeight = function(){input$PlotHeight}
  plotWidth = function(){input$PlotWidth}
  plotHeight1 = function(){input$PlotHeight1}
  plotWidth1 = function(){input$PlotWidth1}
  plotHeight2 = function(){input$PlotHeight2}
  plotWidth2 = function(){input$PlotWidth2}
  plotres = function(){input$PlotRes}
  plotres1 = function(){input$PlotRes1}
  plotres2 = function(){input$PlotRes2}

  ranges <- reactiveValues(x = NULL, y = NULL)
  ranges2 <- reactiveValues(x = NULL, y = NULL)
  comp_plot1 <- reactive({
    if(is.null(master())){return(NULL)}
    if(is.null(comp_subset1())){return(NULL)}

    if(input$only_annotated){
      comp_subset1 <- comp_subset1()[which(comp_subset1()$pathway.name %in% paste(module_annotations$Modulev2_Annotation,module_annotations$Module,sep=" ")),]
    }
    else{
      comp_subset1 <- comp_subset1()
    }

    ylow = c()
    yhigh = c()

    if(min(comp_subset1$low) < 0 & max(comp_subset1$up) > 0){
      if(abs(min(comp_subset1$low)) >= max(comp_subset1$up)){
        ylow = min(comp_subset1$low)
        yhigh = -min(comp_subset1$low)
      }
      else{
        ylow = -max(comp_subset1$up)
        yhigh = max(comp_subset1$up)
      }
    }

    if(min(comp_subset1$low) > 0){
      ylow = -max(comp_subset1$up)
      yhigh = max(comp_subset1$up)
    }

    if(max(comp_subset1$up) < 0){
      ylow = min(comp_subset1$low)
      yhigh = -min(comp_subset1$low)
    }

    if(length(input$set_comp1) > 1){
      if(min(comp_subset1$Log2FC) < 0 & max(comp_subset1$Log2FC) > 0){
        if(abs(min(comp_subset1$Log2FC)) >= max(comp_subset1$Log2FC)){
          ylow = min(comp_subset1$Log2FC)
          yhigh = -min(comp_subset1$Log2FC)
        }
        else{
          ylow = -max(comp_subset1$Log2FC)
          yhigh = max(comp_subset1$Log2FC)
        }
      }
      if(min(comp_subset1$Log2FC) > 0){
        ylow = -max(comp_subset1$Log2FC)
        yhigh = max(comp_subset1$Log2FC)
      }
      if(max(comp_subset1$Log2FC) < 0){
        ylow = min(comp_subset1$Log2FC)
        yhigh = -min(comp_subset1$Log2FC)
      }
    }

    comp_subset1$ylow = round(ylow,1)
    comp_subset1$yhigh = round(yhigh,1)

    if(length(input$set_comp1) > 1){
      n = length(input$set_comp1)
      if(input$graphics6 == FALSE){
        line_colors = c("blue", "red","green","lightskyblue","purple","hotpink","brown","gold")
      }
      else{
        line_colors = input$ColorChoice1
      }
      qusage_plot = ggplot(data = comp_subset1, aes(x = factor(Index), y = Log2FC, ymin = ylow, ymax = yhigh))
      qusage_plot = qusage_plot + scale_x_discrete(breaks = 1:length(comp_subset1$Index), labels = as.character.factor(comp_subset1$pathway.name[comp_subset1$Index]))
      qusage_plot = qusage_plot + xlab("Modules") + ylab("Pathway Activity")
      qusage_plot = qusage_plot + scale_colour_manual(values = line_colors) + geom_line(aes(colour = Comparison, group = Comparison), size = 1) + geom_hline(yintercept = 0, colour = "black", size = .5)
      qusage_plot = qusage_plot + geom_point(aes(shape = SIG), size = 2) + scale_shape_manual(values = c(16,8))
    }

    else{
      qusage_plot = qplot(x = pathway.name, y = Log2FC, data = comp_subset1, ymin = ylow, ymax = yhigh, ylab = "Pathway Activity", xlab = "Modules")
      qusage_plot = qusage_plot + geom_point() + geom_errorbar(data = comp_subset1, aes(x = pathway.name, y = Log2FC, ymin = low, ymax = up))
      qusage_plot = qusage_plot + geom_hline(yintercept = 0, colour = "red", size = 1)
    }

    qusage_plot = qusage_plot + theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) #+ coord_cartesian(xlim = ranges$x, ylim = ranges$y)
    return(qusage_plot)

  })


  individual_modplot <- reactive({
    if(is.null(master())){return(NULL)}
    if(is.null(individual_modselect())){return(NULL)}
    mmr_modselection <- individual_modselect()$mmr_modselection
    master <- individual_modselect()$master
    ylow = c()
    yhigh = c()
    if(min(mmr_modselection$lowerCI) < 0 & max(mmr_modselection$upperCI) > 0){
      if(abs(min(mmr_modselection$lowerCI)) >= max(mmr_modselection$upperCI)){
        ylow = min(mmr_modselection$lowerCI)
        yhigh = -min(mmr_modselection$lowerCI)
      }
      else{
        ylow = -max(mmr_modselection$upperCI)
        yhigh = max(mmr_modselection$upperCI)
      }
    }
    if(min(mmr_modselection$lowerCI) > 0){
      ylow = -max(mmr_modselection$upperCI)
      yhigh = max(mmr_modselection$upperCI)
    }
    if(max(mmr_modselection$upperCI) < 0){
      ylow = min(mmr_modselection$lowerCI)
      yhigh = -min(mmr_modselection$lowerCI)
    }
    mmr_modselection$ylow = round(ylow, 1)
    mmr_modselection$yhigh = round(yhigh, 1)
    mmr_modselection$Pathway.Activity = master$Log2FC
    mod_plot = ggplot(data = mmr_modselection, aes(x = Index, y = Log2FC, ymin = ylow, ymax = yhigh)) + xlim(0, length(mmr_modselection$Index))
    mod_plot = mod_plot + annotate("rect", xmin = -Inf, xmax = Inf, ymin = master$low, ymax = master$up, alpha = .3, fill = "lightblue")
    mod_plot = mod_plot + scale_x_discrete(limits = as.character(mmr_modselection$SYMBOL[mmr_modselection$Index]))
    mod_plot = mod_plot + geom_point()
    mod_plot = mod_plot + geom_errorbar(data = mmr_modselection, aes(x = Index, y = Log2FC, ymin = lowerCI, ymax = upperCI))
    mod_plot = mod_plot + xlab("Symbol ID") + ylab("Probe Level Fold Change") + theme_bw() +
               theme(axis.text.x = element_text(angle = 45, hjust = 1)) + geom_hline(yintercept = 0, colour = "red", size = 1)
    mod_plot = mod_plot + geom_hline(aes(yintercept = Pathway.Activity), linetype = "dashed",colour = "black") + theme(plot.margin = unit(c(1,10,0,0), "lines"))
    mod_plot = mod_plot + annotation_custom(textGrob(label = "Pathway Activity", hjust = 0), xmin = length(mmr_modselection$Index) + 1.08,
                                            xmax = length(mmr_modselection$Index) + 1.08, ymin = master$Log2FC, ymax = master$Log2FC)
    gt <- ggplot_gtable(ggplot_build(mod_plot))
    gt$layout$clip[gt$layout$name == "panel"] <- "off"
    gt
  })

  output$GeneSetTab <- renderDataTable({
    if(is.null(master())){return(NULL)}
    if(is.null(individual_modselect())){return(NULL)}
    y <- individual_modselect()$mmr_modselection
    y$SYMBOL <- paste("<a href=http://www.genecards.org/cgi-bin/carddisp.pl?gene=",y$SYMBOL," target = '_blank'",'>',y$SYMBOL,"</a>",sep='')
    y <- y[,-1]
    escape = FALSE
    y
  }, escape = FALSE)

  output$GeneSetPlot <- renderPlot({
    if(is.null(master())){return(NULL)}
    if(is.null(individual_modplot())){return(NULL)}
    grid.draw(individual_modplot())
  },width = plotWidth2, height = 400)

  output$CompOverview <- renderDataTable({
    if(is.null(master())){return(NULL)}
    comp_overview()
  })

  output$foldchange1 <- renderPlot({
    if(is.null(master())){return(NULL)}
    comp_plot1()
  }, width = plotWidth1, height = 400)

  output$venn <- renderUI({
    if(is.null(master())){return(NULL)}
    if(is.null(comp_subset1())){return(NULL)}
    if(length(venn.data()) == 1){return(NULL)}
    else{
      plotOutput("venndiagram")
    }
  })

  output$venn.download <- renderUI({
    if(is.null(master())){return(NULL)}
    if(is.null(comp_subset1())){return(NULL)}
    if(length(venn.data()) == 1){return(NULL)}
    else{
      downloadButton("downloadVenn2", "Download Figure")
    }
  })

  venn.d <- reactive({
    if(is.null(master())){return(NULL)}
    color.choices = c("blue", "red","green","lightskyblue","purple","hotpink","brown","gold")
    if(length(venn.data()) == 2){
      color.choices = color.choices[1:2]
    }
    if(length(venn.data()) == 3){
      color.choices = color.choices[1:3]
    }
    if(length(venn.data()) == 4){
      color.choices = color.choices[1:4]
    }
    if(length(venn.data()) == 5){
      color.choices = color.choices[1:5]
    }
    if(input$graphics6 == FALSE){
      return(VennDiagram::venn.diagram(venn.data(), filename = NULL, lwd = 1, col = color.choices, cat.cex = .9, fil = color.choices, margin = .12, ext.text = FALSE,
                          euler.d = TRUE))
    }
    else{
      return(VennDiagram::venn.diagram(venn.data(), filename = NULL, lwd = 1, col = input$ColorChoice1, cat.cex = .9, fil = input$ColorChoice1, margin = .12, ext.text = FALSE,
                          euler.d = TRUE))
    }
  })

  output$venndiagram <- renderPlot({
    if(is.null(comp_subset1())){return(NULL)}
    grid.draw(venn.d())
  })

  output$MultipleCompTab <- renderDataTable({
    if(is.null(master())){return(NULL)}
    if(input$only_annotated){
      if(is.null(values$BaylorTF)){
        comp_subset1 <- comp_subset1()[which(comp_subset1()$pathway.name %in% paste(module_annotations$Modulev2_Annotation,module_annotations$Module,sep=" ")),]
        comp_subset1$pathway.name <- as.character(comp_subset1$pathway.name)
        annot <- which(paste(module_annotations$Modulev2_Annotation,module_annotations$Module,sep=" ") %in% comp_subset1()$pathway.name)
      }
      else{
        if(values$BaylorTF == TRUE){
          comp_subset1 <- comp_subset1()[which(comp_subset1()$pathway.name %in% paste(module_annotations$Modulev2_Annotation,module_annotations$Module,sep=" ")),]
        }
        else{
          comp_subset1 <- comp_subset1()[which(comp_subset1()$pathway.name %in% module_annotations$Module),]
        }
      }
    }
    else{
      comp_subset1 <- comp_subset1()
    }
    comp_subset1 <- comp_subset1[,-c(1,11)]
    colnames(comp_subset1)[which(colnames(comp_subset1) == "p.Value")] <- "P.Value"
    comp_subset1[,c(1,9,2,3,4,8,5,6,7)]
  })

  output$downloadSigComps <- downloadHandler(

    filename = function() {paste(values$project_name,'_','Qusage_Sig_Comps_Table','.csv', sep='')  },
    content = function(file) {
      write.csv(comp_overview(), file,row.names = FALSE)
    }
  )

  output$downloadPlot2 <- downloadHandler(
    filename = function() {paste(values$project_name,'_','Multi_Comparisons_Plot','.png', sep = '')},
    content = function(file){
      png(file, width = (plotres1()/72)*plotWidth1(), height = (plotres1()/72)*480, res = plotres1())
      print(comp_plot1())
      dev.off()
    }
  )

  output$downloadVenn2 <- downloadHandler(
    filename = function() {paste(values$project_name,'_','Multi_Comparisons_Venn', '.png', sep = '')},
    content = function(file){
      png(file)
      grid.draw(venn.d())
      dev.off()
    }
  )

  output$downloadTable2 <- downloadHandler(
    filename = function() {paste(values$project_name,'_','Qusage_Data_Table_Multi_Comp','.csv', sep='')  },
    content = function(file) {
      comp_subset1 <- comp_subset1()[,-c(1,11)]
      comp_subset1 <- comp_subset1[,c(1,9,2,3,4,8,5,6,7)]
      write.csv(comp_subset1, file,row.names = FALSE)
    }
  )

  output$downloadPlot3 <- downloadHandler(
    filename = function() {paste(values$project_name,'_', 'Individual_GeneSet_Plot','.png', sep = '')},
    content = function(file){
      png(file, width = (plotres2()/72)*plotWidth2(), height = (plotres2()/72)*480, res = plotres2())
      grid.draw(individual_modplot())
      dev.off()
    }
  )

  output$downloadTable3 <- downloadHandler(
    filename = function() {paste(values$project_name,'_','Qusage_Individual_GeneSet_Data_Table','.csv', sep='')  },
    content = function(file) {
      write.csv(individual_modselect()$mmr_modselection[,-1], file,row.names = FALSE)
    }
  )

  ################### ROAST ############################

  output$roast <- renderMenu({
    if(is.null(values$roast_results)){
      return(strong(""))
    }
    if(is.null(values$roast_results) == FALSE){
      menuItem("Roast", icon = icon("th-list"), tabName = "roast")
    }
  })

  output$setStat <- renderUI({
    selectInput("setStat1", "Select gene set statistic:", choices = names(values$roast_results), selected = names(values$roast_results)[1])
  })

  roast.overview <- reactive({
    results <- values$roast_results[[which(names(values$roast_results) %in% input$setStat1)]]
    Comparison <- names(results)
    Raw <- FDR <- Bonf <- c()
    for(i in 1:length(results)){
      Bonferroni <- p.adjust(results[[i]]$PValue, method = "bonferroni")
      Raw[i] <- length(which(results[[i]]$PValue <= input$SigLevelR))
      FDR[i] <- length(which(results[[i]]$FDR <= input$SigLevelR))
      Bonf[i] <- length(which(Bonferroni <= input$SigLevelR))
    }
    overview <- data.frame(Comparison = Comparison, Raw = Raw, FDR = FDR, Bonf = Bonf)
    overview
  })

  roast.results <- reactive({
    results <- values$roast_results[[which(names(values$roast_results) %in% input$setStat1)]]
    for(i in 2:length(results)){
      results[[i]] <- results[[i]][match(rownames(results[[1]]), rownames(results[[i]]), nomatch = 0),]
    }
    Gene.set <- rownames(results[[1]])
    results <- do.call("cbind", results)
    results <- cbind(Gene.set, results)
    results
  })

  output$CompOverviewR <- renderDataTable({
    roast.overview()
  })

  ###################FLOW PART##########################

  output$flow.data <- renderMenu({
    if(is.null(values$flow_data)){
      return(strong(""))
    }
    else{
      return(menuItem("Flow", icon = icon("th-list"), tabName = "flow"))
    }
  })

  FlowMMR<-reactive({
    x<-values$flow_results
    return(x)
  })

  FClist <- reactive({
    fc_1 <- FlowMMR()[grep("P.Value", names(FlowMMR()))]
    fc_2 <- apply(fc_1, 2, p.adjust, method = "fdr")
    fc_3 <- apply(fc_1, 2, p.adjust, method = "bonferroni")
    sumfc <- function(alpha){
      Raw <- apply(fc_1, 2, function(x) sum(x[!is.na(x)] <= alpha))
      FDR <- apply(fc_2, 2, function(x) sum(x[!is.na(x)] <= alpha))
      Bonf <- apply(fc_3, 2, function(x) sum(x[!is.na(x)] <= alpha))
      sumfc <- rbind(Raw, FDR, Bonf)
      return(sumfc)
    }
    x <- t(sumfc(input$alphaFlow_1))
    y <- data.frame(Comparison = substring(rownames(x), 13), x)
    rownames(y) <- NULL
    y
  })

  output$FlowOverview <- renderDataTable({
    FClist()
  })

  output$downloadFC <- downloadHandler(
    filename = function() {paste0('Flow_Analysis_Overview-Significant_Probes_under_', input$alphaFlow_1, '.csv')  },
    content = function(file) {
      write.csv(FClist(), file,row.names = FALSE)
    }
  )

  output$CompF <- renderUI({
    nam <- names(FlowMMR())
    p.names <- substring(nam[grep("Estimate of ", nam, fixed = TRUE)], 13)
    selectInput("compflow", "Comparison Selection:", p.names, p.names[1])
  })

  output$flowlisttable <-renderDataTable({
    y <- callModule(filterOpts, "flowResultsTable", data = reactive(values$flow_results), comparison = reactive(input$compflow), data.type = "flow")
    return(y)
  })

  output$downloadFL <- downloadHandler(
    filename = function() {paste0('Flow_Analysis_Lists-', input$compflow, '_under_',  input$alphaFlow_2, '_', input$methodF, '.csv')  },
    content = function(file) {
      write.csv(flowlist(), file, row.names = FALSE)
    }
  )

  FlowData<-reactive({
    x <- values$flow_data
    subsetindex<-which(x[,which(names(x) %in% values$f_responder_var)] %in% input$FlowSub)
    x[subsetindex,]
  })

  FlowDataForDownload<-reactive({  if(input$FlowVarSet=="No Flow Data"){return(NULL)}
    x <- values$flow_data
    subsetindex<-which(x[,which(names(x) %in% values$f_responder_var)] %in% input$FlowSub)
    x[subsetindex,]
    x
  })

  output$FlowDataNames<-renderUI({
    selectInput("FlowPlotVars","Variable(s):",as.character(FlowMMR()$Flow.variable), multiple = TRUE, selected = as.character(FlowMMR()$Flow.variable)[1])
  })

  output$FlowSummary<-renderTable({
    x <- values$flow_results
    x[is.na(x)]<-1
    head(x)
  }, include.rownames = FALSE)

  output$flowmax<-renderUI({ numericInput("FlowMax","Max value to be plotted for time:",max(FlowData()[,which(names(FlowData()) %in% values$f_time_var)]))  })
  output$flowmin<-renderUI({ numericInput("FlowMin","Min value to be plotted for time:",min(FlowData()[,which(names(FlowData()) %in% values$f_time_var)]))  })
  output$flowsub<-renderUI({
    x <- values$flow_data
    y<-unique(as.character(x[,which(names(x) %in% values$f_responder_var)]))
    selectInput("FlowSub","Responder levels:",y,y[1:length(y)],multiple=TRUE)
  })

  flowplot <- reactive({
    if(length(input$FlowPlotVars) == 0){return(NULL)}
    if(length(input$FlowSub) == 0){return(NULL)}
    if(is.numeric(input$FlowMin) == FALSE & is.numeric(input$FlowMax) == FALSE){return(NULL)}
    mysummary<-function(x){
      y<-c(mean(x),sd(x),length(x))
      names(y)<-c("Mean","Sd","N")
      return(y)
    }
    
    mydata <- sum1 <- summaries <- result <- myplot <- list()
    for(i in 1:length(input$FlowPlotVars)){
      if(!input$FlowTransform){
        mydata[[i]] <- data.frame(FlowVar=FlowData()[,which(names(FlowData()) %in% input$FlowPlotVars[i])],
                                  time=FlowData()[,which(names(FlowData()) %in% values$f_time_var)],
                                  subjectid=FlowData()[,which(names(FlowData()) %in% values$f_patient_id)],
                                  responder=FlowData()[,which(names(FlowData()) %in% values$f_responder_var)])
      } else{
        mydata[[i]] <- data.frame(FlowVar=log2(FlowData()[,which(names(FlowData()) %in% input$FlowPlotVars[i])]),
                                  time=FlowData()[,which(names(FlowData()) %in% values$f_time_var)],
                                  subjectid=FlowData()[,which(names(FlowData()) %in% values$f_patient_id)],
                                  responder=FlowData()[,which(names(FlowData()) %in% values$f_responder_var)])
      }
      sum1[[i]] <- aggregate(FlowVar~responder+time, data=mydata[[i]], mysummary)
      summaries[[i]] <- sum1[[i]][,3]
      result[[i]] <- as.data.frame(cbind(sum1[[i]][,c(1,2)],summaries[[i]]))
      names(result[[i]])<-c("ResponderStatus","Time",colnames(summaries[[i]]))
      myplot[[i]] <- ggplot(data=result[[i]],aes(x=Time, y=Mean,group=ResponderStatus,colour=ResponderStatus))+geom_point()+geom_line(aes(size=.7))+
        geom_errorbar(aes(ymin = Mean - 2*Sd, ymax = Mean + 2*Sd,size=.7)) +
        scale_size(range=c(.1, 2),guide=FALSE)+ xlim(input$FlowMin, input$FlowMax)+ggtitle(input$FlowPlotVars[i])
      if(input$FlowSamples){
        myplot[[i]] <- myplot[[i]] + geom_point(data=mydata[[i]],aes(x=time,y=FlowVar,group=subjectid,colour=responder,size=1))+
          geom_line(data=mydata[[i]],aes(x=time,y=FlowVar,group=subjectid,colour=responder,size=.25))
      } 
    }
    z <- do.call(multiplot, c(myplot, cols = 2))
    return(z)
  })

  flowplot2 <- reactive({
    if(length(input$FlowPlotVars) == 0){return(NULL)}
    mydata <- dummy <- index <- myplot <- list()
    for(i in 1:length(input$FlowPlotVars)){
      if(!input$FlowTransform){
        mydata[[i]] <- data.frame(FlowVar=FlowData()[,which(names(FlowData()) %in% input$FlowPlotVars[i])],
                                  time=FlowData()[,which(names(FlowData()) %in% values$f_time_var)],
                                  subjectid=FlowData()[,which(names(FlowData()) %in% values$f_patient_id)],
                                  responder=FlowData()[,which(names(FlowData()) %in% values$f_responder_var)])
      } else{
        mydata[[i]] <- data.frame(FlowVar=log2(FlowData()[,which(names(FlowData()) %in% input$FlowPlotVars[i])]),
                                  time=FlowData()[,which(names(FlowData()) %in% values$f_time_var)],
                                  subjectid=FlowData()[,which(names(FlowData()) %in% values$f_patient_id)],
                                  responder=FlowData()[,which(names(FlowData()) %in% values$f_responder_var)])
      }
      mydata[[i]] <- mydata[[i]][order(mydata[[i]]$time,mydata[[i]]$responder),]
      mydata[[i]]$time<-factor(mydata[[i]]$time,ordered=T)
      mydata[[i]]$Time_Responder<-factor(paste(mydata[[i]]$time,mydata[[i]]$responder,sep="_"),ordered=T)
      dummy[[i]] <- data.frame(do.call(rbind,strsplit(levels(mydata[[i]]$Time_Responder),"_")))
      index[[i]] <- order(as.numeric(as.character(dummy[[i]]$X1)))
      mydata[[i]]$Time_Responder<-factor(paste(mydata[[i]]$time,mydata[[i]]$responder,sep="_"),levels(mydata[[i]]$Time_Responder)[index[[i]]])
      if(input$flowbox){
        myplot[[i]] <- ggplot(data=mydata[[i]],aes(x=time,y=FlowVar,fill=responder,colour=responder)) + geom_boxplot(position = position_dodge(width = .9)) + 
          ggtitle(input$FlowPlotVars[i])
      } else{
        myplot[[i]] <- ggplot(data=mydata[[i]],aes(x=Time_Responder,y=FlowVar,fill=responder,colour=responder)) + geom_point() + 
          theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(input$FlowPlotVars[i])
      }
    }
    z <- do.call(multiplot, c(myplot, cols = 2))
    return(z)
  })

  output$FlowPlot<-renderPlot({
    print(flowplot())
  })

  output$FlowPlot2<-renderPlot({
    print(flowplot2())
  })

  FlowPlotSummary1<-reactive({
    if(length(input$FlowPlotVars) == 0){return(NULL)}
    if(length(input$FlowSub) == 0){return(NULL)}
    mysummary<-function(x){
      y<-c(mean(x),sd(x),length(x))
      names(y)<-c("Mean","Sd","N")
      return(y)
    }
    
    mydata <- sum1 <- summaries <- result <- list()
    FlowVariable <- c()
    for(i in 1:length(input$FlowPlotVars)){
      if(!input$FlowTransform){
        mydata[[i]] <- data.frame(FlowVar=FlowData()[,which(names(FlowData()) %in% input$FlowPlotVars[i])],
                                  time=FlowData()[,which(names(FlowData()) %in% values$f_time_var)],
                                  subjectid=FlowData()[,which(names(FlowData()) %in% values$f_patient_id)],
                                  responder=FlowData()[,which(names(FlowData()) %in% values$f_responder_var)])
      } else{
        mydata[[i]] <- data.frame(FlowVar=log2(FlowData()[,which(names(FlowData()) %in% input$FlowPlotVars[i])]),
                                  time=FlowData()[,which(names(FlowData()) %in% values$f_time_var)],
                                  subjectid=FlowData()[,which(names(FlowData()) %in% values$f_patient_id)],
                                  responder=FlowData()[,which(names(FlowData()) %in% values$f_responder_var)])
      }
      sum1[[i]] <- aggregate(FlowVar~responder+time, data=mydata[[i]], mysummary)
      summaries[[i]] <- sum1[[i]][,3]
      result[[i]] <- as.data.frame(cbind(sum1[[i]][,c(1,2)],summaries[[i]]))
      names(result[[i]])<-c("ResponderStatus","Time",colnames(summaries[[i]]))
      FlowVariable <- c(FlowVariable, rep(input$FlowPlotVars[i], length(result[[i]][,i])))
    }
    
    z <- do.call(rbind, result)
    z <- cbind(FlowVariable, z)
    return(z)
  })

  output$FlowPlotSummary<-renderDataTable({
    FlowPlotSummary1()
  })

  output$downloadFlowResults <- downloadHandler(
    filename = function() {paste(values$project_name,'_',input$comparisonflow,'.csv', sep='')  },
    content = function(file) {
      write.csv(FlowMMR(), file,row.names = FALSE)
    }
  )

  output$downloadFlowData <- downloadHandler(
    filename = function() {paste(values$project_name,'_FlowData','.csv', sep='')  },
    content = function(file) {
      write.csv(FlowDataForDownload(), file, row.names = FALSE)
    }
  )

  output$downloadFlowSummaries <- downloadHandler(
    filename = function() {paste(values$project_name,'_',"FlowSummary_",input$FlowPlotVars[1],'.csv', sep='')  },
    content = function(file) {
      write.csv(FlowPlotSummary1(), file, row.names = FALSE)
    }
  )

  output$downloadFlowPlot <- downloadHandler(
    filename = function() {paste(values$project_name,'_','FlowPlot1','.png', sep = '')},
    content = function(file){
      png(file, width = 900)
      print(flowplot())
      dev.off()
    }
  )

  output$downloadFlowPlot2 <- downloadHandler(
    filename = function() {paste(values$project_name,'_','FlowPlot2','.png', sep = '')},
    content = function(file){
      png(file, width = 900)
      print(flowplot2())
      dev.off()
    }
  )


  ###############END OF FLOW PART####################

  ############### METABOLOMICS PART #################

  output$metab.data <- renderMenu({
    if(is.null(values$metab_data)){
      return(strong(""))
    }
    else{
      return(menuItem("Metab", icon = icon("th-list"), tabName = "metab2",
                      menuSubItem("PCA", tabName = "pcaM"),
                      menuSubItem("Differential Analysis", tabName = "metab")))
    }
  })

  MetabMMR<-reactive({
    x <- values$metab_results
    return(x)
  })

  Mlist <- reactive({
    fc_1 <- MetabMMR()[grep("P.Value", names(MetabMMR()), fixed = TRUE)]
    fc_2 <- apply(fc_1, 2, p.adjust, method = "fdr")
    fc_3 <- apply(fc_1, 2, p.adjust, method = "bonferroni")
    sumfc <- function(alpha){
      Raw <- apply(fc_1, 2, function(x) sum(x[!is.na(x)] <= alpha))
      FDR <- apply(fc_2, 2, function(x) sum(x[!is.na(x)] <= alpha))
      Bonf <- apply(fc_3, 2, function(x) sum(x[!is.na(x)] <= alpha))
      sumfc <- rbind(Raw, FDR, Bonf)
      return(sumfc)
    }
    x <- t(sumfc(input$alphaMetab_1))
    y <- data.frame(Comparison = substring(rownames(x), 13), x)
    rownames(y) <- NULL
    y
  })

  output$MetabOverview <- renderDataTable({
    Mlist()
  })

  output$downloadFC2 <- downloadHandler(
    filename = function() {paste0('Metab_Analysis_Overview-Significant_Probes_under_', input$alphaMetab_1, '.csv')  },
    content = function(file) {
      write.csv(Mlist(), file,row.names = FALSE)
    }
  )

  output$CompM <- renderUI({
    nam <- names(MetabMMR())
    p.names <- substring(nam[grep("Estimate of ", nam, fixed = TRUE)], 13)
    selectInput("compmetab", "Comparison Selection:", p.names, p.names[1])
  })

  metablist <- reactive({
    dat <- MetabMMR()
    x <- flowlistmaker(dat, input$compmetab, input$alphaMetab_2, input$methodM)
    dummy <- data.frame("No Variables Present")
    names(dummy) <- "Metab_Variable"
    if(identical(x,dummy)){return(x)}
    else{
      ind1 <- grep("Estimate", names(x), fixed = TRUE)
      ind2 <- grep("Test.statistic", names(x), fixed = TRUE)
      ind3 <- grep("P.Value", names(x), fixed = TRUE)
      ind4 <- grep("FDR", names(x), fixed = TRUE)
      ind5 <- grep("BONF", names(x), fixed = TRUE)
      x <- x[,c(1,ind1, ind2, ind3, ind4, ind5)]
      names(x) <- c("Metab_Variable","Estimate", "Test.statistic", "P.Value", "FDR", "BONF")
      return(x)
    }
  })

  output$metablisttable <-renderDataTable({
    if(is.null(metablist())){return(NULL)}
    metablist()
  })

  output$downloadME <- downloadHandler(
    filename = function() {paste0('Metab_Analysis_Lists-', input$compmetab, '_under_',  input$alphaMetab_2, '_', input$methodM, '.csv')  },
    content = function(file) {
      write.csv(metablist(), file, row.names = FALSE)
    }
  )

  MetabData<-reactive({
    x <- values$metab_data
    subsetindex<-which(x[,which(names(x) %in% values$m_responder_var)] %in% input$MetabSub)
    x[subsetindex,]
  })

  MetabDataForDownload<-reactive({
    x <- values$metab_data
    subsetindex<-which(x[,which(names(x) %in% values$m_responder_var)] %in% input$MetabSub)
    x[subsetindex,]
    x
  })

  MetabResult <- reactive({
    MetabMMR()
  })

  output$MetabResultTable<-renderDataTable({
    head(MetabResult())
  })

  output$MetabDataNames<-renderUI({
    selectInput("MetabPlotVars","Variable(s):",as.character(MetabMMR()$Metab.variable), multiple = TRUE, selected = as.character(MetabMMR()$Metab.variable)[1])
  })

  output$pcaAnnotM <- renderUI({
    dat <- values$metab_data
    num <- sapply(dat, is.numeric)
    groups <- dat[,which(num == FALSE),drop = FALSE]
    selectInput("pcaAnnot2M", "Select grouping factor:", colnames(groups), selected = colnames(groups)[which(colnames(groups) %in% values$m_responder_var)])
  })

  output$pcaAnnotValsM <- renderUI({
    dat <- values$metab_data
    num <- sapply(dat, is.numeric)
    groups <- dat[,which(num == FALSE),drop = FALSE]
    values <- unique(groups[,input$pcaAnnot2M])
    selectInput("pcaAnnValsM", "Select grouping factor values:", values, selected = values, multiple = TRUE)
  })

  output$pcaBlockingM <- renderUI({
    if(is.null(values$m_time_var)){return(NULL)}
    dat <- values$metab_data
    selectInput("pcaBlockM", "PCA by time:", c("All timepoints", unique(dat[,values$m_time_var])), selected = "All timepoints")
  })

  PCAM <- reactive({
    dat <- values$metab_data
    if(!is.null(values$m_time_var)){
      if(input$pcaBlockM == "All timepoints"){
        metabDat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM),which(colnames(dat) %in% as.character(MetabMMR()$Metab.variable))]
        dat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM),]
      }
      else{
        metabDat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM & dat[,values$m_time_var] %in% input$pcaBlockM),which(colnames(dat) %in% as.character(MetabMMR()$Metab.variable))]
        dat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM & dat[,values$m_time_var] %in% input$pcaBlockM),]
      }
    }
    else{
      metabDat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM),which(colnames(dat) %in% as.character(MetabMMR()$Metab.variable))]
      dat <- dat[which(dat[,input$pcaAnnot2M] %in% input$pcaAnnValsM),]
    }
    sds <- sapply(metabDat, sd)
    if(length(which(sds == 0)) > 0){
      metabDat <- metabDat[,-which(sds == 0)]
    }
    pca <- prcomp(metabDat, scale = TRUE)
    z <- list(dat = dat, pca = pca)
  })

  PCAdatM <- reactive({
    pca <- PCAM()$pca
    dat <- PCAM()$dat
    num <- sapply(dat, is.numeric)
    groups = dat[,which(num == FALSE),drop = FALSE]
    annotations <- groups[,input$pcaAnnot2M]
    pcs <- data.frame(pca$x, annotations)
    colnames(pcs)[ncol(pcs)] <- "Group"
    pcs
  })

  plotw.pcaM <- function(){
    input$PlotWidthPCAM
  }

  ploth.pcaM <- function(){
    input$PlotHeightPCAM
  }

  observeEvent(input$showM, {
    shinyjs::toggle("screePlot2M")
  })

  output$screePlotM <- renderUI({
    plotOutput("screePlot2M")
  })

  output$PCAplot3dM <- renderUI({
    if(input$PCSnumM != 3){
      return(NULL)
    }
    else{
      return(plotOutput("pcaPlot3dM"))
    }
  })

  output$screePlot2M <- renderPlot({
    dat <- as.data.frame(summary(PCAM()$pca)[[length(summary(PCAM()$pca))]])
    dat <- as.data.frame(t(dat))
    dat <- cbind(PC = rownames(dat), dat)
    dat[,2] <- NULL
    dat <- reshape2::melt(dat, id = "PC")
    dat$PC <- factor(dat$PC, levels = dat$PC)
    p <- ggplot(data = dat[which(dat$PC %in% levels(dat$PC)[1:10]),], aes(x = PC, y = value, group = variable)) + geom_line(size = 1.5, aes(colour = variable))
    p <- p + geom_point(size = 3, shape = 21, fill = "white") + ylim(0,1) + ylab("Proportion of Variance") + theme_minimal()
    p
  })


  output$PCAplotM <- renderPlot({
    qplot(PC1, PC2, data = PCAdatM(), colour = Group, size = I(input$CircleSizePCAM))
  }, width = plotw.pcaM, height = ploth.pcaM)

  output$pcaPlot3dM <- renderPlot({
    pca3d::pca3d(PCAM()$pca, group = PCAdatM()$Group, bg = "black", legend = "topright")
  })

  output$MetabSummary<-renderTable({
    x <- values$metab_results
    x[is.na(x)]<-1
    head(x)
  }, include.rownames = FALSE)

  output$metabmax<-renderUI({ numericInput("MetabMax","Max value to be plotted for time:",max(MetabData()[,which(names(MetabData()) %in% values$m_time_var)]))  })
  output$metabmin<-renderUI({ numericInput("MetabMin","Min value to be plotted for time:",min(MetabData()[,which(names(MetabData()) %in% values$m_time_var)]))  })
  output$metabsub<-renderUI({
    x<-values$metab_data
    y<-unique(as.character(x[,which(names(x) %in% values$m_responder_var)]))
    selectInput("MetabSub","Responder levels:",y,y[1:length(y)],multiple=TRUE)
  })

  metabplot <- reactive({
    if(length(input$MetabPlotVars) == 0){return(NULL)}
    if(length(input$MetabSub) == 0){return(NULL)}
    if(is.numeric(input$MetabMin) == FALSE & is.numeric(input$MetabMax) == FALSE){return(NULL)}
    
    mysummary<-function(x){
      y<-c(mean(x),sd(x),length(x))
      names(y)<-c("Mean","Sd","N")
      return(y)
    }
    
    mydata <- sum1 <- summaries <- result <- myplot <- list()
    for(i in 1:length(input$MetabPlotVars)){
      if(!input$MetabTransform){
        mydata[[i]] <- data.frame(MetabVar=MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])],
                                  time=MetabData()[,which(names(MetabData()) %in% values$m_time_var)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% values$m_patient_id)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      } else{
        mydata[[i]] <- data.frame(MetabVar=log2(MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])]),
                                  time=MetabData()[,which(names(MetabData()) %in% values$m_time_var)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% values$m_patient_id)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      }
      sum1[[i]] <- aggregate(MetabVar~responder+time, data=mydata[[i]], mysummary)
      summaries[[i]] <- sum1[[i]][,3]
      result[[i]] <- as.data.frame(cbind(sum1[[i]][,c(1,2)],summaries[[i]]))
      names(result[[i]])<-c("ResponderStatus","Time",colnames(summaries[[i]]))
      myplot[[i]] <- ggplot(data=result[[i]],aes(x=Time, y=Mean,group=ResponderStatus,colour=ResponderStatus))+geom_point()+geom_line(aes(size=.7))+
        geom_errorbar(aes(ymin = Mean - 2*Sd, ymax = Mean + 2*Sd,size=.7)) +
        scale_size(range=c(.1, 2),guide=FALSE)+ xlim(input$MetabMin, input$MetabMax)+ggtitle(input$MetabPlotVars[i])
      if(input$MetabSamples){
        myplot[[i]] <- myplot[[i]] + geom_point(data=mydata[[i]],aes(x=time,y=MetabVar,group=subjectid,colour=responder,size=1))+
          geom_line(data=mydata[[i]],aes(x=time,y=MetabVar,group=subjectid,colour=responder,size=.25))
      }
    }
    z <- do.call(multiplot, c(myplot, cols = 2))
    return(z)
  })

  metabplot2 <- reactive({
    if(length(input$MetabPlotVars) == 0){return(NULL)}
    mydata <- dummy <- index <- myplot <- list()
    for(i in 1:length(input$MetabPlotVars)){
      if(!input$MetabTransform){
        mydata[[i]] <- data.frame(MetabVar=MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])],
                                          time=MetabData()[,which(names(MetabData()) %in% values$m_time_var)],
                                          subjectid=MetabData()[,which(names(MetabData()) %in% values$m_patient_id)],
                                          responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      } else{
        mydata[[i]] <- data.frame(MetabVar=log2(MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])]),
                                  time=MetabData()[,which(names(MetabData()) %in% values$m_time_var)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% values$m_patient_id)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      }
      mydata[[i]] <- mydata[[i]][order(mydata[[i]]$time,mydata[[i]]$responder),]
      mydata[[i]]$time<-factor(mydata[[i]]$time,ordered=T)
      mydata[[i]]$Time_Responder<-factor(paste(mydata[[i]]$time,mydata[[i]]$responder,sep="_"),ordered=T)
      dummy[[i]] <- data.frame(do.call(rbind,strsplit(levels(mydata[[i]]$Time_Responder),"_")))
      index[[i]] <- order(as.numeric(as.character(dummy[[i]]$X1)))
      mydata[[i]]$Time_Responder<-factor(paste(mydata[[i]]$time,mydata[[i]]$responder,sep="_"),levels(mydata[[i]]$Time_Responder)[index[[i]]])
      if(input$metabbox){
        myplot[[i]] <- ggplot(data=mydata[[i]],aes(x=time,y=MetabVar,fill=responder,colour=responder)) + geom_boxplot(position = position_dodge(width = .9)) + 
          ggtitle(input$MetabPlotVars[i])
      } else{
        myplot[[i]] <- ggplot(data=mydata[[i]],aes(x=Time_Responder,y=MetabVar,fill=responder,colour=responder)) + geom_point() + 
          theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(input$MetabPlotVars[i])
      }
    }
    z <- do.call(multiplot, c(myplot, cols = 2))
    return(z)
  })

  output$MetabPlot<-renderPlot({
    print(metabplot())
  })

  output$MetabPlot2<-renderPlot({
    print(metabplot2())
  })

  MetabPlotSummary1<-reactive({
    if(length(input$MetabPlotVars) == 0){return(NULL)}
    if(length(input$MetabSub) == 0){return(NULL)}
    
    mysummary<-function(x){
      y<-c(mean(x),sd(x),length(x))
      names(y)<-c("Mean","Sd","N")
      return(y)
    }
    
    mydata <- sum1 <- summaries <- result <- list()
    MetabVariable <- c()
    for(i in 1:length(input$MetabPlotVars)){
      if(!input$MetabTransform){
        mydata[[i]] <- data.frame(MetabVar=MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])],
                                  time=MetabData()[,which(names(MetabData()) %in% values$m_time_var)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% values$m_patient_id)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      } else{
        mydata[[i]] <- data.frame(MetabVar=log2(MetabData()[,which(names(MetabData()) %in% input$MetabPlotVars[i])]),
                                  time=MetabData()[,which(names(MetabData()) %in% values$m_time_var)],
                                  subjectid=MetabData()[,which(names(MetabData()) %in% values$m_patient_id)],
                                  responder=MetabData()[,which(names(MetabData()) %in% values$m_responder_var)])
      }
      sum1[[i]] <- aggregate(MetabVar~responder+time, data=mydata[[i]], mysummary)
      summaries[[i]] <- sum1[[i]][,3]
      result[[i]] <- as.data.frame(cbind(sum1[[i]][,c(1,2)],summaries[[i]]))
      names(result[[i]])<-c("ResponderStatus","Time",colnames(summaries[[i]]))
      MetabVariable <- c(MetabVariable, rep(input$MetabPlotVars[i], length(result[[i]][,i])))
    }
    
    z <- do.call(rbind, result)
    z <- cbind(MetabVariable, z)
    return(z)
  })

  output$normMetab<-renderUI({

    if(is.null(values$h3_rowdendro)){
      if(values$m_hc == TRUE){
        try<-list("Baseline Median Normalized" = 1,
                  "Baseline Healthy Normalized" = 2)
      }

      if(values$m_hc == FALSE){
        try<-list("Baseline Median Normalized" = 1)
      }
    }

    if(!is.null(values$h3_rowdendro)){
      if(values$m_hc == TRUE){
        try<-list("Baseline Median Normalized" = 1,
                  "Baseline Healthy Normalized" = 2,
                  "All Samples Median Normalized" = 3,
                  "All Samples Healthy Normalized"=4,
                  "All Samples Baseline Normalized"=5)
      }

      if(values$m_hc == FALSE){
        try<-list("Baseline Median Normalized" = 1,
                  "All Samples Median Normalized" = 3,
                  "All Samples Baseline Normalized"=5)
      }
    }

    selectInput("set3", "Select heatmap:",as.list(try))
  })

  design <- reactive({
    values$m_design
  })

  heatmapdatam <-reactive({
    design <- values$m_design
    metabdat <- values$metab_data
    metabvars <- as.character(values$metab_results$Metab.variable)
    final_expression = metabdat[,which(colnames(metabdat) %in% metabvars)]
    final_expression <- final_expression[,match(metabvars, colnames(final_expression), nomatch = 0)]
    rownames(final_expression) <- as.character(design$columnname)
    final_expression <- as.data.frame(t(final_expression))
    metabvars <- metabvars[match(rownames(final_expression), metabvars,nomatch = 0)]
    PROBE_ID <- as.character(metabvars)
    SYMBOL <- as.character(metabvars)
    final_expression <- log2(final_expression)
    final_expression <- do.call("cbind", list(PROBE_ID = PROBE_ID,SYMBOL=SYMBOL, final_expression))
    final_expression <- final_expression[which(final_expression$PROBE_ID %in% metablist()[,1]),]

    if (input$set3==1){#heatmapbase1
      base_sample_name=design$columnname[design[,m_baseline_var]==values$m_baseline_val]
      ind1<-which(colnames(final_expression)%in%c("PROBE_ID","SYMBOL"))
      ind2<-which(colnames(final_expression)%in%base_sample_name)
      exp_base_sam=final_expression[,c(ind1,ind2)]
      des_base_sam=design[which(design$columnname%in%colnames(exp_base_sam)),]
      y<-data.manipulate(exp=exp_base_sam,des=des_base_sam,values$m_baseline_val,longitudinal=FALSE,lg2=FALSE,keepbase=TRUE,format="Probes",allsamples=TRUE)
    }

    if (input$set3==2){
      base_sample_name=design$columnname[design[,m_baseline_var]==values$m_baseline_val]
      ind1<-which(colnames(final_expression)%in%c("PROBE_ID","SYMBOL"))
      ind2<-which(colnames(final_expression)%in%base_sample_name)
      exp_base_sam=final_expression[,c(ind1,ind2)]
      des_base_sam=design[which(design$columnname%in%colnames(exp_base_sam)),]
      y<-data.manipulate(exp=exp_base_sam,des=des_base_sam,values$m_control_var,values$m_control_val,longitudinal=FALSE,subjects,lg2=FALSE,keepbase=TRUE,format="Probes",allsamples=FALSE)
    }
    if (input$set3==3){
      y<-data.manipulate(exp=final_expression,des=design[which(design$columnname %in% colnames(final_expression)),],values$m_baseline_var,values$m_baseline_val,longitudinal=FALSE,subjects,lg2=FALSE,keepbase=TRUE,format="Probes",allsamples=TRUE)
    }
    if (input$set3==4){
      y<-data.manipulate(exp=final_expression,des=design[which(design$columnname %in% colnames(final_expression)),],values$m_control_var,values$m_control_val,longitudinal=FALSE,subjects,lg2=FALSE,keepbase=TRUE,format="Probes",allsamples=FALSE)
    }
    if (input$set3==5){#heatmap3
      if(values$m_hc==TRUE){
        des_w_controls<-design[which(design$columnname %in% colnames(final_expression)),]
        des_wo_controls<-design[-which(design[,values$m_control_var]==values$m_control_val),]
        h5index<-c(1,2,which(colnames(final_expression) %in% des_wo_controls$columnname))
        y<-data.manipulate(exp=final_expression[,h5index],des=des_wo_controls,values$m_baseline_var,values$m_baseline_val,longitudinal=TRUE,subjects=values$m_patient_id,lg2=FALSE,keepbase=FALSE,format="Probes",allsamples=FALSE)
      }
      if(values$m_hc==FALSE){
        y<-data.manipulate(exp=final_expression,des=design[which(design$columnname %in% colnames(final_expression)),],values$m_baseline_var,values$m_baseline_val,longitudinal=TRUE,subjects=values$m_patient_id,lg2=FALSE,keepbase=FALSE,format="Probes",allsamples=FALSE)
      }
    }
    z<-list(y=y)
    return(z)
  })

  heatmapnamem<-reactive({
    if(input$set3==1) heattxt<-"Baseline Median Normalized"
    if(input$set3==2) heattxt<-"Baseline Healthy Normalized"
    if(input$set3==3) heattxt<-"All Samples Median Normalized"
    if(input$set3==4) heattxt<-"All Samples Healthy Normalized"
    if(input$set3==5) heattxt<-"All Samples Normalized to each Subjects Baseline"
    heattxt
  })

  metabGraphParams <- eventReactive(input$go4, {
    params <- callModule(graphOptions, "metabGraphOptions")
    width <- params$width
    height <- params$height
    fontSize <- params$fontSize
    legendSize <- params$legendSize
    treeHeight <- params$treeHeight
    resolution <- params$resolution
    params <- list(width = width, height = height, fontSize = fontSize, legendSize = legendSize, treeHeight = treeHeight, resolution = resolution)
    return(params)
  })
  
  metabPlotWidth <- function(){metabGraphParams()$width}
  metabPlotHeight <- function(){metabGraphParams()$height}
  
  callModule(subsetAndOrderRenderUI, "metabSubOrder", des = reactive(values$m_design), groupingVar = reactive(values$m_responder_var))
  
  metabRowCluster <- eventReactive(input$go4, {
    x <- heatmapdatam()$y$heatexp 
    ddm <- NA
    if(input$metabRowCluster){
      dist <- dist(x)
      hcl <- fastcluster::hclust(dist)
      ddm <- as.dendrogram(hcl)
      Rowv <- rowMeans(x, na.rm = TRUE)
      ddm <- reorder(ddm, Rowv)
    }
    labelRows <- NULL
    y <- list(x = x, ddm = ddm, labelRows = labelRows)
    return(y)
  })
  
  metabClusterData <- eventReactive(input$go4,{
    x <- callModule(colCluster, "metabCluster", des = reactive(metabOrderedData()$colAnnot), data = reactive(metabOrderedData()$x))
    return(x)
  })
  
  metabOrderedData <- reactive({
    dat <- callModule(subsetAndOrder, "metabSubOrder", des = reactive(heatmapdatam()$y$heatdes), data = reactive(metabRowCluster()$x), 
                      sampleAnnot = reactive(values$m_sample_id), groupingVar = reactive(values$m_responder_var))
    x <- dat$dat
    colAnnot <- dat$colAnnot
    design <- dat$design
    z <- list(x = x, colAnnot = colAnnot, design = design)
    return(z)
  })
  
  metabMaxRangeData <- eventReactive(input$go4, {
    x <- callModule(maxValues, "metabMaxValues", reactive(metabOrderedData()$x))
    return(x)
  })
  
  metabHeatColors <- eventReactive(input$go4, {
    x <- callModule(annColors, "metabSubOrder", reactive(metabOrderedData()$colAnnot))
    return(x)
  })
  
  output$heatmapm <- renderPlot({
    withProgress(message = 'Making plot',
                 detail = 'This may take a while...', value = 1,{
                   aheatmap2(metabMaxRangeData(),Rowv = metabRowCluster()$ddm,Colv = metabClusterData()$colddm, treeheight = metabGraphParams()$treeHeight, fontsize = metabGraphParams()$fontSize, cexRow = 1.2, 
                             annheight = metabGraphParams()$legendSize,color = colorRampPalette(c("navy", "yellow", "firebrick3"))(100),annCol = metabClusterData()$colAnnot,annColors = metabHeatColors(),labRow=metabRowCluster()$labelRows,
                             breaks=0)
                 }
    )
  }, width = metabPlotWidth, height = metabPlotHeight)
  

  output$downloadHeatmapm <- downloadHandler(
    filename = function() {paste('SignificantMetab_Heatmap','.png', sep = '')},
    content = function(file){
      x <- expression_matrixm()$x
      if(input$setcutoff2!=0){
        cut1<-as.numeric(input$setcutoff2)
        x[x>cut1]<-cut1
        x[x<(-cut1)]<--cut1
      }
      png(file, width = plotsize_mW(), height = plotsize_mH(), res = resolutionm())
      print(aheatmap2(x,Rowv=TRUE,Colv=opt_numClustm()$colddm,cexRow=1.2, treeheight = input$Metab_TreeHeight, fontsize = input$Metab_FontSize, annheight = input$Metab_LegendSize, color = colorRampPalette(c("navy", "yellow", "firebrick3"))(50),annCol = heatmap_colorsm()$groups,annColors= heatmap_colorsm()$first_color,labRow=NA,breaks=0))
      dev.off()
    }
  )

  heatmap_download2M <- reactive({
    heatmapdata <- cbind(expression_matrix2()$symb, expression_matrix2()$y$heatexp)
    heatmapdata <- cbind(expression_matrix2()$probeids, heatmapdata)
    return(heatmapdata)
  })

  output$downloadHeatmap1 <- downloadHandler(
    filename = function() {paste(values$project_name,'_',heatmapname1(),'.csv', sep='')  },
    content = function(file) {
      write.csv(heatmap_download2M(), file, row.names = FALSE)
    }
  )

  output$MetabPlotSummary<-renderDataTable({
    MetabPlotSummary1()
  })

  output$downloadMetabResults <- downloadHandler(
    filename = function() {paste(values$project_name,'_',input$comparisonmetab,'.csv', sep='')  },
    content = function(file) {
      write.csv(MetabResult(), file,row.names = FALSE)
    }
  )

  output$downloadMetabData <- downloadHandler(
    filename = function() {paste(values$project_name,'_MetabData','.csv', sep='')  },
    content = function(file) {
      write.csv(MetabDataForDownload(), file, row.names = FALSE)
    }
  )

  output$downloadMetabSummaries <- downloadHandler(
    filename = function() {paste(values$project_name,'_',"MetabSummary_",input$MetabPlotVars[1],'.csv', sep='')  },
    content = function(file) {
      write.csv(MetabPlotSummary1(), file, row.names = FALSE)
    }
  )

  output$downloadMetabPlot <- downloadHandler(
    filename = function() {paste(values$project_name,'_','MetabPlot1','.png', sep = '')},
    content = function(file){
      png(file, width = 900)
      print(metabplot())
      dev.off()
    }
  )

  output$downloadMetabPlot2 <- downloadHandler(
    filename = function() {paste(values$project_name,'_','MetabPlot2','.png', sep = '')},
    content = function(file){
      png(file, width = 900)
      print(metabplot2())
      dev.off()
    }
  )

  ############# END OF METABOLOMICS PART ################

###############Correlations########################

  output$correlations <- renderMenu({
    if(is.null(values$correlations)){
      #return(menuItem(strong("Flow", style = "color:red"), tabName = ""))
      return(strong(""))
    }
    else{
      return(menuItem("Correlations", icon = icon("bolt"), tabName = "corr"))
    }
  })

  output$TypeVariable <- renderUI({
    selectInput("TypeVariable1", "Choose type:", choices = values$correlation_names, selected = values$correlation_names[1])
  })

  output$TypeVariable2 <- renderUI({
    selectInput("TypeVariable3", "Choose type:", choices = values$correlation_names, selected = values$correlation_names[1])
  })

  output$TypeVariable4 <- renderUI({
    selectInput("TypeVariable5", "Choose type:", choices = values$correlation_names, selected = values$correlation_names[1])
  })

  output$TypeVariable6 <- renderUI({
    selectInput("TypeVariable7", "Choose type:", choices = values$correlation_names, selected = values$correlation_names[1])
  })

  output$subsetcorr <- renderUI({
    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable1)]]
    if(input$var_switch == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    correlations <- correlations[which(correlations$Base_subtracted == input$Base_subtract),]

    visit.name = colnames(correlations)[3]
    visit <- unique(correlations[,3])
    visit <- gtools::mixedsort(as.character(visit))
    selectInput("subsetcorr1", paste("Subset by", " ",visit.name,":",sep = ""), choices = visit, selected = visit, multiple = TRUE)
  })

  output$WithVariable1 <- renderUI({
    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable1)]]
    if(input$var_switch == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    selectInput("WithVariable", "Choose 'with' variable:", choices = as.character(gtools::mixedsort(unique(correlations$With))), selected = gtools::mixedsort(unique(correlations$With))[1], multiple = TRUE)
  })

  output$WithVariable2 <- renderUI({
    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable3)]]
    if(input$var_switch2 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    selectInput("WithVariable3", "Choose 'with' variable:", choices = as.character(gtools::mixedsort(unique(correlations$With))), selected = as.character(gtools::mixedsort(unique(correlations$With)))[1])
  })

  output$corr_Variable <- renderUI({
    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable7)]]
    selectInput("corr_Variable2", paste("Choose", values$y_var, "variable:", sep = " "), choices = as.character(gtools::mixedsort(unique(correlations$Variable))), selected = as.character(gtools::mixedsort(unique(correlations$With)))[1])
  })

  output$WithVariable4 <- renderUI({
    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable7)]]
    selectInput("WithVariable5", "Choose 'with' variable:", choices = as.character(gtools::mixedsort(unique(correlations$With))), selected = as.character(gtools::mixedsort(unique(correlations$With)))[1])
  })

  output$uploadmod1 <- renderUI({
    if(input$var_switch == FALSE){
      if(values$y_var[which(values$correlation_names == input$TypeVariable1)] == "Flow"){
        return(checkboxInput("uploadmod", strong(paste("Upload"," ",tolower(values$y_var[which(values$correlation_names == input$TypeVariable1)])," ", "variables",":",sep = ""), style = "color:blue"), FALSE))
      }
      else{
        return(checkboxInput("uploadmod", strong(paste("Upload"," ",tolower(values$y_var[which(values$correlation_names == input$TypeVariable1)]),"s",":",sep = ""), style = "color:blue"), FALSE))
      }
    }
    else{
      if(values$x_var[which(values$correlation_names == input$TypeVariable1)] == "Flow"){
        return(checkboxInput("uploadmod", strong(paste("Upload"," ",tolower(values$y_var[which(values$correlation_names == input$TypeVariable1)])," ", "variables",":",sep = ""), style = "color:blue"), FALSE))
      }
      else{
        return(checkboxInput("uploadmod", strong(paste("Upload"," ",tolower(values$x_var[which(values$correlation_names == input$TypeVariable1)]),"s",":",sep = ""), style = "color:blue"), FALSE))
      }
    }
  })

  output$fileupload1 <- renderUI({
    if(input$uploadmod == TRUE){
      return(fileInput('modselect', '', accept = ".csv"))
    }
    else{
      return(NULL)
    }
  })

  output$uploadmod3 <- renderUI({
    if(input$var_switch3 == FALSE){
      if(values$y_var[which(values$correlation_names == input$TypeVariable5)] == "Flow"){
        return(checkboxInput("uploadmod2", strong(paste("Upload"," ",tolower(values$y_var[which(values$correlation_names == input$TypeVariable5)])," ", "variables",":",sep = ""), style = "color:blue"), FALSE))
      }
      else{
        return(checkboxInput("uploadmod2", strong(paste("Upload"," ",tolower(values$y_var[which(values$correlation_names == input$TypeVariable5)]),"s",":",sep = ""), style = "color:blue"), FALSE))
      }
    }
    else{
      if(values$x_var[which(values$correlation_names == input$TypeVariable5)] == "Flow"){
        return(checkboxInput("uploadmod2", strong(paste("Upload"," ",tolower(values$x_var[which(values$correlation_names == input$TypeVariable5)])," ", "variables",":",sep = ""), style = "color:blue"), FALSE))
      }
      else{
        return(checkboxInput("uploadmod2", strong(paste("Upload"," ",tolower(values$x_var[which(values$correlation_names == input$TypeVariable5)]),"s",":",sep = ""), style = "color:blue"), FALSE))
      }
    }
  })

  output$fileupload2 <- renderUI({
    if(input$uploadmod2 == TRUE){
      return(fileInput('modselect2', '', accept = ".csv"))
    }
    else{
      return(NULL)
    }
  })

  h.dat <- reactive({
    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable1)]]
    correlation.type <- colnames(correlations)[4]

    correlations <- correlations[which(correlations$Base_subtracted == input$Base_subtract),]
    correlations <- data.table::as.data.table(correlations)
    correlations$FDR <- 1
    correlations$Bonf <- 1
    correlations[,FDR := p.adjust(Raw.P.Value, method = "fdr"), by = c(names(correlations)[c(2,3)])]
    correlations[,Bonf := p.adjust(Raw.P.Value, method = "bonferroni"), by = c(names(correlations)[c(2,3)])]

    correlations <- as.data.frame(correlations)
    z <- list(correlations = correlations)
  })

  heatmap.data <- reactive({

    if(input$uploadmod == FALSE){
      correlations <- h.dat()$correlations
      if(input$var_switch){
        correlations <- correlations[,c(2,1,3:ncol(correlations))]
        colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
      }
    }

    if(input$uploadmod == TRUE){
      correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable1)]]
      if(input$var_switch == TRUE){
        correlations <- correlations[,c(2,1,3:ncol(correlations))]
        colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
      }
      correlation.type <- colnames(correlations)[4]

      modnames.corr <- read.csv(input$modselect$datapath, header = TRUE)
      modnames.corr <- as.character(modnames.corr[,1])
      modnames.corr <- gsub(".", "_", modnames.corr,fixed = TRUE)

      correlations <- correlations[which(correlations$Base_subtracted == input$Base_subtract),]
      correlations <- correlations[which(correlations$Variable %in% modnames.corr),]

      col_anno <- list()
      col_anno2 <- list()
      dat <- list()
      dat2 <- list()
      keep_names <- list()

      names <- gtools::mixedsort(unique(as.character(correlations[,3])))

      if(input$subsetModcorr == TRUE){
        names <- input$subsetcorr1
      }

      for(j in 1:length(input$WithVariable)){
        correlations1 <- correlations[which(correlations$With %in% input$WithVariable[j]),]
        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat[[i]] <- dat[[i]][which(dat[[i]]$Variable %in% modnames.corr),]
          dat[[i]] <- as.character(dat[[i]]$Variable)
        }

        keep_names[[j]] <- Reduce(intersect, dat)
      }

      keep_names <- unlist(keep_names)

      for(j in 1:length(input$WithVariable)){
        correlations1 <- correlations[which(correlations$With %in% input$WithVariable[j]),]
        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat[[i]] <- dat[[i]][which(dat[[i]]$Variable %in% keep_names),]
          dat[[i]] <- dat[[i]][order(dat[[i]]$Variable),]
          dat[[i]] <- dat[[i]][,4]
          col_anno[[i]] <- input$WithVariable[j]
        }

        col_anno2[[j]] <- unlist(col_anno)
        dat2[[j]] <- do.call("cbind", dat)
        rownames(dat2[[j]]) <- sort(unique(keep_names))
        colnames(dat2[[j]]) <- names
      }

      col_anno <- data.frame(unlist(col_anno2))
      colnames(col_anno)[1] <- paste(values$x_var, "variable", sep = " ")
      dat <- do.call("cbind", dat2)
      z <- list(col_anno = col_anno, dat = dat)
    }

    else{
      correlations <- h.dat()$correlations
      if(input$var_switch){
        correlations <- correlations[,c(2,1,3:ncol(correlations))]
        colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
      }

      dat3 <- list()
      colnames3 <- list()
      rownames3 <- list()

      for(j in 1:length(input$WithVariable)){
        correlations1 <- correlations[which(correlations$With %in% input$WithVariable[j]),]

        dat <- list()
        sig <- list()
        cor_vals <- list()
        names <- gtools::mixedsort(unique(as.character(correlations1[,3])))

        if(input$subsetModcorr == TRUE){
          names <- input$subsetcorr1
        }

        if(input$corrval2 == TRUE){
          if(input$corrsign1 == "+"){
            for(i in 1:length(names)){
              dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
              cor_vals[[i]] <- dat[[i]][which(dat[[i]][,4] >= input$corrval3),]
              cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
            }
          }
          if(input$corrsign1 == "-"){
            for(i in 1:length(names)){
              dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
              cor_vals[[i]] <- dat[[i]][which(dat[[i]][,4] <= -input$corrval3),]
              cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
            }
          }
          if(input$corrsign1 == "Both"){
            for(i in 1:length(names)){
              dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
              cor_vals[[i]] <- dat[[i]][c(which(dat[[i]][,4] <= -input$corrval3),which(dat[[i]][,4] >= input$corrval3)),]
              cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
            }
          }

          cor_vals <- Reduce(union,cor_vals)
          correlations1 <- correlations1[which(correlations1$Variable %in% cor_vals),]
        }

        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]

          if(input$correction_method.corr == "Raw"){
            sig[[i]] <- dat[[i]][which(dat[[i]]$Raw.P.Value <= input$Alpha1),]
          }

          if(input$correction_method.corr == "FDR"){
            sig[[i]] <- dat[[i]][which(dat[[i]]$FDR <= input$Alpha1),]
          }

          if(input$correction_method.corr == "Bonferroni"){
            sig[[i]] <- dat[[i]][which(dat[[i]]$Bonf <= input$Alpha1),]
          }

          sig[[i]] <- as.character(sig[[i]]$Variable)
        }

        sigvars <- Reduce(union,sig)

        correlations1 <- correlations1[which(correlations1$Variable %in% sigvars),]

        dat2 <- list()
        for(i in 1:length(names)){
          dat2[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat2[[i]] <- dat2[[i]][which(dat2[[i]]$Variable %in% sigvars),]$Variable
        }

        dat2 <- Reduce(intersect, dat2)

        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat[[i]] <- dat[[i]][which(dat[[i]]$Variable %in% dat2),]
          dat[[i]] <- dat[[i]][order(dat[[i]]$Variable),]
          dat[[i]] <- dat[[i]][,4]
        }

        dat3[[j]] <- do.call("cbind", dat)
        colnames(dat3[[j]]) <- names
        rownames(dat3[[j]]) <- sort(dat2)
        colnames3[[j]] <- names
        rownames3[[j]] <- sort(dat2)
      }
      rownames3 <- Reduce(union, rownames3)
      dat2 <- list()
      col_anno <- list()
      col_anno2 <- list()

      for(j in 1:length(input$WithVariable)){
        correlations1 <- correlations[which(correlations$With %in% input$WithVariable[j]),]
        dat <- list()
        for(i in 1:length(names)){
          dat[[i]] <- correlations1[which(correlations1[,3] == names[i]),]
          dat[[i]] <- dat[[i]][which(dat[[i]]$Variable %in% rownames3),]
          dat[[i]] <- dat[[i]][order(dat[[i]]$Variable),]
          dat[[i]] <- dat[[i]][,4]
          col_anno[[i]] <- input$WithVariable[j]
        }

        col_anno2[[j]] <- unlist(col_anno)
        dat2[[j]] <- do.call("cbind",dat)
        rownames(dat2[[j]]) <- sort(rownames3)
        colnames(dat2[[j]]) <- names
      }
      dat <- do.call("cbind", dat2)
      col_anno <- as.data.frame(unlist(col_anno2))
      colnames(col_anno)[1] <- paste(values$x_var[which(values$correlation_names == input$TypeVariable1)], "variable", sep = " ")
      if(input$ordercorr == TRUE){
        order_time <- mixedorder(colnames(dat))
        dat <- dat[,order_time]
        col_anno <- as.data.frame(col_anno[order_time,,drop = F])
      }
      z <- list(col_anno = col_anno, dat = dat)
    }

    return(z)
  })

  output$download_heatmap_data <- downloadHandler(
    filename = function() {paste(values$project_name, "_", "Correlation_heatmap_data.csv",sep = "")},
    content = function(file) {
      write.csv(heatmap.data()$dat, file, row.names = TRUE)
    }
  )

  row_clust.corr <- reactive({
    if(input$rowclustcorr == TRUE){return(TRUE)}
    else{
      return(NA)
    }
  })

  col_clust.corr <- reactive({
    if(input$colclustcorr == TRUE){return(TRUE)}
    else{
      return(NA)
    }
  })

  height1 <- function(){
    input$PlotHeight4
  }

  width1 <- function(){
    input$PlotWidth4
  }

  rows.plot <- reactive({
    if(nrow(heatmap.data()$dat) > 300){return(NA)}
    else{return(NULL)}
  })

  color.heatmap <- reactive({
    color_palette <- colorRampPalette(c("blue", "white", "red"))(1000)
    color_palette[c(495:505)] = "#FFFFFF"
    color_palette
  })

  plotresolution.corr <- reactive({
    input$PlotRes4
  })

  output$correlations_plotOverview <- renderPlot({
    if(ncol(heatmap.data()$dat) > 1){
      return(aheatmap2(heatmap.data()$dat,Colv = col_clust.corr(),annCol = heatmap.data()$col_anno,labRow = rows.plot(), color = color.heatmap(), border_color = "grey60", Rowv = row_clust.corr(), main = paste(input$TypeVariable1, "across visits", sep = " "), breaks = 0))
    }
    else{
      return(aheatmap2(heatmap.data()$dat,Colv = col_clust.corr(),labRow = rows.plot(), color = color.heatmap(), border_color = "grey60", Rowv = row_clust.corr(), main = paste(input$TypeVariable1, "across visits", sep = " "), breaks = 0))
    }
  }, height = height1, width = width1)

  output$download_corr_heatmap <- downloadHandler(
    filename = function() {paste(values$project_name,"_","Heatmap.png",sep = "")},
    content = function(file){
      png(file, width = (plotresolution.corr()/72)*width1(), height = (plotresolution.corr()/72)*height1(), res = plotresolution.corr())
      print(aheatmap2(heatmap.data()$dat, annCol = heatmap.data()$col_anno, Colv = col_clust.corr(),labRow = rows.plot(), color = color.heatmap(), border_color = "grey60", Rowv = row_clust.corr(), main = paste(input$TypeVariable1, "across visits", sep = " "), breaks = 0))
      dev.off()
    }
  )

  output$Visit <- renderUI({

    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable3)]]
    if(input$var_switch2 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    correlations <- correlations[which(correlations$Base_subtracted == input$Base_subtract2),]

    visit.name = colnames(correlations)[3]
    visit <- unique(correlations[,3])
    visit <- gtools::mixedsort(as.character(visit))
    selectInput("visit", paste("Correlations by"," ",visit.name, ":", sep = ""), choices = visit, selected = visit[1])
  })

  sub.dat <- reactive({
    if(input$TypeVariable3 == input$TypeVariable1 & input$Base_subtract == input$Base_subtract2){
      correlations <- h.dat()$correlations
      if(input$var_switch2){
        correlations <- correlations[,c(2,1,3:ncol(correlations))]
        colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
      }
      correlations <- correlations[which(correlations$With == input$WithVariable3),]
      correlations <- correlations[which(correlations[,3] == input$visit),]
      z <- list(correlations = correlations)
    }
    else{
      correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable3)]]
      correlations <- correlations[which(correlations$Base_subtracted == input$Base_subtract2),]
      if(input$var_switch2){
        correlations <- correlations[,c(2,1,3:ncol(correlations))]
        colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
      }
      correlations <- correlations[which(correlations$With == input$WithVariable3),]
      correlations <- correlations[which(correlations[,3] == input$visit),]

      correlations$FDR <- p.adjust(correlations$Raw.P.Value, method = "fdr")
      correlations$Bonf <- p.adjust(correlations$Raw.P.Value, method = "bonferroni")
      z <- list(correlations = correlations)
    }
    return(z)
  })

  subset_correlations <- reactive({
    correlations <- sub.dat()$correlations

    if(input$corrval == TRUE){
      if(input$corrsign == "+"){
        correlations <- correlations[which(correlations[,4] >= input$corrval1),]
      }
      if(input$corrsign == "-"){
        correlations <- correlations[which(correlations[,4] <= -input$corrval1),]
      }
      if(input$corrsign == "Both"){
        correlations <- correlations[c(which(correlations[,4] <= -input$corrval1), which(correlations[,4] >= input$corrval1)),]
      }
    }

    if(input$correction_method.corr2 == "Raw"){
      correlations <- correlations[which(correlations$Raw.P.Value <= input$Alpha),]
    }

    if(input$correction_method.corr2 == "FDR"){
      correlations <- correlations[which(correlations$FDR <= input$Alpha),]
    }

    if(input$correction_method.corr2 == "Bonferroni"){
      correlations <- correlations[which(correlations$Bonf <= input$Alpha),]
    }

    correlations <- correlations[,-c(which(colnames(correlations) == "Base_subtracted"), which(colnames(correlations) == "NObs"),
                                     which(colnames(correlations) == "Sign_NegLog10_p"))]
    return(correlations)
  })

  output$download_data <- downloadHandler(
    filename = function() {paste(values$project_name, "_", "Correlations_subset.csv")},
    content = function(file) {
      write.csv(subset_correlations(), file, row.names = FALSE)
    }
  )

  output$correlation_table <- renderDataTable({
    subset_correlations()
  })

  output$Visit2 <- renderUI({

    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable5)]]
    if(input$var_switch3 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    correlations <- correlations[which(correlations$Base_subtracted == input$Base_subtract3),]

    visit.name = colnames(correlations)[3]
    visit <- unique(correlations[,3])
    visit <- gtools::mixedsort(as.character(visit))
    selectInput("visit2", paste("Correlations by", visit.name, ":", sep = " "), choices = visit, selected = visit[1])
  })

  output$subsetcorr2 <- renderUI({

    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable5)]]
    if(input$var_switch3 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    correlations <- correlations[which(correlations$Base_subtracted == input$Base_subtract3),]
    var <- as.character(sort(unique(correlations$With)))
    selectInput("subsetcorr3", paste("Subset by 'with' variable:",sep = ""), choices = var, selected = var[1:5], multiple = TRUE)
  })

  correlation.data <- reactive({

    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable5)]]
    if(input$var_switch3 == TRUE){
      correlations <- correlations[,c(2,1,3:ncol(correlations))]
      colnames(correlations) <- colnames(correlations)[c(2,1,3:ncol(correlations))]
    }
    correlations <- correlations[which(correlations$Base_subtracted == input$Base_subtract3),]
    correlations <- correlations[which(correlations[,3] == input$visit2),]

    if(input$subsetModcorr2 == TRUE){
      correlations <- correlations[which(correlations$With %in% input$subsetcorr3),]
    }

    correlations$FDR <- 1
    correlations$Bonf <- 1
    if(input$var_switch3 == FALSE){
      for(i in 1:length(unique(correlations$With))){
        correlations$FDR[which(correlations$With == unique(correlations$With)[i])] <- p.adjust(correlations$Raw.P.Value[which(correlations$With == unique(correlations$With)[i])], "fdr")
        correlations$Bonf[which(correlations$With == unique(correlations$With)[i])] <- p.adjust(correlations$Raw.P.Value[which(correlations$With == unique(correlations$With)[i])], "bonferroni")
      }
    }
    else{
      for(i in 1:length(unique(correlations$Variable))){
        correlations$FDR[which(correlations$Variable == unique(correlations$Variable)[i])] <- p.adjust(correlations$Raw.P.Value[which(correlations$Variable == unique(correlations$Variable)[i])], "fdr")
        correlations$Bonf[which(correlations$Variable == unique(correlations$Variable)[i])] <- p.adjust(correlations$Raw.P.Value[which(correlations$Variable == unique(correlations$Variable)[i])], "bonferroni")
      }
    }

    if(input$var_switch3 == TRUE){
      y <- values$x_var[which(values$correlation_names == input$TypeVariable5)]
      x <- values$y_var[which(values$correlation_names == input$TypeVariable5)]
    }
    else{
      y <- values$y_var[which(values$correlation_names == input$TypeVariable5)]
      x <- values$x_var[which(values$correlation_names == input$TypeVariable5)]
    }
    dat <- list()
    cor_vals <- list()
    sig <- list()
    names <- as.character(unique(correlations$With))

    if(input$corrval4 == TRUE){
      if(input$corrsign2 == "+"){
        for(i in 1:length(names)){
          dat[[i]] <- correlations[which(correlations$With == names[i]),]
          cor_vals[[i]] <- dat[[i]][which(dat[[i]][,4] >= input$corrval5),]
          cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
        }
      }
      if(input$corrsign2 == "-"){
        for(i in 1:length(names)){
          dat[[i]] <- correlations[which(correlations$With == names[i]),]
          cor_vals[[i]] <- dat[[i]][which(dat[[i]][,4] <= -input$corrval5),]
          cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
        }
      }
      if(input$corrsign2 == "Both"){
        for(i in 1:length(names)){
          dat[[i]] <- correlations[which(correlations$With == names[i]),]
          cor_vals[[i]] <- dat[[i]][c(which(dat[[i]][,4] <= -input$corrval5),which(dat[[i]][,4] >= input$corrval5)),]
          cor_vals[[i]] <- as.character(cor_vals[[i]]$Variable)
        }
      }

      cor_vals <- Reduce(union,cor_vals)
      correlations <- correlations[which(correlations$Variable %in% cor_vals),]
    }


    for(i in 1:length(names)){
      dat[[i]] <- correlations[which(correlations$With == names[i]),]
      if(input$correction_method.corr3 == "Raw"){
        sig[[i]] <- dat[[i]][which(dat[[i]]$Raw.P.Value <= input$Alpha2),]
      }
      if(input$correction_method.corr3 == "FDR"){
        sig[[i]] <- dat[[i]][which(dat[[i]]$FDR <= input$Alpha2),]
      }
      if(input$correction_method.corr3 == "Bonferroni"){
        sig[[i]] <- dat[[i]][which(dat[[i]]$Bonf <= input$Alpha2),]
      }
      sig[[i]] <- as.character(sig[[i]]$Variable)
    }

    sigvars <- Reduce(union,sig)

    correlations <- correlations[which(correlations$Variable %in% sigvars),]

    correlation.type <- colnames(correlations)[4]

    if(input$uploadmod2 == TRUE){
      modnames.corr <- read.csv(input$modselect2$datapath, header = TRUE)
      modnames.corr <- as.character(modnames.corr[,1])
      modnames.corr <- gsub(".", "_", modnames.corr,fixed = TRUE)
      correlations <- correlations[which(correlations$Variable %in% modnames.corr),]
    }

    n = length(unique(correlations$With))
    cor <- list()
    cor_sub <- list()
    names <- unique(correlations$With)

    for(i in 1:n){
      cor[[i]] <- correlations[which(correlations$With == names[i]),]

      if(i > 1){
        cor[[i]] <- cor[[i]][match(cor[[i-1]]$Variable, cor[[i]]$Variable, nomatch = 0),]
      }

      if(input$correction_method.corr3 == "Raw"){
        cor_sub[[i]] <- cor[[i]][,which(colnames(cor[[i]]) %in% c(correlation.type, "Raw.P.Value"))]
      }
      if(input$correction_method.corr3 == "FDR"){
        cor_sub[[i]] <- cor[[i]][,which(colnames(cor[[i]]) %in% c(correlation.type, "FDR"))]
      }
      if(input$correction_method.corr3 == "Bonferroni"){
        cor_sub[[i]] <- cor[[i]][,which(colnames(cor[[i]]) %in% c(correlation.type, "Bonf"))]
      }
      colnames(cor_sub[[i]]) <- c(paste(names[i], "r.val", sep = "."), paste(names[i], "pVal", sep = "."))
    }

    mat1 <- do.call("cbind", cor_sub)
    mat1 <- as.matrix(mat1)
    rownames(mat1) <- cor[[1]]$Variable
    mat1 <- as.data.frame(mat1)

    t = mat1 #mat1 is what you created with the correlation script.
    t$modName<-rownames(t)
    t.pval=reshape2::melt(t[c(length(t),grep("pVal",colnames(t), fixed = TRUE))]) #combine all columns with "pVal" into one loooooong object.
    t.rval=reshape2::melt(t[c(length(t),grep("r.val",colnames(t), fixed = TRUE))]) #combine all columns with "r.val" into one loooooong object.
    GraphFrame=cbind(t.pval,t.rval[,3])  #concaternate them into one matrix
    if(input$correction_method.corr3 == "Raw"){
      colnames(GraphFrame)=c(y,"Correlation","Raw.pVal","rVal")  #change column names
    }
    if(input$correction_method.corr3 == "FDR"){
      colnames(GraphFrame)=c(y,"Correlation","FDR.pVal","rVal")  #change column names
    }
    if(input$correction_method.corr3 == "Bonferroni"){
      colnames(GraphFrame)=c(y,"Correlation","Bonf.pVal","rVal")  #change column names
    }

    GraphFrame[,which(colnames(GraphFrame) == y)] = factor(GraphFrame[,which(colnames(GraphFrame) == y)],levels=unique(GraphFrame[,which(colnames(GraphFrame) == y)],order=T))  #this is super important as it makes sure the order on the axis is correct!
    GraphFrame$Correlation <- gsub(".pVal", "",GraphFrame$Correlation, fixed = TRUE)
    z <- list(GraphFrame = GraphFrame, y = y, x = x)
    return(z)
  })

  output$download_plot_data <- downloadHandler(
    filename = function() {paste(values$project_name, "_", "correlations_data.csv")},
    content = function(file) {
      write.csv(correlation.data()$GraphFrame, file, row.names = FALSE)
    }
  )

  height <- function(){
    input$PlotHeight3
  }

  width <- function(){
    input$PlotWidth3
  }

  plotresolution.corr1 <- reactive({
    input$PlotRes3
  })


  correlations_makePlot <- reactive({
    y <- correlation.data()$y
    x <- correlation.data()$x
    GraphFrame <- correlation.data()$GraphFrame
    if(input$correction_method.corr3 == "Raw"){
      GraphFrame <- GraphFrame[-which(GraphFrame$Raw.pVal >= input$Alpha2),]
      p <- GraphFrame$Raw.pVal
    }
    if(input$correction_method.corr3 == "FDR"){
      GraphFrame <- GraphFrame[-which(GraphFrame$FDR.pVal >= input$Alpha2),]
      p <- GraphFrame$FDR.pVal
    }
    if(input$correction_method.corr3 == "Bonferroni"){
      GraphFrame <- GraphFrame[-which(GraphFrame$Bonf.pVal >= input$Alpha2),]
      p <- GraphFrame$Bonf.pVal
    }
    p[p < .0001] <- .0001 #set log-10 transformed p-values <4 (=0.0001) to 4
    RV <- ifelse(GraphFrame$rVal>0,GraphFrame$rVal^4,(GraphFrame$rVal^4)*-1)

    if(length(p)/length(unique(GraphFrame$Correlation)) <= 260){
      graph <- ggplot(data = GraphFrame, aes(Correlation, GraphFrame[,1],colour=RV, size = p), environment = environment()) + labs(y = y, x = x)  + scale_size_continuous("P-value",range=c(12,4),limits = c(min(p), .06), breaks = c(round(min(p),4),round((min(p)+.05)/2,4),.05)) + geom_point(colour="black",aes(size = p),shape=21,alpha=I(1)) + geom_point(alpha=I(.75))  + theme_minimal()  +
        theme(panel.background=element_rect(fill="white"),
              panel.grid = element_line(),panel.grid.major.y=element_blank(),
              panel.grid.major.x = element_blank(),
              axis.text.y=element_text(hjust=0),
              axis.text.x=element_text(angle=45,vjust=1,hjust=1)) +
        scale_x_discrete(expand=c(0,1)) +
        scale_color_gradient2(paste(values$correlation_method,"'s r",sep = ""),GraphFrame$rVal, low="navy", high="red", breaks=c(min(RV),0,max(RV)), labels = c(as.character(round(-1*(-1*min(RV))^(1/4),3)),"0",as.character(round(max(RV)^(1/4),3))))
    }

    if(length(p)/length(unique(GraphFrame$Correlation)) > 260){
      graph <- ggplot(data = GraphFrame, aes(Correlation, GraphFrame[,1],colour=RV, size = p), environment = environment()) + labs(y = y, x = x)  + scale_size_continuous("P-value",range=c(12,4),limits = c(min(p), .06), breaks = c(round(min(p),4),round((min(p)+.05)/2,4),.05)) + geom_point(colour="black",aes(size = p),shape=21,alpha=I(1)) + geom_point(alpha=I(.75))  + theme_minimal()  +
        theme(panel.background=element_rect(fill="white"),
              panel.grid = element_line(),panel.grid.major.y=element_blank(),
              panel.grid.major.x = element_blank(),
              axis.text.y=element_blank(),
              axis.text.x=element_text(angle=45,vjust=1,hjust=1)) +
        scale_x_discrete(expand=c(0,1)) + scale_y_discrete(breaks = NULL) +
        scale_color_gradient2(paste(values$correlation_method,"'s r",sep = ""),GraphFrame$rVal, low="navy", high="red", breaks=c(min(RV),0,max(RV)), labels = c(as.character(round(-1*(-1*min(RV))^(1/4),3)),"0",as.character(round(max(RV)^(1/4),3))))
    }

    return(graph)
  })

  output$correlations_plot <- renderPlot({
    correlations_makePlot()
  }, height = height, width = width)

  output$download_corr_plot <- downloadHandler(
    filename = function() {paste(values$project_name, "_","significant_correlations_plot.png")},
    content = function(file){
      png(file, width = (plotresolution.corr1()/72)*width(), height = (plotresolution.corr1()/72)*height(), res = plotresolution.corr1())
      print(correlations_makePlot())
      dev.off()
    }
  )

  output$Visit3 <- renderUI({

    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable7)]]
    visit.name = colnames(correlations)[3]
    visit <- unique(correlations[,3])
    visit <- gtools::mixedsort(as.character(visit))
    selectInput("visit3", paste("Correlations by"," ",visit.name, ":", sep = ""), choices = visit, selected = visit[1])
  })


  scatter_plot <- reactive({
    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable7)]]
    correlation_file <- values$correlation_files[[which(values$correlation_names == input$TypeVariable7)]]
    x <- correlation_file[,input$WithVariable5][which(correlation_file[,colnames(correlations)[3]] == input$visit3)]
    y <- correlation_file[,input$corr_Variable2][which(correlation_file[,colnames(correlations)[3]] == input$visit3)]
    z <- list(x = x, y = y)
    return(z)
  })

  scatter_width <- function(){
    input$PlotWidth5
  }

  scatter_height <- function(){
    input$PlotHeight5
  }

  plot_res5 <- reactive({
    input$PlotRes5
  })


  axis_text_size <- reactive({
    input$axis_text_size
  })

  axis_label_size <- reactive({
    input$axis_label_size
  })

  scatter_makePlot <- reactive({
    correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable7)]]
    if(input$log_scale == TRUE){
      dat <- data.frame(x = scatter_plot()$x, y = log2(scatter_plot()$y + 1))
    }
    else{
      dat <- data.frame(x = scatter_plot()$x, y = scatter_plot()$y)
    }
    scat.plot <-  ggplot(data = dat, aes(x = x, y = y)) + geom_point(size = input$Point_size) + theme_bw()+
      labs(x = paste(input$WithVariable5, colnames(correlations)[3], input$visit3, sep = " "), y = paste(input$corr_Variable2, colnames(correlations)[3], input$visit3, sep = " ")) +
      theme(axis.text = element_text(size = axis_text_size()), axis.title = element_text(size = axis_label_size()))

    if(input$plot_reg == TRUE){
      scat.plot <- scat.plot + geom_smooth(method = "lm", se = FALSE)
    }
    if(input$plot_loess == TRUE){
      if(input$plot_reg == TRUE){
        scat.plot <- scat.plot + geom_smooth(method = "lm", se = FALSE)
      }
      else{
        scat.plot <- scat.plot + geom_smooth(method = "loess", se = FALSE, span = input$span)
      }
    }
    z <- list(scatplot = scat.plot, dat = dat)
    return(z)
  })


  output$correlations_scatter_plot <- renderPlot({
    scatter_makePlot()$scatplot
  }, width = scatter_width, height = scatter_height)


  output$download_scatter_data <- downloadHandler(
    filename = function() {correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable7)]]
    paste(values$project_name, "_",input$corr_Variable2, "vs", input$WithVariable5, "_", colnames(correlations)[3], input$visit3,"_data.csv")},
    content = function(file) {
      dat <- scatter_makePlot()$dat
      colnames(dat) <- c(input$WithVariable5, input$corr_Variable2)
      write.csv(dat, file, row.names = FALSE)
    }
  )

  output$download_scatter <- downloadHandler(
    filename = function() {correlations <- values$correlations[[which(values$correlation_names == input$TypeVariable7)]]
    paste(values$project_name, "_",input$corr_Variable2, "vs", input$WithVariable5, "_", colnames(correlations)[3], input$visit3,".png")},
    content = function(file){
      png(file, width = (plot_res5()/72)*width(), height = (plot_res5()/72)*height(), res = plot_res5())
      print(scatter_makePlot()$scatplot)
      dev.off()
    }
  )
  
################End of Correlations Part###################

  })
